# FE-013: Exec start (hijacked stream)

**Component:** FE (Docker REST API frontend)
**Phase:** 1
**Depends on:** FE-012, FE-002
**Estimated effort:** L

---

## Description

Implement the exec start endpoint with HTTP connection hijacking and bidirectional multiplexed streaming. This is the PRIMARY mechanism for GitHub Actions Runner -- every workflow step is executed via `docker exec` into the job container. The endpoint hijacks the HTTP connection after the initial response headers, establishing a raw bidirectional byte stream using Docker's 8-byte header multiplexed frame protocol. The frontend bridges the hijacked client connection to the backend/agent, framing agent stdout/stderr into multiplexed frames and forwarding client stdin to the agent.

This is one of the most critical endpoints in the entire system. GitHub Runner has NO retry logic for exec failures -- if exec fails once, the workflow step fails immediately.

---

## Context

### Exec start protocol (Spec Section 4.4)

> `POST /exec/{id}/start` -- Start Exec Instance
>
> Request body:
> ```json
> {
>   "Detach": false,
>   "Tty": false
> }
> ```
>
> Response: Connection hijack with multiplexed stream (same as attach). This is another **connection-hijacking** endpoint.
>
> When `Detach: false`, the response hijacks the HTTP connection and streams stdin/stdout/stderr bidirectionally. The exec command runs inside the already-running container.
>
> **This is the primary mechanism for GitHub Actions Runner** -- every workflow step is `docker exec` into the job container.

### Connection hijacking protocol (Spec Section 5.3)

> The `attach` and `exec/start` endpoints use HTTP connection hijacking:
>
> 1. Client sends HTTP POST request
> 2. Server responds with `101 Switching Protocols` (or `200 OK` with `Connection: Upgrade`)
> 3. The TCP connection is now a raw bidirectional byte stream
> 4. Server writes multiplexed frames for stdout/stderr
> 5. Client writes raw bytes for stdin
> 6. Connection closes when the command/container exits

### Multiplexed stream protocol (Spec Section 5.2)

> When `Tty: false` (which is always the case for CI runners), attach and exec use Docker's multiplexed stream format:
>
> ```
> +--------+--------+--------+--------+--------+--------+--------+--------+
> | STREAM | 0x00   | 0x00   | 0x00   | SIZE1  | SIZE2  | SIZE3  | SIZE4  |
> +--------+--------+--------+--------+--------+--------+--------+--------+
> ```
>
> - Byte 0 (STREAM): `0` = stdin, `1` = stdout, `2` = stderr
> - Bytes 1-3: Padding (zeros)
> - Bytes 4-7: Payload size as big-endian uint32
> - Following bytes: Payload (exactly SIZE bytes)
>
> GitLab Runner uses `stdcopy.StdCopy` from the Docker Go SDK to demultiplex this. Any incorrect framing breaks CI job output.

### GitHub Runner exec behavior (Spec Section 13.2.4)

> **Exec with stdin (`-i`):**
> The runner uses `docker exec -i` for ALL step executions. The `-i` flag keeps stdin open -- the runner pipes the step script into the container. Exit codes are read from the `docker exec` process return code (not from `docker inspect`).
>
> **No exec retry:**
> If `docker exec` fails (container not running, connection lost, etc.), the step fails immediately. There is NO exponential backoff or retry logic for exec. This means the exec facility must be reliable from the first attempt.

### Exec reliability (Spec Section 13.3, Gap 11)

> The agent starts its WebSocket server as the first thing on startup (before running the user process). The backend waits for agent readiness (health probe to agent's WebSocket endpoint) before returning from `POST /containers/{id}/start`. By the time the runner calls `docker exec`, the agent is guaranteed to be listening.

### Stream framing responsibility (Spec Section 13.3, Gap 13)

> The frontend is responsible for correct framing. The agent sends raw stdout/stderr bytes via WebSocket JSON messages. The frontend wraps each chunk in the 8-byte header format:
> - Byte 0: stream type (1=stdout, 2=stderr)
> - Bytes 1-3: padding (0x00)
> - Bytes 4-7: payload length (big-endian uint32)
> - Followed by payload bytes
>
> For stdin (client -> agent), the frontend reads raw bytes from the hijacked connection and forwards them as `{"type":"stdin","data":"<base64>"}` WebSocket messages.

---

## Acceptance Criteria

1. `POST /exec/{id}/start` accepts a JSON body with fields: `Detach` (bool) and `Tty` (bool).
2. When `Detach: false`, the HTTP connection is hijacked after initial response headers.
3. The response uses `Content-Type: application/vnd.docker.multiplexed-stream` when `Tty: false`.
4. The response uses `Content-Type: application/vnd.docker.raw-stream` when `Tty: true`.
5. Server writes stdout data in multiplexed frames with stream type byte `0x01`.
6. Server writes stderr data in multiplexed frames with stream type byte `0x02`.
7. Client stdin bytes are forwarded to the exec process as raw input.
8. The connection closes when the exec process exits.
9. The exec process exit code is available via `GET /exec/{id}/json` after completion.
10. `POST /exec/{id}/start` returns `404` with `{"message": "No such exec instance: <id>"}` if the exec does not exist.
11. `POST /exec/{id}/start` returns `409` with `{"message": "Exec <id> has already been started"}` if the exec has already been started.
12. When `Detach: true`, the response is `200 OK` with no body, and the exec runs in the background.
13. The multiplexed framing is byte-accurate: 8-byte header followed by exactly SIZE bytes of payload. `stdcopy.StdCopy` from the Docker SDK must be able to demultiplex the output without errors.
14. Stdin pipe closure (client closes write side) is propagated to the exec process as EOF on its stdin.
15. The exec instance's `Running` field transitions from `false` to `true` during execution and back to `false` on completion.

### Example Requests

```bash
# Start an exec instance (interactive, non-TTY)
# Note: curl cannot fully demonstrate hijacked streams; this shows the HTTP portion
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{"Detach": false, "Tty": false}' \
  http://localhost/v1.44/exec/e90e34656806072/start
# Response: 101 Switching Protocols
# Content-Type: application/vnd.docker.multiplexed-stream
# Connection: Upgrade
# Upgrade: tcp
#
# <hijacked bidirectional multiplexed stream follows>

# Start an exec instance (detached)
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{"Detach": true, "Tty": false}' \
  http://localhost/v1.44/exec/a1b2c3d4e5f6/start
# Response: 200 OK (empty body)

# Start a non-existent exec
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{"Detach": false, "Tty": false}' \
  http://localhost/v1.44/exec/nonexistent/start
# Response: 404
# {"message":"No such exec instance: nonexistent"}

# Verify exit code after exec completes
curl -s --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/exec/e90e34656806072/json
# Response: 200
# {"ID":"e90e34656806072...","Running":false,"ExitCode":0,"Pid":42}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for: exec start with stdout/stderr capture, exec start with stdin piping, exit code propagation, multiplexed frame correctness (verifiable via `stdcopy.StdCopy`), detached mode, error cases (not found, already started)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (NotFound, Conflict)
- [ ] Errors wrapped with context: `fmt.Errorf("exec start: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated if new public API is added

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Uses the multiplexed stream library from FE-002
- [ ] Exec state from FE-012 is read and updated correctly
- [ ] Capability model consulted (exec not supported on FaaS backends)

---

## Suggested File Paths

```
frontends/docker/
├── handler_exec_start.go     # POST /exec/{id}/start handler
├── hijack.go                 # Shared connection hijacking utilities (may already exist from FE-009)
└── routes.go                 # Register new route (update existing)
```

---

## Notes

- The connection hijacking for exec start is identical in protocol to attach (FE-009). Reuse the hijacking and stream bridging infrastructure built for attach.
- GitHub Runner's `docker exec -i` maps to `AttachStdin: true` in the exec create body. The exec start handler must check the exec config to know whether to expect stdin from the client.
- The exit code from the exec process is the step result for GitHub Runner. This MUST be accurate. A process that exits with code 1 must result in ExitCode=1 in the exec inspect response.
- Docker allows starting an exec instance exactly once. A second call to `POST /exec/{id}/start` returns 409. Track the "started" state.
- When the parent container stops while an exec is running, the exec should terminate and report a non-zero exit code. The connection should close cleanly.
- The `Tty: true` case uses raw stream (no multiplexing). While CI runners always use `Tty: false`, implement both paths for completeness. In raw stream mode, stdout and stderr are merged into a single stream without headers.
- Memory backend can simulate exec by recording the command and returning a configurable exit code. The actual process execution happens only with cloud backends via the agent.
- Concurrent exec instances on the same container must be supported. GitHub Runner may run step setup and the step itself in overlapping exec calls.
