# TST-010: ECS integration tests

**Component:** Test Infrastructure and Suites
**Phase:** 2
**Depends on:** ECS-002, ECS-003, ECS-004
**Estimated effort:** L

---

## Description

Integration tests for the ECS Fargate backend. Tests exercise the full container lifecycle -- create, start, inspect, logs, stop, remove -- on real AWS Fargate tasks. Tests also verify agent connectivity (WebSocket exec/attach through the frontend) and CloudWatch log retrieval. These tests require valid AWS credentials and a pre-configured Fargate cluster; they are skipped in CI environments where credentials are not available.

---

## Context

### AWS ECS Fargate mapping (Spec Section 9.1)

| Docker Concept | ECS Mapping |
|---|---|
| Container create + start | `RunTask` (Fargate launch type) with task definition registered from container config |
| Container stop | `StopTask` |
| Container kill | `StopTask` (ECS has no SIGKILL; tasks get 30s SIGTERM then forced stop) |
| Container remove | Deregister task definition, clean up |
| Container inspect | `DescribeTasks` |
| Container logs | CloudWatch Logs (`GetLogEvents` / `FilterLogEvents`) |
| Exec / Attach | Via sockerless-agent (agent address from task's ENI private IP) |
| Image pull | ECS pulls from ECR / Docker Hub / any registry natively |

### Agent networking (Spec Section 9.1)

Fargate tasks get private IPs in the configured VPC. The frontend must be able to reach these IPs (same VPC, VPC peering, or transit gateway). The agent listens on port 9111 -- the security group must allow inbound from the frontend.

### Startup latency (Spec Section 9.1)

ECS Fargate startup latency is 10-45 seconds (image pull + Fargate capacity allocation). Tests must account for this with appropriate timeouts.

### Container logs via CloudWatch (ECS-004)

The ECS backend retrieves container logs from CloudWatch Logs using `GetLogEvents` or `FilterLogEvents`. Logs are formatted into Docker's multiplexed stream protocol (8-byte header framing) before being returned to the client.

### Agent injection (Spec Section 8.6)

The backend injects the sockerless-agent into cloud containers by modifying the entrypoint to: `["/sockerless-agent", "--", <original-entrypoint>]`. For ECS, injection uses volume mount (from EFS) or init container. The agent starts the original command as a child process and serves WebSocket connections for exec/attach.

### Container state mapping

| ECS Task Status | Docker State |
|---|---|
| PROVISIONING | created |
| PENDING | created |
| RUNNING | running |
| DEPROVISIONING | running (stopping) |
| STOPPED (exitCode 0) | exited (ExitCode: 0) |
| STOPPED (exitCode != 0) | exited (ExitCode: N) |

---

## Acceptance Criteria

### Prerequisites

1. Tests detect AWS credentials via environment (`AWS_ACCESS_KEY_ID` / `AWS_SECRET_ACCESS_KEY` or `AWS_PROFILE`). If absent, all tests in this file are skipped with `t.Skip("AWS credentials not available")`.
2. Tests read the ECS cluster name and VPC configuration from environment variables (`SOCKERLESS_ECS_CLUSTER`, `SOCKERLESS_ECS_SUBNETS`, `SOCKERLESS_ECS_SECURITY_GROUP`).

### Container lifecycle

3. `POST /containers/create` with `Image: "alpine:latest"` and `Cmd: ["echo", "hello from fargate"]` returns `201` with a valid container ID.
4. `POST /containers/{id}/start` returns `204` and blocks until the Fargate task reaches RUNNING status (within 120s timeout).
5. `GET /containers/{id}/json` returns `State.Status: "running"` after start completes, with `NetworkSettings.IPAddress` set to a valid private IP.
6. `GET /containers/{id}/json` after the container's command completes returns `State.Status: "exited"` and `State.ExitCode: 0`.
7. `POST /containers/{id}/stop` on a running container returns `204` and the container transitions to exited state.
8. `DELETE /containers/{id}` removes the container from state and deregisters the ECS task definition.

### Container list and filtering

9. `GET /containers/json?all=true` includes the ECS-backed container with correct `Image`, `State`, and `Names` fields.
10. `GET /containers/json?filters={"label":["test-run=ecs-integration"]}` returns only containers with the matching label.

### Logs

11. `GET /containers/{id}/logs?stdout=true&stderr=true` retrieves log output from CloudWatch. For a container that ran `echo hello from fargate`, the response includes `hello from fargate`.
12. Logs are returned with Docker's multiplexed stream framing (8-byte header, stream_type=1 for stdout).
13. `GET /containers/{id}/logs?timestamps=true` prepends RFC3339 timestamps to each log line.

### Agent connectivity

14. After starting a container with `Cmd: ["tail", "-f", "/dev/null"]` (long-running), `POST /containers/{id}/exec` with `Cmd: ["echo", "exec-works"]` returns `201` with an exec ID.
15. `POST /exec/{id}/start` returns the hijacked stream containing `exec-works` in the stdout output.
16. Exec exit code is `0` for a successful command (verified via `GET /exec/{id}/json`).
17. Exec with `Cmd: ["sh", "-c", "exit 7"]` reports `ExitCode: 7` in `GET /exec/{id}/json`.

### Cleanup

18. All containers, task definitions, and CloudWatch log groups created during the test are cleaned up in `t.Cleanup`, even if the test fails.

### Example Requests

```bash
# These examples assume sockerless is running with the ECS backend
# and the frontend is listening on the default socket.

# Create container on Fargate
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/create \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine:latest","Cmd":["echo","hello from fargate"],"Labels":{"test-run":"ecs-integration"}}'
# Expected: 201 {"Id":"abc123...","Warnings":[]}

# Start container (blocks until Fargate task is RUNNING)
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/abc123/start
# Expected: 204

# Inspect container
curl --unix-socket /var/run/sockerless.sock \
  http://localhost/containers/abc123/json | jq '{Status: .State.Status, IP: .NetworkSettings.IPAddress}'
# Expected: {"Status":"running","IP":"10.0.1.47"}

# Get logs from CloudWatch
curl --unix-socket /var/run/sockerless.sock \
  "http://localhost/containers/abc123/logs?stdout=true&stderr=true"
# Expected: multiplexed stream containing "hello from fargate"

# Remove container
curl --unix-socket /var/run/sockerless.sock \
  -X DELETE http://localhost/containers/abc123
# Expected: 204
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 18 acceptance criteria pass
- [ ] Tests are skipped (not failed) when AWS credentials are absent
- [ ] Each test uses unique container names with `t.Name()` + random suffix to avoid collisions
- [ ] All AWS resources (tasks, task definitions, log groups) are cleaned up via `t.Cleanup`
- [ ] Timeouts account for Fargate startup latency (120s for start, 30s for stop)
- [ ] Tests reuse helpers from TST-003 (container lifecycle) and TST-005 (exec) where possible

---

## Suggested File Paths

```
tests/
├── ecs_test.go                    # TestECSContainerLifecycle, TestECSContainerList,
│                                  # TestECSContainerLogs, TestECSAgentExec, TestECSCleanup
└── helpers/
    ├── ecs.go                     # skipIfNoAWS, ecsClusterConfig, waitForFargateRunning
    ├── container.go               # (from TST-003) reused for create/start/inspect/remove
    ├── exec.go                    # (from TST-005) reused for exec create/start/inspect
    └── mux_stream.go              # (from TST-004) reused for log stream parsing
```

---

## Notes

- These tests are slow (each Fargate task takes 10-45s to start). Group related assertions into single test functions to minimize the number of Fargate tasks created. For example, test create+start+inspect+logs+stop+remove as one sequential flow.
- Use `t.Parallel()` cautiously -- each parallel test creates a Fargate task, which costs money and may hit ECS service quotas.
- CloudWatch log delivery has latency (typically 5-15 seconds after container output). The log retrieval test should retry with backoff up to 30 seconds.
- The agent connectivity tests (AC 14-17) require the agent to be injected into the container image. Ensure the ECS backend's agent injection mechanism is configured (init container or EFS volume mount).
- For cleanup reliability, use `t.Cleanup` rather than `defer` to ensure cleanup runs even on `t.Fatal`. Register cleanup immediately after creating each resource.
- The container used for exec tests (AC 14-17) should run `tail -f /dev/null` to stay alive. This is the same pattern GitHub Actions Runner uses.
- Consider adding a `TestECSStartTimeout` test that verifies the frontend returns an error (not a hang) if the Fargate task fails to reach RUNNING within the timeout period. Use an invalid image to trigger this.
- AWS costs: each test run creates real Fargate tasks. Keep the test suite lean and add a `-short` flag check to skip ECS tests in quick development cycles.
