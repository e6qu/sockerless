# ECS-002: ECS container create and start

**Component:** ECS (AWS ECS Fargate backend)
**Phase:** 2
**Depends on:** ECS-001, AG-005
**Estimated effort:** XL

---

## Description

Implement `ContainerCreate` and `ContainerStart` for the ECS backend. Container create registers an ECS task definition from the container config (image, env, cmd, resource limits, volumes, network). Container start calls `RunTask` on Fargate, polls `DescribeTasks` until the task reaches RUNNING state, resolves the agent address from the task's ENI private IP, and verifies agent readiness before returning. The start call MUST block until the container is actually running -- this is critical because GitHub Actions Runner checks container status immediately after start.

---

## Context

### ECS container mapping (Spec Section 9.1)

> | Docker Concept | ECS Mapping |
> |---|---|
> | Container create + start | `RunTask` (Fargate launch type) with task definition registered from container config |
> | Image | Container image in task definition container definition |
> | Env | `environment` key-value pairs in container definition |
> | Cmd | `command` in container definition |
> | Resource limits | `cpu` and `memory` at task level |
> | Binds | EFS volume mounts in task definition |

### Near-instant container start (Spec Section 13.3, Gap 2)

> **Problem:** After `docker start`, the runner immediately runs `docker ps --filter status=running` to verify the container started. Docker containers start in <1s. Cloud backends take 5-60s.
>
> **Solution:** The `POST /containers/{id}/start` endpoint MUST block until the cloud task is actually running (agent is reachable). Only then return `204 No Content`. This way, the subsequent `docker ps` check sees "running" status.
>
> **Implementation:** Backend launches cloud task -> polls cloud API for task status -> returns 204 only when task is in "RUNNING" state. Frontend forwards the 204 to the Docker client.

### Agent injection (Spec Section 8.6)

> The backend modifies the container's entrypoint to: `["/sockerless-agent", "--", <original-entrypoint>]`
>
> The agent starts the original command as a child process and serves WebSocket connections for exec/attach.

### Agent readiness (Spec Section 13.3, Gap 11)

> **Agent readiness check:** Backend polls `ws://agent:9111/health` (a simple HTTP GET on the same port). Agent responds with `200 OK` once its WebSocket server is accepting connections. Backend only returns `204` from start once this check passes.

---

## Acceptance Criteria

1. `ContainerCreate` accepts a `ContainerCreateRequest` and registers an ECS task definition via `RegisterTaskDefinition`.
2. The task definition maps: `Image` -> container definition image, `Env` -> container definition environment, `Cmd` -> container definition command, `Entrypoint` -> container definition entry point.
3. CPU and memory are mapped from Docker's resource limits: `HostConfig.NanoCPUs` / `HostConfig.CpuShares` -> ECS task CPU (256/512/1024/2048/4096), `HostConfig.Memory` -> ECS task memory. Defaults: 256 CPU (0.25 vCPU), 512 MB memory.
4. The task definition includes the `awslogs` log driver with the configured CloudWatch log group, stream prefix, and region.
5. The task definition uses the configured execution role ARN (for pulling images from ECR) and optional task role ARN (for in-container AWS API access).
6. The agent is injected into the container: the entrypoint is modified to `["/sockerless-agent", "--", <original-entrypoint>, <original-cmd>...]` or `["/sockerless-agent", "--keep-alive", "--"]` for tail-f-dev-null containers. Agent env vars (`SOCKERLESS_AGENT_PORT`, `SOCKERLESS_AGENT_TOKEN`) are added.
7. A unique agent token is generated (32 random bytes, hex-encoded) and stored in the state for later retrieval by the frontend.
8. The container is stored in the state with status `"created"` and a generated 64-char hex ID. The state includes the task definition ARN, agent token, and all original config.
9. `ContainerCreate` returns `ContainerCreateResponse` with the generated ID and any warnings.
10. `ContainerStart` calls `RunTask` with Fargate launch type, configured cluster, subnets, and security groups.
11. `ContainerStart` polls `DescribeTasks` at 2-second intervals until the task status is `RUNNING`. Maximum wait: 5 minutes (configurable). If the task fails to start (status `STOPPED`), return an error with the stop reason.
12. Once the task is RUNNING, the backend extracts the task's ENI private IP from the `attachments` field of the `DescribeTasks` response.
13. The backend constructs the agent address as `<eni-private-ip>:9111` and stores it in the container state.
14. The backend polls `http://<agent-address>/health` until the agent responds with `200 OK`. Timeout: 60 seconds. Poll interval: 1 second.
15. Only after the agent is confirmed ready does `ContainerStart` return success (204).
16. Container state is updated to `"running"` with `StartedAt` timestamp.
17. Labels from the container create request are applied as ECS task tags.

### Example SDK Calls

```go
// RegisterTaskDefinition
ecs.RegisterTaskDefinition(&ecs.RegisterTaskDefinitionInput{
    Family: "sockerless-<container-id-prefix>",
    RequiresCompatibilities: []types.Compatibility{types.CompatibilityFargate},
    NetworkMode: types.NetworkModeAwsvpc,
    Cpu: "256",
    Memory: "512",
    ExecutionRoleArn: &executionRoleArn,
    TaskRoleArn: &taskRoleArn,
    ContainerDefinitions: []types.ContainerDefinition{{
        Name: "main",
        Image: &image,
        Command: entrypoint,
        Environment: envVars,
        LogConfiguration: &types.LogConfiguration{
            LogDriver: types.LogDriverAwslogs,
            Options: map[string]string{
                "awslogs-group":         logGroup,
                "awslogs-region":        region,
                "awslogs-stream-prefix": containerID[:12],
            },
        },
    }},
})

// RunTask
ecs.RunTask(&ecs.RunTaskInput{
    Cluster: &cluster,
    TaskDefinition: &taskDefArn,
    LaunchType: types.LaunchTypeFargate,
    NetworkConfiguration: &types.NetworkConfiguration{
        AwsvpcConfiguration: &types.AwsVpcConfiguration{
            Subnets:        subnets,
            SecurityGroups: securityGroups,
            AssignPublicIp: types.AssignPublicIpDisabled,
        },
    },
    Tags: tags,
})

// DescribeTasks (polling)
ecs.DescribeTasks(&ecs.DescribeTasksInput{
    Cluster: &cluster,
    Tasks:   []string{taskArn},
})
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests with mock AWS clients for: task definition registration, RunTask call, DescribeTasks polling (running, stopped, timeout), ENI IP extraction, agent readiness polling, agent token generation, tail-f-dev-null detection and keep-alive flag
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] AWS API errors mapped to Docker-compatible error responses
- [ ] Task startup failures include ECS stop reason in error message
- [ ] Agent unreachable after task RUNNING produces clear error
- [ ] Errors wrapped with context: `fmt.Errorf("ecs: container start: %w", err)`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated with container lifecycle details

### Integration
- [ ] State store updated correctly for each lifecycle transition
- [ ] Agent injection compatible with AG-005 (keep-alive) and AG-002/AG-003 (exec/attach)
- [ ] Task tags include sockerless container ID for later lookup

---

## Suggested File Paths

```
backends/ecs/
├── container_create.go      # ContainerCreate: task definition registration, state creation
├── container_start.go       # ContainerStart: RunTask, polling, ENI extraction, agent readiness
├── taskdef.go               # Task definition builder (maps Docker config -> ECS task def)
├── agent_inject.go          # Agent entrypoint modification, token generation
├── store.go                 # (update) Container state with task ARN, agent address, agent token
└── errors.go                # (update) ECS-specific error mapping
```

---

## Notes

- ECS Fargate resource mappings: CPU must be one of 256, 512, 1024, 2048, 4096 (units of 1/1024 vCPU). Memory depends on CPU. Use the closest valid value that meets or exceeds the Docker request. If no resource limits are specified, default to 256 CPU / 512 MB.
- The `awsvpc` network mode is required for Fargate. Each task gets its own ENI with a private IP.
- ENI IP extraction from `DescribeTasks`: the attachment with `type: "ElasticNetworkInterface"` contains a `details` map with key `"privateIPv4Address"`.
- For the agent binary injection, the initial approach is to require the agent binary in the container image (either baked in or via an init container). A more sophisticated approach (volume mount from EFS) can be added in ECS-005. Document the requirement that images must include the agent binary at `/sockerless-agent`.
- The tail-f-dev-null detection: check if `Entrypoint == ["tail"]` and `Cmd == ["-f", "/dev/null"]`. Also check variations like `Entrypoint == ["tail", "-f", "/dev/null"]` with empty Cmd.
- Consider implementing eager container provisioning: when `ContainerCreate` is called, begin provisioning the Fargate task immediately (not waiting for `ContainerStart`). This reduces the perceived startup latency. However, this is an optimization that can be added later.
