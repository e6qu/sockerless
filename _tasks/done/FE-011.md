# FE-011: Container stop, kill, and remove

**Component:** FE (Docker REST API frontend)
**Phase:** 1
**Depends on:** FE-005
**Estimated effort:** M

---

## Description

Implement the three container lifecycle termination endpoints: stop, kill, and remove. These are used by both GitLab Runner and GitHub Actions Runner during cleanup. GitLab Runner's cleanup sequence is: kill(SIGTERM) -> stop(timeout=0) -> network disconnect -> remove(force=true, removeVolumes=true). GitHub Actions Runner uses: remove(force=true). All three endpoints delegate to the backend for actual cloud task termination and state cleanup.

---

## Context

### Container stop (Spec Section 4.3)

> `POST /containers/{id}/stop`
>
> Query parameter: `t` (int): Seconds to wait before killing (default: 10)
>
> Sends SIGTERM, waits `t` seconds, then SIGKILL. For sockerless, translates to the cloud backend's stop/terminate mechanism.
>
> Response: `204 No Content`

### Container kill (Spec Section 4.3)

> `POST /containers/{id}/kill`
>
> Query parameter: `signal` (string): Signal to send (default: `SIGKILL`)
>
> Immediate termination. For sockerless, translates to force-stopping the cloud backend task.
>
> Response: `204 No Content`

### Container remove (Spec Section 4.3)

> `DELETE /containers/{id}`
>
> Query parameters:
> - `v` (bool): Remove associated anonymous volumes
> - `force` (bool): Kill and remove even if running
>
> Sockerless: Remove the container from internal state. If the cloud backend task is still running and `force=true`, stop it first. Clean up any associated cloud resources (volumes, network attachments).
>
> Response: `204 No Content`

### GitLab Runner cleanup sequence (Spec Section 13.1.2)

> ```
> 8. Cleanup (5-minute timeout, parallel)
>    For each container:
>      ContainerKill(id, "SIGTERM")
>      ContainerStop(id, timeout=0)
>      NetworkDisconnect(networkID, id, force=true)
>      ContainerRemove(id, force=true, removeVolumes=true)
>    NetworkRemove(networkID)
>    VolumeRemove(volumeID)
> ```

### GitHub Actions Runner cleanup (Spec Section 13.2.2)

> ```
> 10. Cleanup
>     docker rm --force <job-container>       # kill + remove
>     docker rm --force <service-container>   # for each
> ```

### Error response format (Spec Section 5.4)

> All errors follow Docker's format: `{"message": "No such container: abc123"}`

---

## Acceptance Criteria

1. `POST /containers/{id}/stop` accepts optional query parameter `t` (integer seconds, default 10).
2. `POST /containers/{id}/stop` returns `204 No Content` when the container is successfully stopped.
3. `POST /containers/{id}/stop` returns `304 Not Modified` if the container is already stopped.
4. `POST /containers/{id}/stop` returns `404` with `{"message": "No such container: <id>"}` if the container does not exist.
5. `POST /containers/{id}/kill` accepts optional query parameter `signal` (string, default `SIGKILL`).
6. `POST /containers/{id}/kill` returns `204 No Content` on success.
7. `POST /containers/{id}/kill` returns `404` with `{"message": "No such container: <id>"}` if the container does not exist.
8. `POST /containers/{id}/kill` returns `409` with `{"message": "Container <id> is not running"}` if the container is not running.
9. `DELETE /containers/{id}` accepts optional query parameters `v` (bool) and `force` (bool).
10. `DELETE /containers/{id}` returns `204 No Content` on success.
11. `DELETE /containers/{id}` returns `404` with `{"message": "No such container: <id>"}` if the container does not exist.
12. `DELETE /containers/{id}?force=true` kills a running container before removing it (no error for running containers).
13. `DELETE /containers/{id}` without `force=true` returns `409` with `{"message": "You cannot remove a running container <id>. Stop the container before attempting removal or force remove"}` if the container is running.
14. After a successful `DELETE`, the container no longer appears in `GET /containers/json?all=true`.
15. Container state transitions to `"exited"` after stop/kill, with appropriate `ExitCode` and `FinishedAt` timestamp.
16. All three endpoints accept both full container ID and name for `{id}` path parameter.

### Example Requests

```bash
# Stop a container with default timeout (10s)
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/containers/abc123def456/stop
# Response: 204 No Content

# Stop a container with custom timeout
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/abc123def456/stop?t=5"
# Response: 204 No Content

# Stop an already-stopped container
curl -s -o /dev/null -w "%{http_code}" -X POST --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/containers/abc123def456/stop
# Response: 304 Not Modified

# Kill a container with SIGTERM
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/abc123def456/kill?signal=SIGTERM"
# Response: 204 No Content

# Kill a container with default signal (SIGKILL)
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/containers/abc123def456/kill
# Response: 204 No Content

# Remove a stopped container
curl -s -X DELETE --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/containers/abc123def456
# Response: 204 No Content

# Force remove a running container (kill + remove)
curl -s -X DELETE --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/abc123def456?force=true&v=true"
# Response: 204 No Content

# Remove a non-existent container
curl -s -X DELETE --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/containers/nonexistent
# Response: 404
# {"message":"No such container: nonexistent"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for: stop (success, already stopped, not found), kill (success, not running, not found), remove (success, force, running without force, not found)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (NotFound, Conflict)
- [ ] Errors wrapped with context: `fmt.Errorf("stop container: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated if new public API is added

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model consulted (backend may not support signal-based kill)

---

## Suggested File Paths

```
frontends/docker/
├── handler_container_stop.go    # POST /containers/{id}/stop handler
├── handler_container_kill.go    # POST /containers/{id}/kill handler
├── handler_container_remove.go  # DELETE /containers/{id} handler
└── routes.go                    # Register new routes (update existing)
```

---

## Notes

- The `signal` query parameter for kill should accept both `SIGKILL` and `9` formats. Map named signals to their numeric equivalents when delegating to the backend.
- GitLab Runner calls kill(SIGTERM) then stop(timeout=0) in sequence. The stop with timeout=0 means immediate SIGKILL if not already stopped. This is a valid pattern and should not produce errors.
- GitHub Runner uses `docker rm --force` which maps to `DELETE /containers/{id}?force=true`. This combines kill + remove in a single call.
- The `v=true` query parameter on DELETE should also clean up anonymous volumes associated with the container. Named volumes are NOT removed by this flag.
- When `force=true`, the remove endpoint should not return an error if the container is running -- it should kill first, then remove.
- Container state must be updated to "exited" after stop/kill, even if the cloud backend task termination is asynchronous. The state store should reflect the stopped state immediately.
