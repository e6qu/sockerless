# TST-009: Agent tests

**Component:** Test Infrastructure and Suites
**Phase:** 2
**Depends on:** AG-002, AG-003
**Estimated effort:** M

---

## Description

Integration tests for the sockerless agent's WebSocket server. Tests cover the exec flow (fork+exec a child process, receive stdout/stderr, exit code), the attach flow (pipe stdio of the main process), keep-alive mode, and error handling. Tests connect directly to the agent's WebSocket endpoint on port 9111, send JSON messages, and validate the response messages. These tests validate the agent in isolation -- no frontend or backend is involved.

---

## Context

### Agent WebSocket server (Spec Section 8.1)

The agent runs inside the cloud container and listens for WebSocket connections on port 9111. The frontend connects on demand when a user triggers an exec, attach, or streaming logs operation.

```
Frontend ── WebSocket CONNECT ──→ Agent (ws://host:9111/)
           Authorization: Bearer <token>
```

### Authentication (Spec Section 8.2)

The backend generates a one-time token injected as `SOCKERLESS_AGENT_TOKEN`. The agent validates `Authorization: Bearer <token>` on every WebSocket upgrade request and rejects unauthorized connections.

### WebSocket message protocol (Spec Section 8.3)

All messages are JSON with a `type` field.

**Client -> Agent:**

| Type | Fields | Purpose |
|------|--------|---------|
| `exec` | `id`, `cmd`, `env`, `workdir`, `tty` | Fork a new process |
| `attach` | `id` | Attach to main process (PID 1 child) |
| `stdin` | `id`, `data` (base64) | Pipe bytes to process stdin |
| `signal` | `id`, `signal` | Send signal (SIGTERM, SIGKILL) |
| `close_stdin` | `id` | Close process stdin (EOF) |

**Agent -> Client:**

| Type | Fields | Purpose |
|------|--------|---------|
| `stdout` | `id`, `data` (base64) | Process stdout bytes |
| `stderr` | `id`, `data` (base64) | Process stderr bytes |
| `exit` | `id`, `code` | Process exited with code |
| `error` | `id`, `message` | Error (process not found, etc.) |

The `id` field identifies the exec/attach session and supports multiple concurrent sessions over the same WebSocket.

### Exec flow (Spec Section 8.5)

The exec message causes the agent to fork+exec a child process. Stdout/stderr are streamed back as JSON messages. When the process exits, an `exit` message with the exit code is sent.

### Attach flow (Spec Section 8.4)

The attach message connects to PID 1's child process (or the wrapped process started by the agent). Stdin/stdout/stderr are bridged over WebSocket.

### Keep-alive mode (AG-005)

`--keep-alive` flag: agent starts with no child process, stays alive, and serves exec/attach requests. The container entrypoint is effectively `sockerless-agent --keep-alive` (equivalent to `tail -f /dev/null` but with agent capabilities). Used by GitHub Actions Runner pattern where the container idles and all work happens via exec.

---

## Acceptance Criteria

### Authentication

1. A WebSocket connection with a valid `Authorization: Bearer <token>` header succeeds (101 upgrade).
2. A WebSocket connection with an invalid token is rejected with HTTP 401.
3. A WebSocket connection with no `Authorization` header is rejected with HTTP 401.

### Exec flow

4. Sending `{"type":"exec","id":"e1","cmd":["echo","hello"]}` produces a `stdout` message containing `hello\n` followed by an `exit` message with `code: 0`.
5. Sending an exec with `cmd: ["sh", "-c", "echo err >&2"]` produces a `stderr` message containing `err\n`.
6. Sending an exec with `cmd: ["sh", "-c", "exit 42"]` produces an `exit` message with `code: 42`.
7. Sending an exec with `env: ["FOO=bar"]` and `cmd: ["sh", "-c", "echo $FOO"]` produces stdout containing `bar\n`.
8. Sending an exec with `workdir: "/tmp"` and `cmd: ["pwd"]` produces stdout containing `/tmp\n`.
9. Sending an exec with a non-existent command (e.g., `cmd: ["/nonexistent"]`) produces an `error` message.

### Stdin piping

10. After sending an exec with `cmd: ["cat"]`, sending `{"type":"stdin","id":"e1","data":"<base64 of hello>"}` followed by `{"type":"close_stdin","id":"e1"}` produces stdout containing `hello` and then `exit` with `code: 0`.

### Signal handling

11. After sending an exec with `cmd: ["sleep", "3600"]`, sending `{"type":"signal","id":"e1","signal":"SIGTERM"}` produces an `exit` message with a non-zero code (128+15 = 143 on Linux).

### Attach flow

12. When the agent is started wrapping a command (e.g., `sockerless-agent -- cat`), sending `{"type":"attach","id":"a1"}` followed by stdin data and `close_stdin` produces the corresponding stdout output and eventually an `exit` message.

### Concurrent sessions

13. Two exec sessions with different `id` values can run simultaneously over the same WebSocket connection, and their stdout/exit messages arrive with the correct `id`.

### Keep-alive mode

14. When started with `--keep-alive`, the agent does not exit on its own and accepts exec requests indefinitely (test: send exec, wait for exit, send another exec, wait for exit).

### Example Requests

```bash
# Start the agent (in a separate terminal for manual testing)
SOCKERLESS_AGENT_TOKEN=test-token ./sockerless-agent --keep-alive

# Connect via websocat (WebSocket CLI tool)
websocat ws://localhost:9111/ -H "Authorization: Bearer test-token"

# Send exec message (type into websocat)
{"type":"exec","id":"e1","cmd":["echo","hello"]}
# Expected response: {"type":"stdout","id":"e1","data":"aGVsbG8K"}
# Expected response: {"type":"exit","id":"e1","code":0}

# Send exec with non-zero exit
{"type":"exec","id":"e2","cmd":["sh","-c","exit 42"]}
# Expected response: {"type":"exit","id":"e2","code":42}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 14 acceptance criteria pass
- [ ] Agent binary is built and started as a subprocess in test setup
- [ ] Each test uses a unique session `id` to avoid cross-test interference
- [ ] Tests have timeouts (5s per test) to avoid hanging on agent crashes
- [ ] WebSocket connection is closed in test cleanup

---

## Suggested File Paths

```
tests/
├── agent_test.go                  # TestAgentAuth, TestAgentExec, TestAgentStdin,
│                                  # TestAgentSignal, TestAgentAttach, TestAgentConcurrent,
│                                  # TestAgentKeepAlive
└── helpers/
    ├── agent.go                   # startAgent (subprocess), stopAgent, newAgentWSConn
    └── ws.go                      # sendWSMessage, readWSMessage, expectWSMessage helpers
```

---

## Notes

- The agent is tested in isolation -- tests start the agent binary as a subprocess and connect directly via WebSocket. No frontend or backend is involved.
- Use `os/exec.Command` to start the agent subprocess. Set `SOCKERLESS_AGENT_TOKEN` in the environment. Wait for the agent to be ready by polling the WebSocket endpoint before running tests.
- Use `gorilla/websocket` (or `nhooyr.io/websocket`) as the WebSocket client in tests.
- Base64-encode stdin data and decode stdout/stderr data per the protocol spec.
- For the attach flow test (AC 12), start the agent wrapping a simple command like `cat`. This requires a separate agent subprocess with a different configuration than keep-alive mode.
- For concurrent session tests (AC 13), use goroutines with `sync.WaitGroup` to send two exec messages and collect responses, then verify each response has the correct `id`.
- Signal handling behavior depends on the OS. On Linux, SIGTERM causes exit code 143 (128 + 15). On macOS, the exit code may differ. Use `code != 0` as the assertion rather than an exact value, or skip on non-Linux.
- Keep-alive mode tests should verify the agent does not exit between exec requests. Send two sequential exec commands with a short delay between them.
