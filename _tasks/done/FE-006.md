# FE-006: GET /containers/{id}/json (Inspect)

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** FE-004
**Estimated effort:** M

---

## Description

Implement the `GET /containers/{id}/json` endpoint (container inspect). This returns the full container metadata including State, Config, HostConfig, and NetworkSettings. CI runners rely heavily on specific fields from this response -- GitLab Runner reads state and network info, while GitHub Actions Runner reads environment variables (for PATH extraction) and health check status.

## Context

### Container Inspect (spec Section 4.3)

CI runners rely on specific fields:

| Field | GitLab Runner Reads | GitHub Runner Reads |
|-------|:---:|:---:|
| `State.Status` ("created", "running", "exited") | Yes | -- |
| `State.Running` (bool) | Yes | -- |
| `State.ExitCode` (int) | Yes | -- |
| `State.Health.Status` ("healthy", "unhealthy", "starting") | -- | Yes |
| `Config.Env` (array) | -- | Yes (PATH extraction) |
| `Config.Healthcheck` (object) | -- | Yes (presence check) |
| `NetworkSettings.IPAddress` | Yes | -- |
| `NetworkSettings.Networks.<name>.IPAddress` | Yes | -- |
| `NetworkSettings.Ports` | -- | Yes (port mapping) |

### Response Structure (spec Section 4.3)

```json
{
  "Id": "<64-char-hex>",
  "Created": "2026-02-15T12:00:00Z",
  "Name": "/container-name",
  "State": {
    "Status": "running",
    "Running": true,
    "Paused": false,
    "Restarting": false,
    "OOMKilled": false,
    "Dead": false,
    "Pid": 1,
    "ExitCode": 0,
    "Error": "",
    "StartedAt": "2026-02-15T12:00:01Z",
    "FinishedAt": "0001-01-01T00:00:00Z",
    "Health": {
      "Status": "healthy",
      "FailingStreak": 0,
      "Log": []
    }
  },
  "Config": {
    "Image": "nginx:latest",
    "Env": ["PATH=/usr/local/sbin:..."],
    "Cmd": ["nginx"],
    "Entrypoint": null,
    "Hostname": "...",
    "Labels": {},
    "ExposedPorts": {},
    "Tty": false,
    "OpenStdin": false,
    "Healthcheck": null,
    "WorkingDir": ""
  },
  "HostConfig": { "..." },
  "NetworkSettings": {
    "IPAddress": "10.0.0.5",
    "Ports": {
      "80/tcp": [{"HostIp": "0.0.0.0", "HostPort": "8080"}]
    },
    "Networks": {
      "bridge": {
        "IPAddress": "10.0.0.5",
        "Aliases": ["db"],
        "NetworkID": "..."
      }
    }
  }
}
```

### Gap 3: Image Config for PATH Extraction (spec Section 13.3)

**Problem:** GitHub Actions Runner reads `Config.Env` from `docker inspect` to extract the `PATH` environment variable. Sockerless doesn't pull images locally, so it doesn't have the image config.

**Solution:** When `POST /images/create` (pull) is called, the backend fetches the image's manifest and config blob from the registry API WITHOUT downloading layers. The image config contains `Env`, `Cmd`, `Entrypoint`, etc. These are stored and merged into `GET /containers/{id}/json` -> `Config.Env`.

The inspect response MUST merge the image config `Env` with the user-specified `Env` from the create request. Image env vars come first, then user env vars override them (matching Docker behavior). This is critical for PATH -- the image defines `PATH=/usr/local/sbin:...` and the user may add `CI=true` but not redefine PATH.

### Internal API (spec Section 7.3)

Frontend sends: `GET /internal/v1/containers/{id}`

## Acceptance Criteria

1. `GET /containers/{id}/json` returns `200 OK` with full container metadata JSON
2. Returns `404 Not Found` with `{"message": "No such container: <id>"}` if container does not exist
3. `State.Status` reflects the actual state: `"created"`, `"running"`, or `"exited"`
4. `State.Running` is `true` when status is `"running"`, `false` otherwise
5. `State.ExitCode` is `0` for running/created containers, actual exit code for exited containers
6. `State.StartedAt` and `State.FinishedAt` are valid RFC3339 timestamps
7. `Config.Env` merges image env vars with user env vars (image first, user overrides)
8. `Config.Image`, `Config.Cmd`, `Config.Entrypoint`, `Config.Labels`, `Config.Tty` all reflect create-time values
9. `HostConfig` includes all fields from the create request (Binds, NetworkMode, Memory, etc.)
10. `NetworkSettings.IPAddress` is populated for running containers
11. `NetworkSettings.Networks` includes per-network IP addresses and aliases
12. `Name` field includes the leading `/` prefix (e.g., `"/mycontainer"`)
13. Container ID prefix matching works (first 12+ chars)
14. Container name matching works
15. `State.Health` is present only if the image defines a HEALTHCHECK; omitted otherwise

### Example Requests

```bash
# Inspect by full ID
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2/json" | jq .
# { "Id": "a1b2c3...", "State": { "Status": "running", ... }, ... }

# Inspect by short ID
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/json" | jq '.State.Status'
# "running"

# Inspect by name
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/mycontainer/json" | jq '.Config.Env'
# ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "CI=true"]

# Inspect a created (not started) container
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/newcontainer/json" | jq '.State'
# { "Status": "created", "Running": false, "ExitCode": 0, ... }

# Container not found
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/nonexistent/json"
# 404 {"message":"No such container: nonexistent"}
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Env merge logic tested: image PATH + user CI=true results in both in Config.Env
- [ ] All state values tested: created, running, exited
- [ ] NetworkSettings populated for running containers
- [ ] Health field conditionally present based on image HEALTHCHECK

## Suggested File Paths

```
frontends/docker/
├── handler_container_inspect.go   # GET /containers/{id}/json handler
└── types_container.go             # Inspect response types (shared with create)
```

## Notes

- The env merge logic is critical for GitHub Actions compatibility. Docker merges image config `Env` with user `Env` at create time. If the user specifies `ENV=value` and the image also has `ENV=imagevalue`, the user's value wins. If the user does not redefine a variable, the image's value persists. This is a key=value merge, not a simple concatenation.
- The `State.Health` field should only be present if the image defines a `HEALTHCHECK` instruction. If no healthcheck is configured, omit `Health` entirely from the response (or set to `null`). GitHub Runner checks for the *presence* of `Config.Healthcheck` to decide whether to poll health status.
- `FinishedAt` for containers that have not exited should be `"0001-01-01T00:00:00Z"` (Go zero time), matching Docker's behavior.
- The `Pid` field can be `0` or `1` for Sockerless containers (there is no real PID to report for cloud containers). Use `1` for running containers and `0` for stopped.
- `NetworkSettings.Ports` should reflect the port bindings from `HostConfig.PortBindings`, expanded into the inspect format.
