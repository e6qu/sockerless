# FE-001: Frontend HTTP Server Scaffold

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** API-002, API-003
**Estimated effort:** L

---

## Description

Build the foundational HTTP server for the Sockerless Docker-compatible frontend. This server listens on a Unix socket and/or TCP address, routes requests through Docker API version middleware, logs all requests via zerolog, and delegates operations to a backend process over an internal API. This task produces a runnable binary (`sockerless-docker-frontend`) that accepts configuration from YAML, environment variables, and CLI flags.

The server does not implement any Docker endpoints yet (those are separate tasks). It provides the routing framework, middleware stack, backend client, and binary entrypoint that all endpoint tasks build on.

## Context

### Architecture (spec Section 6.3)

The frontend is a **stateless** HTTP server that:

1. Listens on a Unix socket (or TCP) and speaks Docker Engine REST API v1.44
2. Accepts connections from any Docker-compatible client (Docker CLI, Podman, SDKs, Compose, Testcontainers)
3. Translates Docker REST API requests into internal API calls to the backend
4. Handles Docker-specific protocol features: multiplexed streams, connection hijacking, `X-Registry-Auth` headers
5. On exec/attach requests, opens a WebSocket connection to the agent inside the cloud container and bridges the Docker client's hijacked connection to the agent's WebSocket

### API Versioning (spec Section 5.1)

All requests may include a version prefix: `/v1.44/containers/json`. Sockerless accepts `v1.44` and treats unversioned requests as v1.44. Requests for versions > 1.44 return `400 Bad Request` with:
```json
{"message": "client version 1.XX is too new. Maximum supported API version is 1.44"}
```

### Error Response Format (spec Section 5.4)

All errors follow Docker's format:
```json
{"message": "No such container: abc123"}
```

### Frontend Configuration (spec Section 15.2)

```yaml
# sockerless-frontend.yaml
listen:
  socket: /var/run/sockerless.sock   # Unix socket path
  tcp: ""                            # Optional TCP address (e.g., "0.0.0.0:2375")

backend:
  address: /var/run/sockerless-backend.sock  # Backend Unix socket or TCP address

api:
  version: "1.44"                    # Docker API version to advertise

logging:
  level: info                        # debug, info, warn, error
  format: json                       # json, text
```

Priority order: CLI flags > Environment variables > YAML config file > Defaults.

### Internal API Transport (spec Section 7.2)

| Operation Type | Transport | Examples |
|---|---|---|
| CRUD (request-response) | HTTP/JSON | create/start/stop/inspect/list/remove |
| Streaming (long-lived) | WebSocket | logs with `follow=true`, container wait |

All internal API routes are prefixed with `/internal/v1/`.

## Acceptance Criteria

1. `sockerless-docker-frontend` binary compiles and runs from `cmd/sockerless-frontend/main.go`
2. Server listens on a Unix socket (default `/var/run/sockerless.sock`) and responds to HTTP requests
3. Server optionally listens on a TCP address when configured (e.g., `0.0.0.0:2375`)
4. Router registers Docker API route patterns (placeholder handlers returning 404 initially)
5. Requests with `/v1.44/` prefix are routed identically to unversioned requests
6. Requests with a version prefix > 1.44 (e.g., `/v1.99/...`) return `400` with `{"message": "client version 1.99 is too new. Maximum supported API version is 1.44"}`
7. Requests to unrecognized paths return `404` with `{"message": "page not found"}`
8. Every request is logged via zerolog with method, path, status code, and duration
9. Backend client connects to the backend process at the configured address and can perform health checks
10. Configuration loads from YAML file, with env var overrides (`SOCKERLESS_LISTEN_SOCKET`, `SOCKERLESS_BACKEND_ADDRESS`, etc.) and CLI flag overrides (`--socket`, `--backend-address`, etc.)
11. Graceful shutdown on SIGTERM/SIGINT: stop accepting new connections, drain in-flight requests

### Example Requests

```bash
# Server running on Unix socket
curl --unix-socket /var/run/sockerless.sock http://localhost/v1.44/nonexistent
# Expected: 404 {"message": "page not found"}

# Version too new
curl --unix-socket /var/run/sockerless.sock http://localhost/v1.99/containers/json
# Expected: 400 {"message": "client version 1.99 is too new. Maximum supported API version is 1.44"}

# Unversioned route (treated as v1.44)
curl --unix-socket /var/run/sockerless.sock http://localhost/containers/json
# Expected: 404 (no handler registered yet, but route pattern matched)

# Server running on TCP
curl http://localhost:2375/v1.44/_ping
# Expected: 404 (ping handler not implemented in this task)
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Binary entrypoint works: `go run ./cmd/sockerless-frontend/main.go --help`
- [ ] Version middleware tested with versioned and unversioned routes
- [ ] Config loads from YAML, env vars, and CLI flags with correct precedence
- [ ] Graceful shutdown tested (sends SIGTERM, verify clean exit)

## Suggested File Paths

```
frontends/docker/
├── go.mod
├── go.sum
├── README.md
├── server.go              # HTTP server setup, listener management
├── router.go              # Route registration, version prefix handling
├── middleware.go           # Version middleware, request logging middleware
├── config.go              # Config struct, YAML/env/flag loading
├── backend_client.go      # HTTP client for internal API to backend
├── errors.go              # Docker-format error response helpers
└── cmd/
    └── sockerless-frontend/
        └── main.go        # Binary entrypoint
```

## Notes

- Use `gorilla/mux` or `chi` as the router. Both support path variables (`{id}`) and subrouting. Chi is lighter; gorilla/mux is more feature-rich. Either works.
- The version prefix middleware should strip the `/v1.44/` prefix before passing to the router, so all route handlers work with unversioned paths.
- The backend client should support both Unix socket and TCP addresses. Use `net.Dial("unix", path)` for Unix sockets via a custom `http.Transport`.
- Docker clients (including the Go SDK) default to API version negotiation: they call `GET /_ping`, read the `API-Version` header, and use that version for subsequent requests. The version middleware must handle this correctly.
- Consider using `github.com/spf13/viper` for config or a simpler approach with `gopkg.in/yaml.v3` + `os.Getenv` + `flag`.
- The module path is `github.com/sockerless/frontend`.
