# GCR-001: Cloud Run backend scaffold

**Component:** GCR (Google Cloud Run backend)
**Phase:** 3
**Depends on:** API-002
**Estimated effort:** M

---

## Description

Build the scaffold for the Google Cloud Run backend. This backend translates internal API calls into Cloud Run Jobs operations, running containers as Cloud Run job executions. This task sets up the binary entrypoint, GCP SDK clients, configuration loading, capability reporting, and the HTTP server for the internal API. Individual operations (container create/start, logs, images, networking, volumes) are implemented in subsequent GCR-* tasks.

---

## Context

### Cloud Run backend mapping (Spec Section 9.1)

> | Docker Concept | Cloud Run Mapping |
> |---|---|
> | Container create + start | `CreateJob` + `RunJob` (or `CreateExecution`) |
> | Container stop | `CancelExecution` |
> | Container logs | Cloud Logging (`entries.list`) |
> | Exec / Attach | Via sockerless-agent (agent on Cloud Run's ingress port) |
> | Image pull | Cloud Run pulls from Artifact Registry / GCR / Docker Hub natively |
> | Network | VPC Connector or Direct VPC Egress |
> | Volume | Cloud Storage FUSE, GCS, in-memory (tmpfs) |
>
> **Agent networking:** Cloud Run containers serve traffic on the port defined by `PORT` env var. The agent can share this port (mux HTTP + WebSocket) or use Cloud Run's sidecar support. Frontend reaches agent via Cloud Run's internal URL.
>
> **Startup latency:** 5-30 seconds.

### Capability reporting (Spec Section 9.5)

Cloud Run backend capabilities:
```json
{
  "backend": "cloudrun",
  "version": "0.1.0",
  "capabilities": {
    "exec": true,
    "attach": true,
    "logs": true,
    "logs_follow": true,
    "volumes": true,
    "networks": true,
    "health_checks": true,
    "image_pull": true,
    "image_load": true,
    "max_timeout_seconds": 86400,
    "agent_required": true
  }
}
```

Note: `exec` and `attach` are provided via the sockerless-agent, not natively by Cloud Run. Cloud Run Jobs support up to 24 hours of execution time. Volumes are "Partial" (GCS FUSE only, no block storage).

### Cloud Run backend configuration (derived from Spec Section 15.3)

> ```yaml
> cloudrun:
>   project: my-gcp-project
>   region: us-central1
>   vpc_connector: "projects/my-project/locations/us-central1/connectors/sockerless"
>   gcs_bucket: sockerless-volumes
>   log_filter: ""
> ```

---

## Acceptance Criteria

1. `sockerless-backend-cloudrun` binary compiles and runs from `cmd/sockerless-backend-cloudrun/main.go`.
2. Server listens on a Unix socket (default `/var/run/sockerless-backend.sock`) or TCP address for internal API requests.
3. GCP SDK clients are initialized for: Cloud Run Jobs v2 (`run.googleapis.com/v2`), Cloud Logging (`logging.googleapis.com/v2`), Cloud DNS, and Artifact Registry.
4. Configuration loads from YAML file, environment variables, and CLI flags (priority: flags > env > file > defaults). Required config: `project`, `region`. Optional: `vpc_connector`, `gcs_bucket` (default `sockerless-volumes`), `log_filter`.
5. `GET /internal/v1/capabilities` returns the capability JSON with `backend: "cloudrun"`, `agent_required: true`, `exec: true`, `attach: true`, `logs: true`, `logs_follow: true`, `volumes: true`, `networks: true`, `max_timeout_seconds: 86400`.
6. In-memory state store (or SQLite -- consistent with backend configuration from Spec Section 15.3) for containers, images, networks, volumes, execs -- mapping sockerless IDs to GCP resource names.
7. State store maps: `container_id -> {job_name, execution_name, agent_address, agent_token, ...}`, `network_id -> {vpc_connector, dns_zone_name, ...}`, `volume_name -> {gcs_path, ...}`, `image_ref -> {config, digest, ...}`.
8. GCP credentials are loaded via the standard Application Default Credentials chain (env var `GOOGLE_APPLICATION_CREDENTIALS`, gcloud default config, metadata server, workload identity).
9. Error responses use Docker's `{"message": "..."}` format. GCP API errors are mapped to appropriate HTTP status codes (e.g., `PermissionDenied` -> 500, `NotFound` -> 404).
10. Graceful shutdown on SIGTERM/SIGINT: drain in-flight requests, clean exit.
11. All requests logged via zerolog with method, path, status code, duration, and GCP request metadata where applicable.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests for: configuration loading (YAML, env, flags, defaults), capability reporting, state store CRUD operations, GCP error mapping
- [ ] Tests use mock GCP clients (no real GCP calls in unit tests)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] GCP API errors wrapped with context: `fmt.Errorf("cloudrun: create job: %w", err)`
- [ ] Zerolog structured logging on all error paths with GCP error details
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created with Cloud Run backend overview, configuration, and prerequisites

### Integration
- [ ] Implements Backend interface from API-002 (stub methods return NotImplementedError for operations not yet implemented)
- [ ] Capability model accurately reflects Cloud Run backend features

---

## Suggested File Paths

```
backends/cloudrun/
├── go.mod                              # module github.com/sockerless/backend-cloudrun, go 1.23
├── go.sum
├── README.md
├── server.go                           # HTTP server setup, route registration
├── capabilities.go                     # Capability reporting handler
├── config.go                           # YAML + env + flag config loading
├── gcp.go                              # GCP SDK client initialization (Cloud Run, Logging, DNS, AR)
├── store.go                            # State store (container/network/volume -> GCP resource mapping)
├── errors.go                           # GCP error -> HTTP error mapping
└── cmd/
    └── sockerless-backend-cloudrun/
        └── main.go                     # Binary entrypoint
```

---

## Notes

- Use the Google Cloud Go SDK (`cloud.google.com/go/run/apiv2` for Cloud Run Jobs v2, `cloud.google.com/go/logging` for Cloud Logging, `cloud.google.com/go/dns` for Cloud DNS, `cloud.google.com/go/artifactregistry` for Artifact Registry).
- The state store must map between sockerless's 64-char hex IDs and GCP resource names (e.g., `projects/PROJECT/locations/REGION/jobs/JOB_NAME`). A single SQL table or in-memory map per resource type is sufficient.
- For the state store, consider SQLite via `modernc.org/sqlite` (pure Go, no CGO) for persistence across restarts. The memory backend uses in-memory maps, but a production Cloud Run backend benefits from surviving restarts.
- GCP error handling: use `status.Code(err)` from `google.golang.org/grpc/status` to extract gRPC status codes. Map `codes.PermissionDenied` -> 500, `codes.NotFound` -> 404, `codes.AlreadyExists` -> 409, etc.
- The GCP project must exist and the Cloud Run API must be enabled before the backend starts. Consider a startup validation check (`ListJobs` or similar) that logs a warning if the API is not accessible.
- Cloud Run Jobs v2 API is the current version. Do NOT use the deprecated v1 API.
- Agent networking on Cloud Run: the agent listens on the port defined by the `PORT` env var (Cloud Run routes ingress traffic to this port). The frontend reaches the agent via the Cloud Run service/job's internal URL. This is fundamentally different from ECS (where the agent is on a private IP:9111).
- Import `github.com/sockerless/api` for shared types and the `Backend` interface.
- Environment variable mapping for configuration: `SOCKERLESS_CLOUDRUN_PROJECT`, `SOCKERLESS_CLOUDRUN_REGION`, `SOCKERLESS_CLOUDRUN_VPC_CONNECTOR`, `SOCKERLESS_CLOUDRUN_GCS_BUCKET`. The prefix `SOCKERLESS_CLOUDRUN_` is stripped and the remainder is lowercased to match YAML keys.
- Cloud Run Jobs have a different networking model than ECS. ECS tasks get private IPs directly; Cloud Run Jobs use VPC Connectors or Direct VPC Egress for VPC access. The backend must handle both modes. VPC Connector is the simpler setup; Direct VPC Egress is newer and avoids the connector overhead.
- Startup validation should verify: (a) the GCP project exists and is accessible, (b) the Cloud Run Admin API (`run.googleapis.com`) is enabled, (c) the configured region is valid, (d) if a VPC connector is specified, it exists. Log warnings for any failures but do not block startup -- the errors will surface when operations are attempted.
- The state store exec mapping `exec_id -> {container_id, cmd, working_dir, env, ...}` tracks exec instances created via `POST /containers/{id}/exec` for later use by `POST /exec/{id}/start` and `GET /exec/{id}/json`.
