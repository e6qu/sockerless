# SIM-001: Simulator framework scaffold

**Component:** Simulator
**Phase:** 2
**Depends on:** ---
**Estimated effort:** L

---

## Description

Build the shared framework for cloud service simulators. Each simulator is a Go HTTP server that implements the cloud provider's REST/gRPC API surface (the subset used by Sockerless backends). The framework provides common infrastructure: HTTP server with TLS support, request routing by service, in-memory state management, request/response logging, and SDK endpoint override configuration.

The key design principle: simulators must be compatible with the official SDKs and CLIs. AWS SDK Go v2, Google Cloud Go SDK, and Azure SDK for Go should all work against these simulators by simply overriding the endpoint URL. This means the simulators must:

- Accept the same authentication headers (but not validate real credentials)
- Return responses in the exact same JSON/XML format the real APIs return
- Support the same API versioning (AWS uses action-based routing with `X-Amz-Target`, GCP uses REST paths like `/v2/projects/...`, Azure uses ARM paths with `api-version` query parameter)
- Return appropriate error responses in the provider's native error format

Each cloud provider has a distinct API style. The shared framework abstracts common concerns while allowing each simulator to implement provider-specific routing and serialization.

---

## Context

### Simulator purpose (project rationale)

Sockerless backends (ECS, Cloud Run, ACA) call cloud provider APIs to manage containers, logs, networking, volumes, and container registries. Testing these backends against real cloud APIs is slow, expensive, and flaky. Simulators provide a fast, free, deterministic alternative that runs locally or in CI.

### AWS API style

AWS services use JSON over HTTP POST with action-based routing. The `X-Amz-Target` header identifies the service and action (e.g., `AmazonEC2ContainerServiceV20141113.RunTask`). Authentication uses Signature Version 4 headers (`Authorization: AWS4-HMAC-SHA256 ...`). Errors are JSON objects with `__type` and `message` fields.

### GCP API style

GCP services use REST with JSON payloads. Paths follow the pattern `/v2/projects/{project}/locations/{location}/jobs/{job}`. Authentication uses OAuth2 Bearer tokens (`Authorization: Bearer ...`). Async operations return an `Operation` resource that must be polled. Errors follow the Google API error format with `error.code`, `error.message`, and `error.status`.

### Azure API style

Azure services use ARM REST with JSON payloads. Paths follow the pattern `/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.App/jobs/{name}`. The `api-version` query parameter is required on every request. Authentication uses OAuth2 Bearer tokens. Long-running operations return a `Location` or `Azure-AsyncOperation` header for polling. Errors use the ARM error format with `error.code` and `error.message`.

### In-memory state management (pattern from MEM-001)

The memory backend uses mutex-protected maps for thread-safe in-memory state. Each resource type (containers, networks, volumes) has its own map with a `sync.RWMutex`. The simulators follow this same pattern: each simulated service maintains an in-memory store of resources keyed by their cloud-native identifiers (ARNs, resource names, resource IDs).

---

## Acceptance Criteria

### Shared framework
1. A `simulator` Go package provides a reusable HTTP server with configurable listen address, optional TLS (cert/key file paths), and graceful shutdown on SIGTERM/SIGINT.
2. The framework provides a `Router` interface that dispatches requests to service handlers based on provider-specific routing rules (AWS: `X-Amz-Target` header, GCP: URL path prefix, Azure: ARM resource provider in URL path).
3. Request logging middleware logs every request with zerolog: method, path, status code, response time, and relevant provider headers (e.g., `X-Amz-Target` for AWS, `api-version` for Azure).
4. Authentication passthrough middleware extracts auth headers and validates format (e.g., AWS SigV4 header present, Bearer token present) but does not validate real credentials. Requests without any auth header are also accepted (for testing convenience). The extracted identity (e.g., AWS access key ID, GCP service account email) is stored in the request context.
5. An in-memory `StateStore` interface provides typed, mutex-protected CRUD operations for resources. Each resource type is stored in a `map[string]T` with a `sync.RWMutex`. The store supports: `Get(id) (T, bool)`, `Put(id, T)`, `Delete(id) bool`, `List() []T`, and `Filter(func(T) bool) []T`.
6. The framework provides error response helpers for each provider format: `awsError(code, message string, statusCode int)`, `gcpError(code int, message, status string)`, `azureError(code, message string, statusCode int)`. Each produces the exact JSON structure the real provider returns.
7. A health check endpoint (`GET /health`) returns `200 OK` with `{"status": "ok", "provider": "<aws|gcp|azure>"}` on each simulator.
8. Configuration is loaded from environment variables: `SIM_LISTEN_ADDR` (default `:8443`), `SIM_TLS_CERT`, `SIM_TLS_KEY`, `SIM_LOG_LEVEL` (default `info`).

### Per-simulator binaries
9. Each cloud provider simulator is a separate Go binary with its own `go.mod` and `main.go` entrypoint: `simulators/aws/cmd/main.go`, `simulators/gcp/cmd/main.go`, `simulators/azure/cmd/main.go`.
10. The shared framework is a Go module at `simulators/shared/` imported by each simulator binary.
11. Each simulator binary registers its service handlers on startup and starts the HTTP server.

### Docker Compose
12. A `docker-compose.yml` in `simulators/` runs all 3 simulators together, each on a different port (e.g., AWS on 4566, GCP on 4567, Azure on 4568).
13. The Docker Compose file includes health checks for each simulator.

### SDK compatibility foundation
14. The AWS simulator accepts `X-Amz-Target` header-based routing and returns `x-amzn-RequestId` in response headers.
15. The GCP simulator accepts REST path-based routing and returns `x-goog-request-id` in response headers.
16. The Azure simulator accepts ARM path-based routing with `api-version` query parameter validation and returns `x-ms-request-id` in response headers.
17. Tests verify that AWS SDK Go v2 can connect to the AWS simulator with a custom endpoint resolver and make a basic request (e.g., `DescribeClusters` returning empty list).
18. Tests verify that Google Cloud Go SDK can connect to the GCP simulator with a custom endpoint option and make a basic request (e.g., `ListJobs` returning empty list).
19. Tests verify that Azure SDK for Go can connect to the Azure simulator with a custom endpoint and make a basic request (e.g., list jobs returning empty list).

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors in `simulators/shared/`, `simulators/aws/`, `simulators/gcp/`, `simulators/azure/`
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings in all simulator modules
- [ ] Vet passes: `go vet ./...` with zero warnings in all simulator modules
- [ ] Race detector: `go test -race ./...` passes in all simulator modules
- [ ] No new lint warnings introduced

### Testing
- [ ] Unit tests for: HTTP server startup/shutdown, TLS configuration, request routing (AWS, GCP, Azure styles), auth passthrough middleware, state store CRUD with concurrent access, error response formatting for all 3 providers, health check endpoint
- [ ] Integration tests for: AWS SDK Go v2 connects with custom endpoint, Google Cloud Go SDK connects with custom endpoint, Azure SDK for Go connects with custom endpoint
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Invalid routes return provider-appropriate 404/error responses
- [ ] Malformed request bodies return provider-appropriate 400/error responses
- [ ] Errors wrapped with context: `fmt.Errorf("simulator: %w", err)`
- [ ] Zerolog structured logging on all error paths

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` for `simulators/shared/` with framework overview and usage
- [ ] SDK endpoint override documentation for each provider (env vars, SDK config)

### Integration
- [ ] Shared framework importable by all 3 simulator binaries without circular dependencies
- [ ] Docker Compose starts all 3 simulators and health checks pass

---

## Suggested File Paths

```
simulators/
├── shared/
│   ├── go.mod               # module github.com/sockerless/simulator, go 1.23
│   ├── go.sum
│   ├── README.md
│   ├── server.go            # HTTP server with TLS, graceful shutdown
│   ├── router.go            # Provider-specific request routing
│   ├── state.go             # Generic in-memory state store with mutex
│   ├── middleware.go         # Logging, auth passthrough, request ID generation
│   ├── errors.go            # Provider-specific error response formatting (AWS, GCP, Azure)
│   └── config.go            # Environment variable configuration
├── aws/
│   ├── go.mod               # module github.com/sockerless/simulator-aws, go 1.23
│   ├── go.sum
│   ├── README.md
│   ├── router.go            # AWS X-Amz-Target routing
│   └── cmd/
│       └── main.go          # AWS simulator entrypoint
├── gcp/
│   ├── go.mod               # module github.com/sockerless/simulator-gcp, go 1.23
│   ├── go.sum
│   ├── README.md
│   ├── router.go            # GCP REST path routing
│   └── cmd/
│       └── main.go          # GCP simulator entrypoint
├── azure/
│   ├── go.mod               # module github.com/sockerless/simulator-azure, go 1.23
│   ├── go.sum
│   ├── README.md
│   ├── router.go            # Azure ARM path routing
│   └── cmd/
│       └── main.go          # Azure simulator entrypoint
└── docker-compose.yml       # All 3 simulators, health checks, port mapping
```

---

## Notes

- The shared framework should be minimal and focused on common concerns. Provider-specific behavior (routing, error format, request parsing) lives in each simulator's code, with helpers from the shared package.
- For AWS endpoint override, the SDK v2 uses `aws.EndpointResolverWithOptionsFunc` or per-service `BaseEndpoint` option. Both approaches should work. Document both.
- For GCP endpoint override, use `option.WithEndpoint("http://localhost:4567")` and `option.WithoutAuthentication()` or `option.WithTokenSource(...)` with a dummy token.
- For Azure endpoint override, use a custom `policy.ClientOptions` with a custom `Cloud` configuration pointing to the simulator URL.
- The state store should support optional "state machine" behavior: resources can have a `Status` field that transitions through defined states (e.g., PROVISIONING -> PENDING -> RUNNING -> STOPPED). Transitions can be triggered by timers or explicit API calls.
- TLS support is important because some SDKs (particularly Azure) may enforce HTTPS by default. The simulator should support both HTTP and HTTPS modes.
- Port allocation: AWS (4566), GCP (4567), Azure (4568). These are chosen to avoid conflicts with common development tools. LocalStack uses 4566, so consider 4570-4572 as alternatives if coexistence is needed.
- Each simulator binary should print a banner on startup showing the provider, listen address, registered services, and SDK configuration hint.
