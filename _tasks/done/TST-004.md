# TST-004: Container streaming tests

**Component:** Test Infrastructure and Suites
**Phase:** 1
**Depends on:** TST-001, FE-008, FE-009
**Estimated effort:** L

---

## Description

Black-box tests for container streaming endpoints: `GET /containers/{id}/logs` and `POST /containers/{id}/attach`. Tests verify the multiplexed stream protocol (8-byte header framing), streaming modes (follow, tail, timestamps), and bidirectional attach communication. Since full attach testing requires the agent (Phase 2), the memory backend simulates attach behavior.

---

## Context

### Container logs (Spec Section 4.3)

`GET /containers/{id}/logs?stdout=true&stderr=true&follow=false&tail=all&timestamps=false`

Response format (when `Tty: false`): Multiplexed stream with 8-byte header framing:
```
[stream_type: 1 byte][0x00 0x00 0x00][size: 4 bytes big-endian][payload: size bytes]
```
Where `stream_type` = `1` (stdout) or `2` (stderr).

**GitLab Runner reads logs with:** `stdout=true, stderr=true, timestamps=true, follow=false`
**GitHub Runner reads logs with:** `details=true, stdout=true, stderr=true`

### Multiplexed stream protocol (Spec Section 5.2)

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| STREAM | 0x00   | 0x00   | 0x00   | SIZE1  | SIZE2  | SIZE3  | SIZE4  |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

- Byte 0 (STREAM): `0` = stdin, `1` = stdout, `2` = stderr
- Bytes 1-3: Padding (zeros)
- Bytes 4-7: Payload size as big-endian uint32
- Following bytes: Payload (exactly SIZE bytes)

### Container attach (Spec Section 4.3)

`POST /containers/{id}/attach?stream=true&stdin=true&stdout=true&stderr=true`

Connection-hijacking endpoint. After HTTP response headers, the connection becomes a raw bidirectional byte stream. Response uses `Content-Type: application/vnd.docker.raw-stream` (or `application/vnd.docker.multiplexed-stream`).

**How GitLab Runner uses attach:**
1. Creates container with `Cmd` set to the script, `OpenStdin: true`
2. Calls attach BEFORE starting the container
3. Calls start
4. Streams stdin over the hijacked connection
5. Reads stdout/stderr using 8-byte multiplexed frame protocol
6. Connection closes when container exits

### Connection hijacking (Spec Section 5.3)

1. Client sends HTTP POST request
2. Server responds with `101 Switching Protocols` (or `200 OK` with `Connection: Upgrade`)
3. TCP connection becomes raw bidirectional byte stream
4. Server writes multiplexed frames for stdout/stderr
5. Client writes raw bytes for stdin
6. Connection closes when command/container exits

---

## Acceptance Criteria

### Logs - Basic

1. `GET /containers/{id}/logs?stdout=true` returns a multiplexed stream with stdout frames (stream_type = 1).
2. `GET /containers/{id}/logs?stderr=true` returns frames with stream_type = 2 for stderr content.
3. `GET /containers/{id}/logs?stdout=true&stderr=true` returns interleaved stdout and stderr frames.
4. Each frame has a valid 8-byte header: correct stream type, zero padding, correct payload size.
5. The payload size in the header matches the actual number of bytes that follow.

### Logs - Options

6. `GET /containers/{id}/logs?tail=5` returns at most 5 lines of output.
7. `GET /containers/{id}/logs?tail=0` returns no log lines (empty response body, or headers only).
8. `GET /containers/{id}/logs?timestamps=true` prefixes each log line with an RFC3339Nano timestamp (e.g., `2026-02-15T12:00:00.000000000Z `).
9. `GET /containers/{id}/logs?follow=true` keeps the connection open and streams new log entries as they arrive. The connection closes when the container exits.
10. `GET /containers/{id}/logs?follow=false` returns all available logs and closes the connection.

### Logs - Error Cases

11. `GET /containers/{id}/logs` on a non-existent container returns `404`.
12. `GET /containers/{id}/logs` with neither `stdout` nor `stderr` set to true returns a `400` or empty response.

### Attach - Basic

13. `POST /containers/{id}/attach?stream=true&stdout=true&stderr=true` returns `101 Switching Protocols` or `200` with connection upgrade.
14. After hijack, stdout data from the container arrives as multiplexed frames with stream_type = 1.
15. After hijack, stderr data arrives as multiplexed frames with stream_type = 2.

### Attach - Bidirectional

16. `POST /containers/{id}/attach?stream=true&stdin=true&stdout=true` with data written to the connection is received by the container as stdin.
17. The attach connection closes when the container exits.

### Frame Validation

18. Parse at least 3 multiplexed frames and verify: byte 0 is 0, 1, or 2; bytes 1-3 are 0x00; bytes 4-7 decoded as big-endian uint32 match the following payload length.

### Example Requests

```bash
# Prerequisites: create and start a container that produces output
curl --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/images/create?fromImage=alpine&tag=latest"
curl --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/containers/create?name=log-test" \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine:latest","Cmd":["echo","hello world"]}'
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/log-test/start

# Get logs (binary multiplexed stream)
curl --unix-socket /var/run/sockerless.sock \
  "http://localhost/containers/log-test/logs?stdout=true&stderr=true" --output - | xxd | head -5
# Expected: binary data with 8-byte frame headers
# 00000000: 0100 0000 0000 000c 6865 6c6c 6f20 776f  ........hello wo
# 00000010: 726c 640a                                 rld.

# Get logs with timestamps
curl --unix-socket /var/run/sockerless.sock \
  "http://localhost/containers/log-test/logs?stdout=true&timestamps=true" --output - | xxd | head -5
# Expected: timestamp prefix before "hello world"

# Get logs with tail
curl --unix-socket /var/run/sockerless.sock \
  "http://localhost/containers/log-test/logs?stdout=true&tail=1" --output -
# Expected: only the last line

# Attach (hijacked connection - requires raw TCP client, not simple curl)
# This is typically tested with Docker SDK's ContainerAttach or a custom TCP client
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 18 acceptance criteria pass
- [ ] Multiplexed frame parser helper is reusable for exec tests (TST-005)
- [ ] Tests pass against memory backend; attach tests may be limited against memory backend
- [ ] Follow mode test uses a timeout to avoid hanging

---

## Suggested File Paths

```
tests/
├── container_logs_test.go         # TestContainerLogs*, TestContainerLogsFollow, TestContainerLogsTail
├── container_attach_test.go       # TestContainerAttach*, TestContainerAttachBidirectional
└── helpers/
    ├── mux_stream.go              # ParseMuxFrame, ReadMuxFrames, WriteMuxFrame helpers
    └── hijack.go                  # HijackConnection helper for attach/exec tests
```

---

## Notes

- Use Docker SDK's `stdcopy.StdCopy` or a custom frame parser to decode the multiplexed stream. A custom parser is preferred for tests since it validates the raw byte format.
- For follow mode tests, create a helper that reads with a timeout (e.g., `context.WithTimeout`). Start a container, read follow logs, stop the container, and verify the connection closes.
- Attach testing against the memory backend is limited since no real process runs. The memory backend should return synthetic output (e.g., echo the command back). Full bidirectional attach testing happens in Phase 2 with the agent.
- The attach endpoint uses HTTP connection hijacking (`http.Hijacker`). Test with a raw TCP connection or the Docker Go SDK's `ContainerAttach` method, which handles the hijack protocol.
- For the memory backend, log content can be synthetic (e.g., "Container started\n"). The important thing is that the multiplexed framing is correct.
- Timestamp format must be RFC3339Nano (e.g., `2026-02-15T12:00:00.000000000Z`). Verify with a regex or time.Parse.
- Consider using `io.Pipe` for follow mode tests to simulate a streaming response.
