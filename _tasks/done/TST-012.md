# TST-012: GitHub Actions Runner End-to-End

**Component:** Test Infrastructure and Suites
**Phase:** 3
**Depends on:** FE-021, TST-010
**Estimated effort:** XL

---

## Description

End-to-end test suite that validates the complete GitHub Actions Runner workflow against Sockerless. This test exercises the full container job lifecycle (container jobs with exec-based step execution), container actions (`uses: docker://image`), and service containers — verifying that Sockerless correctly handles every Docker API call the runner makes. Tests run against ECS by default but should also pass against Cloud Run and ACA backends.

This is the highest-complexity test suite in the project because it covers the entire GitHub Actions Runner interaction surface: version check, network creation, image pull with retries, container creation with entrypoint overrides, start with immediate status verification, exec-based step execution with stdin, health check polling, port discovery, log retrieval, and force-remove cleanup.

---

## Context

### GitHub Actions Runner Docker API Surface (Spec Section 13.2.1)

GitHub Actions Runner shells out to the `docker` CLI (not the REST API directly). The runner's `DockerCommandManager.cs` wraps these CLI commands, which map to REST API calls:

| CLI Command | REST API Endpoint |
|---|---|
| `docker version` | `GET /version` |
| `docker pull <image>` | `POST /images/create` |
| `docker login` | `POST /auth` |
| `docker create --entrypoint ... --network ... -v ... -e ... --label ...` | `POST /containers/create` |
| `docker start <id>` | `POST /containers/{id}/start` |
| `docker ps --filter ...` | `GET /containers/json?filters=...` |
| `docker inspect <id>` | `GET /containers/{id}/json` |
| `docker exec -i --workdir ... -e ... <id> <cmd>` | `POST /containers/{id}/exec` + `POST /exec/{id}/start` |
| `docker logs --details --stdout --stderr <id>` | `GET /containers/{id}/logs` |
| `docker port <id>` | Derived from `GET /containers/{id}/json` NetworkSettings.Ports |
| `docker rm --force <id>` | `DELETE /containers/{id}?force=true` |
| `docker network create --label ... <name>` | `POST /networks/create` |
| `docker network rm <name>` | `DELETE /networks/{id}` |
| `docker network prune --filter label=...` | `POST /networks/prune` |
| `docker wait <id>` (container actions only) | `POST /containers/{id}/wait` |
| `docker logs --follow <id>` (container actions only) | `GET /containers/{id}/logs?follow=true` |

**Not used:** `docker stop`, `docker kill`, `docker attach`, `docker volume *`, `docker build`, `docker push`.

### Container Job Lifecycle (Spec Section 13.2.2)

```
1. Version Check:    GET /version (requires Server.APIVersion >= 1.35)
2. Network Setup:    POST /networks/create (failure is FATAL)
3. Image Pull:       POST /images/create (with retries, 3 attempts)
4. Container Create: POST /containers/create with --entrypoint "tail" ... "-f" "/dev/null"
5. Container Start:  POST /containers/{id}/start
6. Status Verify:    GET /containers/json?filters={"id":["<id>"],"status":["running"]}
7. Inspect & Setup:  GET /containers/{id}/json (extract Config.Env PATH, Healthcheck)
8. Health Polling:    GET /containers/{id}/json (poll State.Health.Status, exponential backoff)
9. Port Discovery:   GET /containers/{id}/json -> NetworkSettings.Ports
10. Step Execution:  POST /containers/{id}/exec + POST /exec/{id}/start (for each step)
11. Cleanup:         DELETE /containers/{id}?force=true, DELETE /networks/{id}, POST /networks/prune
```

### Container Actions (Spec Section 13.2.3)

Container actions use a different pattern from container jobs:
1. `POST /containers/create` with ORIGINAL entrypoint (NOT overridden to tail)
2. `POST /containers/{id}/start`
3. `GET /containers/{id}/logs?follow=true` (stream output)
4. `POST /containers/{id}/wait` (get exit code from container process)
5. `DELETE /containers/{id}?force=true`

### Critical Behaviors (Spec Section 13.2.4)

- **`tail -f /dev/null` entrypoint override:** Runner ALWAYS overrides entrypoint for container jobs. Agent substitutes as keep-alive mechanism.
- **PATH extraction from `Config.Env`:** Runner reads `Config.Env` array looking for `PATH=` entries. Must include merged image + user env.
- **Exec with stdin (`-i`):** Runner uses `docker exec -i` for ALL step executions. Exit code from exec process = step result.
- **No exec retry:** If exec fails, step fails immediately. No backoff or retry logic.
- **Docker socket mount:** Runner always adds `-v "/var/run/docker.sock:/var/run/docker.sock"`. Accepted silently.
- **Network creation is mandatory:** Failure is FATAL. No fallback to default bridge.
- **No startup grace period:** After `docker start`, runner immediately checks status=running.

---

## Acceptance Criteria

### Version Check

1. `GET /version` returns JSON with `ApiVersion` field >= `"1.35"` (runner requires this minimum)

### Container Job Lifecycle

2. Full container job lifecycle completes: network create, image pull, container create (with `tail -f /dev/null` entrypoint), start, inspect, exec steps, logs, force-remove, network remove
3. `POST /containers/create` with `Entrypoint: ["tail"]`, `Cmd: ["-f", "/dev/null"]` succeeds and returns a valid container ID
4. `POST /containers/create` with `Binds: ["/var/run/docker.sock:/var/run/docker.sock"]` is accepted without error
5. After `POST /containers/{id}/start`, the container is immediately visible as `"running"` via `GET /containers/json?filters={"id":["<id>"],"status":["running"]}`
6. `GET /containers/{id}/json` returns `Config.Env` containing a `PATH=...` entry (merged from image config and user environment variables)
7. `POST /containers/{id}/exec` with `AttachStdin: true, AttachStdout: true, AttachStderr: true` returns an exec ID
8. `POST /exec/{id}/start` opens a hijacked bidirectional stream; data written to stdin is received by the command; stdout/stderr output is returned in multiplexed frames
9. Exec exit code is correctly propagated: a command that exits 0 returns exit code 0; a command that exits non-zero returns the correct non-zero code
10. `GET /containers/{id}/logs?details=true&stdout=true&stderr=true` returns container output with multiplexed framing

### Service Containers

11. Service containers created with a `Healthcheck` config are polled via `GET /containers/{id}/json` until `State.Health.Status` becomes `"healthy"`
12. Containers without a `Healthcheck` config have no `State.Health` field in inspect response (runner skips health polling)
13. Service container ports are discoverable via `GET /containers/{id}/json` under `NetworkSettings.Ports`

### Container Actions

14. Container action lifecycle completes: create (with original entrypoint), start, follow logs, wait for exit, remove
15. `POST /containers/{id}/wait` blocks until the container exits and returns `{"StatusCode": <exit-code>}`
16. `GET /containers/{id}/logs?follow=true&stdout=true&stderr=true` streams output until the container exits

### Network Lifecycle

17. `POST /networks/create` with a label succeeds and returns a network ID
18. `DELETE /networks/{id}` removes the network after containers are removed
19. `POST /networks/prune?filters={"label":["<hash>"]}` cleans up orphaned networks matching the label

### Cleanup and Error Handling

20. `DELETE /containers/{id}?force=true` kills a running container and removes it in a single call
21. After cleanup, no containers or networks from the test remain (verified by list endpoints with label filters)

### Multi-Step Execution

22. Multiple sequential exec calls to the same container succeed (simulating multi-step workflow)
23. Each exec call runs in the correct working directory when `WorkingDir` is specified
24. Each exec call receives the correct environment variables when `Env` is specified

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 24 acceptance criteria pass
- [ ] Tests simulate the exact API call sequence that GitHub Actions Runner makes
- [ ] Test suite can target different backends via `--backend` flag (memory, ecs, cloudrun, aca)
- [ ] Cloud backend tests are skipped gracefully if credentials are not available
- [ ] Tests use unique labels and names to avoid collisions with parallel test runs
- [ ] Each test cleans up all created resources (containers, networks) via `defer`

---

## Suggested File Paths

```
tests/
├── github_runner_e2e_test.go          # TestGitHubRunnerContainerJob, TestGitHubRunnerContainerAction,
│                                       # TestGitHubRunnerServiceContainers, TestGitHubRunnerMultiStep
├── github_runner_lifecycle_test.go     # TestGitHubRunnerNetworkLifecycle, TestGitHubRunnerCleanup,
│                                       # TestGitHubRunnerVersionCheck, TestGitHubRunnerExecExitCodes
└── helpers/
    └── github_runner.go                # simulateRunnerCreate, simulateRunnerExec,
                                        # simulateRunnerCleanup, verifyContainerRunning helpers
```

---

## Notes

- The tests in this suite simulate the exact sequence of Docker API calls that GitHub Actions Runner makes. They do NOT run an actual GitHub Actions Runner binary. Instead, they replay the API call sequence programmatically.
- The `tail -f /dev/null` entrypoint is the most critical pattern to test. Sockerless must translate this into the agent keep-alive mode for cloud backends. Verify that exec commands work correctly on a container started with this entrypoint.
- Exec exit code propagation is tested by running commands like `sh -c "exit 0"` and `sh -c "exit 42"` and verifying the exit code returned by the exec inspect endpoint.
- For service container health checks, use a container image that defines a `HEALTHCHECK` instruction (or provide one in the create body). Poll inspect until `State.Health.Status` is `"healthy"` with the same exponential backoff the runner uses (2s, 3s, 7s, 13s).
- The `Config.Env` test should verify that both image-defined environment variables (e.g., `PATH`) and user-provided env vars (from `Env` in the create body) are present and correctly merged.
- Cloud backend tests will have longer timeouts (up to 120s for container start) due to cold start latency. Use `testing.Short()` to skip long-running cloud tests in CI short mode.
- Network creation failure is fatal for the runner. Test that network creation is reliable and returns a valid ID on the first attempt.
