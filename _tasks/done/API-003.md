# API-003: Custom error types and zerolog setup

**Component:** API (Shared internal API types)
**Phase:** 1
**Depends on:** --
**Estimated effort:** S

---

## Description

Define the custom domain error types and a zerolog logger factory used throughout all Sockerless components. The error types follow Docker's error response conventions and map cleanly to HTTP status codes. The logger factory creates pre-configured zerolog loggers with consistent formatting.

Error types live in `api/errors.go`. The logger factory lives in `api/logging.go`. The errors module has zero external dependencies (stdlib only). The logging module depends on `github.com/rs/zerolog`.

---

## Context

### Docker error format (Spec Section 5.4)

> All errors follow Docker's format:
> ```json
> {"message": "No such container: abc123"}
> ```
>
> Standard HTTP status codes:
> - `200` / `201` / `204`: Success
> - `304`: Not modified (container already started/stopped)
> - `400`: Bad request (invalid parameters)
> - `404`: Not found (no such container/network/volume/image)
> - `409`: Conflict (container already running, name in use)
> - `500`: Server error
> - `501`: Not implemented (capability not supported by backend)

### Error handling conventions (CONVENTIONS.md)

> Use **custom error types** for domain errors:
> ```go
> type NotFoundError struct {
>     Resource string // "container", "image", "network", "volume"
>     ID       string
> }
> func (e *NotFoundError) Error() string {
>     return fmt.Sprintf("No such %s: %s", e.Resource, e.ID)
> }
> ```
>
> - Wrap errors with context: `fmt.Errorf("create container: %w", err)`
> - Use `errors.Is` / `errors.As` for error checking
> - Map domain errors to HTTP status codes in the frontend

### Logging conventions (CONVENTIONS.md)

> Use **zerolog** (`github.com/rs/zerolog`) for all structured logging:
> - Log levels: `debug` for internal state, `info` for operations, `warn` for recoverable issues, `error` for failures
> - Include context in log entries:
>   ```go
>   log.Info().Str("container_id", id).Str("image", image).Msg("container created")
>   ```
> - Never log sensitive data (credentials, tokens, secrets)

### Capability-based 501 responses (Spec Section 7.4)

> When a Docker API request maps to an unsupported capability, the frontend returns `501 Not Implemented` with `{"message":"This backend (lambda) does not support exec"}`.

This means `NotImplementedError` must include the backend name and the operation name so the frontend can construct this message.

---

## Acceptance Criteria

1. `NotFoundError` struct with fields `Resource string` and `ID string`.
   - `Error()` returns `"No such <resource>: <id>"` (e.g., `"No such container: abc123def..."`)
   - `StatusCode()` returns `404`
2. `ConflictError` struct with fields `Resource string` and `Reason string`.
   - `Error()` returns `"Conflict: <reason>"` (e.g., `"Conflict: container name /myapp is already in use"`)
   - `StatusCode()` returns `409`
3. `InvalidParameterError` struct with fields `Param string` and `Reason string`.
   - `Error()` returns `"invalid parameter <param>: <reason>"` (e.g., `"invalid parameter Image: cannot be empty"`)
   - `StatusCode()` returns `400`
4. `NotImplementedError` struct with fields `Operation string`.
   - `Error()` returns `"<operation> is not implemented"` (e.g., `"exec is not implemented"`)
   - `StatusCode()` returns `501`
5. `NotModifiedError` struct (no fields needed).
   - `Error()` returns `"not modified"`
   - `StatusCode()` returns `304`
6. All error types implement the standard `error` interface.
7. All error types implement a `StatusCode() int` method.
8. A `StatusCoder` interface is defined: `type StatusCoder interface { StatusCode() int }` -- the frontend uses this to extract HTTP status from any domain error.
9. Helper functions `IsNotFound(err error) bool`, `IsConflict(err error) bool`, `IsNotImplemented(err error) bool` are provided using `errors.As`.
10. A `NewLogger(level string, format string) zerolog.Logger` factory function is provided:
    - `level` accepts: `"debug"`, `"info"`, `"warn"`, `"error"`, `"disabled"` (maps to zerolog levels)
    - `format` accepts: `"json"` (structured JSON output, default) and `"console"` (human-readable, for development)
    - Adds default fields: `"component"` (caller passes this)
    - Timestamps use RFC3339 format
11. The error types module (`api/errors.go`) has zero external dependencies.
12. The logging module (`api/logging.go`) depends only on `github.com/rs/zerolog`.
13. All exported types, methods, and functions have GoDoc comments.

### Example Usage

```go
// In a backend implementation:
func (b *MemoryBackend) ContainerInspect(ctx context.Context, id string) (api.Container, error) {
    c, ok := b.containers[id]
    if !ok {
        return api.Container{}, &api.NotFoundError{Resource: "container", ID: id}
    }
    return c, nil
}

// In the frontend HTTP handler:
func handleInspect(w http.ResponseWriter, r *http.Request) {
    c, err := backend.ContainerInspect(r.Context(), id)
    if err != nil {
        var sc api.StatusCoder
        if errors.As(err, &sc) {
            w.WriteHeader(sc.StatusCode())
            json.NewEncoder(w).Encode(map[string]string{"message": err.Error()})
            return
        }
        w.WriteHeader(500)
        json.NewEncoder(w).Encode(map[string]string{"message": err.Error()})
        return
    }
    json.NewEncoder(w).Encode(c)
}

// Logger setup:
log := api.NewLogger("info", "json")
log.Info().Str("container_id", "abc123").Msg("container started")
// Output: {"level":"info","time":"2026-02-15T12:00:00Z","container_id":"abc123","message":"container started"}
```

### Example curl — Docker error format

```bash
# 404 Not Found
curl -s --unix-socket /tmp/sockerless.sock http://localhost/v1.44/containers/nonexistent/json
# {"message":"No such container: nonexistent"}

# 409 Conflict
curl -s --unix-socket /tmp/sockerless.sock -X POST \
  -H 'Content-Type: application/json' \
  -d '{"Image":"nginx"}' \
  'http://localhost/v1.44/containers/create?name=myapp'
# (when name already exists)
# {"message":"Conflict: container name /myapp is already in use"}

# 501 Not Implemented
curl -s --unix-socket /tmp/sockerless.sock -X POST \
  -d '{"Cmd":["sh"]}' \
  http://localhost/v1.44/containers/abc123/exec
# (on Lambda backend)
# {"message":"exec is not implemented"}

# 400 Bad Request
curl -s --unix-socket /tmp/sockerless.sock -X POST \
  -H 'Content-Type: application/json' \
  -d '{}' \
  http://localhost/v1.44/containers/create
# {"message":"invalid parameter Image: cannot be empty"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes (if any unit tests are added)
- [ ] No new lint warnings introduced

### Testing
- [ ] Unit tests for each error type's `Error()` and `StatusCode()` methods
- [ ] Unit tests for `IsNotFound`, `IsConflict`, `IsNotImplemented` helpers including wrapped errors
- [ ] Unit tests for `NewLogger` with both `"json"` and `"console"` formats

### Error Handling
- [ ] All error types use pointer receivers (so `errors.As` works with `*NotFoundError`)
- [ ] All error messages match Docker's phrasing (e.g., "No such container:" not "Container not found:")

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated if this is the first code in the `api/` module

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] `StatusCoder` interface can be used by the frontend without importing concrete error types

---

## Suggested File Paths

```
api/
├── errors.go         # NotFoundError, ConflictError, InvalidParameterError,
│                     # NotImplementedError, NotModifiedError, StatusCoder interface,
│                     # IsNotFound, IsConflict, IsNotImplemented helpers
├── errors_test.go    # Unit tests for all error types and helpers
├── logging.go        # NewLogger factory function
└── logging_test.go   # Unit tests for logger creation
```

---

## Notes

- The `errors.go` file must have zero external dependencies -- it uses only `fmt` and `errors` from the standard library. This is important because the `api/` module aims for minimal dependencies, and error types are used everywhere.
- The `logging.go` file introduces the only external dependency in the `api/` module: `github.com/rs/zerolog`. If this dependency is undesirable in `api/`, the logger factory could be moved to a separate `api/log` sub-package. However, keeping it in `api/` is simpler since every component already imports `api/`.
- Error message format must exactly match Docker's: `"No such container: abc123"` (not `"no such container: abc123"` -- Docker capitalizes "No"). Verify against the Docker Engine source.
- The `NotModifiedError` is used for `POST /containers/{id}/start` when the container is already running (HTTP 304) and `POST /containers/{id}/stop` when the container is already stopped.
- Consider adding a `ServerError` type for wrapping unexpected internal errors with a 500 status code, though `fmt.Errorf` with wrapping may suffice for internal errors.
- The `StatusCoder` interface is intentionally separate from `error` so the frontend can do a single `errors.As(err, &sc)` check without knowing the concrete type.
