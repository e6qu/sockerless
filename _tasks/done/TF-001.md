# TF-001: Terraform project scaffold and shared conventions

**Component:** Terraform
**Phase:** 2 (needed before integration tests)
**Depends on:** —
**Estimated effort:** M

---

## Description

Set up the Terraform project structure with shared conventions, provider version constraints, backend configuration (S3/GCS/Azure Blob for state), shared variable definitions, and a root README. This task establishes the patterns that all Terraform modules and environments follow: consistent file layout, naming conventions, tagging strategy, version pinning, and automation scripts. Every subsequent TF-* task builds on this foundation.

---

## Context

### Project directory structure

The Terraform code lives under `terraform/` in the Sockerless monorepo. Modules encapsulate per-backend infrastructure (ECS, Cloud Run, ACA, Lambda, GCF, AZF). Environments instantiate modules with concrete settings (region, project, tags) and configure remote state.

```
terraform/
├── modules/
│   ├── ecs/           # AWS ECS Fargate infrastructure
│   ├── cloudrun/      # Google Cloud Run infrastructure
│   ├── aca/           # Azure Container Apps infrastructure
│   ├── lambda/        # AWS Lambda infrastructure
│   ├── gcf/           # Google Cloud Functions infrastructure
│   └── azf/           # Azure Functions infrastructure
└── environments/
    ├── ecs-test/       # ECS integration test environment
    ├── cloudrun-test/  # Cloud Run integration test environment
    ├── aca-test/       # ACA integration test environment
    ├── lambda-test/    # Lambda integration test environment
    ├── gcf-test/       # Cloud Functions integration test environment
    └── azf-test/       # Azure Functions integration test environment
```

### Provider landscape

Sockerless spans three cloud providers:

| Provider | Registry Source | Used By |
|---|---|---|
| `hashicorp/aws` | AWS ECS, Lambda | ECS, Lambda modules |
| `hashicorp/google` | Cloud Run, Cloud Functions | Cloud Run, GCF modules |
| `hashicorp/azurerm` | Container Apps, Azure Functions | ACA, AZF modules |

Each module declares only the providers it needs. Environments inherit provider configuration from the module but supply credentials and region.

### Remote state strategy

| Cloud | State Backend | Lock Mechanism |
|---|---|---|
| AWS | S3 bucket | DynamoDB table |
| GCP | GCS bucket | Built-in (GCS native locking) |
| Azure | Azure Blob Storage | Azure Blob lease |

Each environment configures its own backend block. State files are never committed to version control.

### Tagging strategy (Spec Section 15.3, deployment conventions)

All cloud resources managed by Terraform carry a consistent set of tags for cost allocation, ownership tracking, and automated cleanup:

- `project = "sockerless"` — identifies the project across all resources
- `environment` — `test`, `staging`, `production`
- `component` — `ecs`, `cloudrun`, `aca`, `lambda`, `gcf`, `azf`
- `managed-by = "terraform"` — distinguishes Terraform-managed resources from manually created ones

---

## Acceptance Criteria

1. Root `terraform/README.md` exists and documents: module usage patterns, environment instantiation steps, provider version requirements, tagging conventions, and remote state configuration.
2. Each module directory (`ecs`, `cloudrun`, `aca`, `lambda`, `gcf`, `azf`) contains placeholder files: `main.tf`, `variables.tf`, `outputs.tf`, `versions.tf`.
3. Every `versions.tf` file declares `required_version = ">= 1.5"` in the `terraform` block.
4. Provider version constraints use the `~>` pessimistic operator (e.g., `~> 5.0` for AWS, `~> 5.0` for Google, `~> 3.0` for AzureRM) to allow patch-level updates while preventing breaking changes.
5. Shared variable naming conventions are documented in the README: `project_name` (string), `environment` (string), `tags` (map of strings). All modules accept these variables.
6. All modules apply consistent default tags via a `locals` block that merges user-supplied `tags` with the mandatory tags (`project`, `environment`, `component`, `managed-by = "terraform"`).
7. Each environment directory (`ecs-test`, `cloudrun-test`, etc.) contains: `main.tf` (module instantiation), `variables.tf`, `outputs.tf`, `backend.tf` (remote state config), and `terraform.tfvars.example` (documented example, no real secrets).
8. Remote state backend is configured per environment: S3 + DynamoDB for AWS environments, GCS for GCP environments, Azure Blob for Azure environments. The `backend.tf` file in each environment directory contains the appropriate backend block.
9. `terraform/.gitignore` includes entries for: `.terraform/`, `*.tfstate`, `*.tfstate.backup`, `.terraform.lock.hcl`, `terraform.tfvars` (actual vars with secrets), `*.auto.tfvars`.
10. `terraform fmt -check -recursive` passes on all `.tf` files with zero formatting differences.
11. `terraform validate` passes in every module directory (after `terraform init` with no backend).
12. A `Makefile` (or shell script `scripts/tf.sh`) in `terraform/` provides targets for common operations: `init`, `plan`, `apply`, `destroy` — each accepting an `ENV=<environment-name>` parameter (e.g., `make plan ENV=ecs-test`).
13. The Makefile includes a `fmt` target that runs `terraform fmt -recursive` and a `validate` target that runs `terraform validate` in all module directories.
14. Module placeholder `main.tf` files contain a comment header describing the module's purpose and a reference to the corresponding task ID (e.g., "See TF-002 for implementation").

---

## Definition of Done

### Code Quality
- [ ] `terraform fmt -check -recursive` passes with zero formatting differences
- [ ] `terraform validate` passes in all module directories
- [ ] No syntax errors in any `.tf` file
- [ ] HCL follows HashiCorp style conventions (2-space indent, sorted blocks)

### Testing
- [ ] `terraform init` succeeds in every module directory (with `-backend=false` for modules)
- [ ] `terraform validate` succeeds in every module directory
- [ ] Makefile targets `fmt` and `validate` execute without errors

### Documentation
- [ ] `terraform/README.md` documents module usage, environment patterns, tagging, and state configuration
- [ ] Each `terraform.tfvars.example` is annotated with descriptions of each variable
- [ ] `.gitignore` is comprehensive and prevents accidental state/secret commits

### Integration
- [ ] Directory structure matches the layout described in this task
- [ ] No breaking changes to existing repository structure
- [ ] All subsequent TF-* tasks can build on this scaffold without restructuring

---

## Suggested File Paths

```
terraform/
├── README.md                            # Project documentation
├── Makefile                             # Automation targets (init, plan, apply, destroy, fmt, validate)
├── .gitignore                           # Terraform-specific ignores
├── modules/
│   ├── ecs/
│   │   ├── main.tf                      # Placeholder (see TF-002)
│   │   ├── variables.tf                 # Shared variable declarations
│   │   ├── outputs.tf                   # Placeholder outputs
│   │   └── versions.tf                  # Terraform >= 1.5, AWS provider ~> 5.0
│   ├── cloudrun/
│   │   ├── main.tf                      # Placeholder (see TF-004)
│   │   ├── variables.tf                 # Shared variable declarations
│   │   ├── outputs.tf                   # Placeholder outputs
│   │   └── versions.tf                  # Terraform >= 1.5, Google provider ~> 5.0
│   ├── aca/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   └── versions.tf                  # Terraform >= 1.5, AzureRM provider ~> 3.0
│   ├── lambda/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   └── versions.tf
│   ├── gcf/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   │   └── versions.tf
│   └── azf/
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       └── versions.tf
└── environments/
    ├── ecs-test/
    │   ├── main.tf                      # Module instantiation
    │   ├── variables.tf                 # Environment-specific variables
    │   ├── outputs.tf                   # Pass-through outputs for test runner
    │   ├── backend.tf                   # S3 + DynamoDB state backend
    │   └── terraform.tfvars.example     # Documented example
    ├── cloudrun-test/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── outputs.tf
    │   ├── backend.tf                   # GCS state backend
    │   └── terraform.tfvars.example
    ├── aca-test/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── outputs.tf
    │   ├── backend.tf                   # Azure Blob state backend
    │   └── terraform.tfvars.example
    ├── lambda-test/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── outputs.tf
    │   ├── backend.tf
    │   └── terraform.tfvars.example
    ├── gcf-test/
    │   ├── main.tf
    │   ├── variables.tf
    │   ├── outputs.tf
    │   ├── backend.tf
    │   └── terraform.tfvars.example
    └── azf-test/
        ├── main.tf
        ├── variables.tf
        ├── outputs.tf
        ├── backend.tf
        └── terraform.tfvars.example
```

---

## Notes

- Provider version pinning with `~>` allows patch updates (e.g., `~> 5.0` allows `5.0.0` through `5.x.y`) while preventing major version jumps that may introduce breaking changes. Pin to the latest stable major version at the time of implementation.
- The `terraform.tfvars` file (without `.example` suffix) must NEVER be committed. It may contain AWS access keys, GCP service account paths, or Azure subscription IDs. The `.gitignore` entry prevents this.
- The Makefile should validate that `ENV` is set before running `plan`/`apply`/`destroy` and print a helpful error message if not.
- For CI/CD, consider adding a `ci-plan` target that outputs the plan in JSON format for automated review.
- Module `variables.tf` should declare variables with `description`, `type`, and `default` (where appropriate). Use `validation` blocks for constrained values (e.g., `environment` must be one of `test`, `staging`, `production`).
- The `.terraform.lock.hcl` file is excluded from version control in this scaffold for simplicity. In production, consider committing it to ensure reproducible provider versions across team members. This is a team decision documented in the README.
- Each module's `versions.tf` should declare only the providers that module actually uses. AWS modules do not declare the Google provider, and vice versa. This prevents unnecessary provider downloads.
