# TF-003: ECS test environment

**Component:** Terraform
**Phase:** 2
**Depends on:** TF-001, TF-002
**Estimated effort:** S

---

## Description

Create the Terraform environment configuration that instantiates the ECS module (TF-002) for integration testing. This environment uses cost-optimized settings: small VPC, minimal NAT Gateway, short log retention, and a single availability zone where possible. The environment outputs all values needed by the ECS integration test suite (TST-010) and the ECS backend binary (ECS-001) so that tests can provision and run containers on real AWS Fargate infrastructure.

---

## Context

### ECS integration test requirements (TST-010)

The ECS integration test suite needs to:
1. Run Fargate tasks in a VPC with internet access (for image pulls)
2. Mount EFS volumes to share data between helper and build containers
3. Use Cloud Map for DNS-based service discovery between containers
4. Reach the agent on port 9111 from the test runner (or from the frontend running in the same VPC)
5. Read container logs from CloudWatch

The test runner receives infrastructure details as environment variables or a config file. These map directly to the ECS backend configuration (Spec Section 15.3):

```yaml
ecs:
  region: us-east-1
  cluster: sockerless-test
  subnets: ["subnet-..."]
  security_groups: ["sg-..."]
  task_role_arn: "arn:aws:iam::..."
  execution_role_arn: "arn:aws:iam::..."
  efs_filesystem_id: "fs-..."
  log_group: /sockerless/test/containers
```

### Cost optimization for test environments

Test environments are short-lived and cost-sensitive. Key savings:
- Single NAT Gateway (not one per AZ) -- saves ~$32/month per avoided gateway
- 2 AZs with small subnets (/24 instead of /20) -- sufficient for test workloads
- 1-day CloudWatch Logs retention -- avoids accumulating log storage costs
- EFS with bursting throughput -- no provisioned throughput charge
- ECR lifecycle: expire untagged images after 1 day

### Remote state for AWS environments

AWS environments use S3 for Terraform state with DynamoDB for state locking:

```hcl
terraform {
  backend "s3" {
    bucket         = "sockerless-terraform-state"
    key            = "ecs-test/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "sockerless-terraform-locks"
    encrypt        = true
  }
}
```

The S3 bucket and DynamoDB table must exist before running `terraform init`. These are bootstrap resources created manually or via a separate bootstrap script.

---

## Acceptance Criteria

1. `environments/ecs-test/main.tf` instantiates the `../../modules/ecs` module with test-appropriate defaults.
2. VPC is configured with 2 AZs, `/24` private subnets, `/24` public subnets, and a single NAT Gateway.
3. CloudWatch Logs retention is set to 1 day.
4. ECR lifecycle policy expires untagged images after 1 day.
5. ECS cluster name includes a `test` suffix or prefix (e.g., `sockerless-test`) to distinguish from production.
6. `backend.tf` configures S3 remote state with DynamoDB locking. The state key is `ecs-test/terraform.tfstate`.
7. All resources are tagged with `environment = "test"` and `project = "sockerless"`.
8. `terraform.tfvars.example` documents all required and optional variables with example values and comments. It does NOT contain real AWS account IDs, credentials, or resource ARNs.
9. `outputs.tf` exports all values needed by the ECS backend and test runner: `ecs_cluster_arn`, `ecs_cluster_name`, `private_subnet_ids`, `public_subnet_ids`, `task_security_group_id`, `efs_security_group_id`, `efs_filesystem_id`, `log_group_name`, `cloud_map_namespace_id`, `execution_role_arn`, `task_role_arn`, `ecr_repository_url`, `vpc_id`, `region`.
10. A helper comment block or script demonstrates how to pass Terraform outputs to the ECS backend config or test runner (e.g., `terraform output -json | jq ...` or environment variable export commands).
11. `terraform validate` passes in the `ecs-test` directory.
12. `terraform plan` produces no errors when valid AWS credentials and variable values are provided.
13. The environment can be fully destroyed with `terraform destroy` leaving no orphaned resources.

---

## Definition of Done

### Code Quality
- [ ] `terraform fmt -check` passes with zero formatting differences
- [ ] `terraform validate` passes with zero errors
- [ ] No hard-coded AWS account IDs, regions, or resource names (all parameterized)
- [ ] HCL follows HashiCorp style conventions

### Testing
- [ ] `terraform init -backend=false` succeeds (validates syntax without needing S3 bucket)
- [ ] `terraform validate` succeeds
- [ ] `terraform plan` succeeds with valid credentials and variable values
- [ ] `terraform apply` creates all resources successfully (manual verification)
- [ ] `terraform destroy` removes all resources cleanly

### Documentation
- [ ] `terraform.tfvars.example` is comprehensive and annotated
- [ ] Output descriptions clearly state what each value is used for
- [ ] Comments in `main.tf` explain cost-optimization choices
- [ ] README section or comment block explains how to use outputs with the test runner

### Integration
- [ ] Output values can be directly mapped to ECS backend configuration keys (ECS-001)
- [ ] The created infrastructure supports all ECS backend operations: container create/start (ECS-002), logs (ECS-004), networking (ECS-007), volumes (ECS-008)
- [ ] Security groups allow the test runner (or frontend in the same VPC) to reach agent port 9111 on Fargate tasks
- [ ] No breaking changes to the TF-001 scaffold or TF-002 module interface

---

## Suggested File Paths

```
terraform/environments/ecs-test/
├── main.tf                    # Module instantiation with test-optimized defaults
├── variables.tf               # Environment-specific variables (region, account settings)
├── outputs.tf                 # All outputs needed by test runner and ECS backend
├── backend.tf                 # S3 + DynamoDB state backend configuration
└── terraform.tfvars.example   # Documented example variables (no secrets)
```

---

## Notes

- The `terraform.tfvars.example` should contain an annotated example like:
  ```hcl
  # AWS region for all resources
  region = "us-east-1"

  # Project name (used in resource naming and tags)
  project_name = "sockerless"

  # Environment name (used in tags and resource naming)
  environment = "test"

  # CIDR for the frontend or test runner to reach agent port 9111
  # Set to the VPC CIDR if running tests from within the VPC
  agent_ingress_cidr = "10.99.0.0/16"
  ```
- The S3 state bucket and DynamoDB lock table are bootstrap resources. They must exist before the first `terraform init` in this environment. Document the bootstrap commands in the `terraform.tfvars.example` or a separate section of the README:
  ```bash
  aws s3api create-bucket --bucket sockerless-terraform-state --region us-east-1
  aws dynamodb create-table --table-name sockerless-terraform-locks \
    --attribute-definitions AttributeName=LockID,AttributeType=S \
    --key-schema AttributeName=LockID,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST
  ```
- The test environment VPC CIDR (`10.0.0.0/16` or similar) should not conflict with VPCs in the same account used for other purposes. Consider using a less common CIDR like `10.99.0.0/16` for test environments.
- For CI-driven infrastructure provisioning, consider adding a `Makefile` target that runs `terraform apply -auto-approve` in the `ecs-test` environment. However, auto-approve should only be used in CI pipelines with proper guardrails.
- The `region` variable should default to a cost-effective region like `us-east-1` for testing. Developers can override it for regional testing.
- Agent connectivity: the test runner must be able to reach Fargate task private IPs on port 9111. Options: (a) run the test runner inside the VPC (e.g., on an EC2 instance or as a Fargate task), (b) use VPC peering if the test runner is in a different VPC, (c) use a public IP assignment for tasks (not recommended for production). For the test environment, option (a) is simplest -- the security group allows port 9111 from the VPC CIDR.
- Cost estimate for a minimal test environment: NAT Gateway ~$32/month + EFS ~$0.30/GB-month (minimal for CI) + CloudWatch Logs ~$0.50/GB ingested. Total: ~$35-40/month when idle. Per-test costs are primarily Fargate task charges (~$0.01-0.05 per short-lived task).
- The `terraform.tfvars.example` file should include the S3 backend bucket name and DynamoDB table name as comments, since these are configured in `backend.tf` and must be created manually.
- Consider adding an `auto.tfvars` entry to `.gitignore` in TF-001 to prevent developers from accidentally committing their local variable overrides.
- The output block should include a helper for generating backend config. For example:
  ```hcl
  output "backend_config_yaml" {
    description = "YAML snippet for ECS backend configuration file"
    value = yamlencode({
      ecs = {
        region             = var.region
        cluster            = module.ecs.ecs_cluster_name
        subnets            = module.ecs.private_subnet_ids
        security_groups    = [module.ecs.task_security_group_id]
        execution_role_arn = module.ecs.execution_role_arn
        task_role_arn      = module.ecs.task_role_arn
        efs_filesystem_id  = module.ecs.efs_filesystem_id
        log_group          = module.ecs.log_group_name
      }
    })
  }
  ```
  This allows the test runner to extract the complete backend config with a single `terraform output -raw backend_config_yaml` command.
- EFS mount targets require the EFS security group to allow NFS traffic from the task security group. Verify that the module (TF-002) creates this cross-reference correctly. The test environment does not need to add additional security group rules beyond what the module provides.
