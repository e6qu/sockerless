# GCR-003: Cloud Run logs, agent injection, and image operations

**Component:** GCR (Google Cloud Run backend)
**Phase:** 3
**Depends on:** GCR-001, AG-001
**Estimated effort:** L

---

## Description

Implement container log retrieval via Cloud Logging, the agent binary injection strategy for Cloud Run containers, and image operations (pull metadata, inspect, load, tag) for the Cloud Run backend. Cloud Run does not support native exec/attach, so the sockerless-agent must be injected into every container. Cloud Run also does not support volume mounts at startup, so the agent injection must use a startup command approach (download agent binary) or an image layer approach (wrapper image with agent baked in). Image operations fetch registry manifests and configs from Artifact Registry and Docker Hub without pulling layers locally.

---

## Context

### Cloud Run log retrieval (Spec Section 9.1)

> | Docker Concept | Cloud Run Mapping |
> |---|---|
> | Container logs | Cloud Logging (`entries.list`) |

Cloud Run Jobs automatically send container stdout/stderr to Cloud Logging. Log entries are tagged with the job name and execution name. The Cloud Logging API (`entries.list`) supports filtering by resource type, job name, and time range.

### Agent injection methods (Spec Section 8.6)

> | Method | Description | Best For |
> |---|---|---|
> | **Volume mount** | Mount agent binary from cloud storage (EFS, GCS, Azure Files) and prepend to entrypoint | ECS, ACA |
> | **Init container** | Run init container that copies agent binary to shared volume | ECS, ACA |
> | **Image layer** | Backend builds a wrapper image with agent included | Cloud Run (no volume mount at startup) |
> | **Not needed** | Backend has native exec (Docker backend) | Docker, Memory |

For Cloud Run, the recommended approach is **Image layer** or a **startup command** that downloads the agent binary from GCS at container startup. The startup command approach avoids building custom images but adds a few seconds to startup.

### Image operations (Spec Section 9.1)

> | Docker Concept | Cloud Run Mapping |
> |---|---|
> | Image pull | Cloud Run pulls from Artifact Registry / GCR / Docker Hub natively |

Cloud Run pulls images natively at execution time. The backend does not need to pull image layers. Instead, `ImagePull` fetches the image manifest and config from the registry (to populate image metadata) and records the image reference in local state. `ImageInspect` returns the stored metadata. `ImageLoad` accepts a tar stream and pushes to a configured staging registry (Artifact Registry).

### Cloud Logging query format

```
resource.type="cloud_run_job"
resource.labels.job_name="sockerless-<container-id-prefix>"
resource.labels.location="<region>"
timestamp >= "<start-time>"
```

---

## Acceptance Criteria

### Logs

1. `ContainerLogs` retrieves log entries from Cloud Logging using the `entries.list` API.
2. Log entries are filtered by: resource type `cloud_run_job`, job name (from container state), execution name (from container state), and region.
3. The `since` parameter maps to a `timestamp >=` filter. The `until` parameter maps to a `timestamp <=` filter.
4. The `tail` parameter limits the number of returned entries (using `pageSize` and reverse ordering).
5. The `timestamps` parameter prepends RFC3339 timestamps to each log line when enabled.
6. Log output uses Docker's multiplexed stream format: 8-byte header framing with stdout (stream type 1) and stderr (stream type 2). Cloud Logging entries with severity `ERROR` or higher are sent to stderr; all others to stdout.
7. The `follow` parameter enables log tailing: the backend polls Cloud Logging at 1-second intervals for new entries and streams them to the client. The stream ends when the execution reaches a terminal state or the client disconnects.
8. GCP Cloud Logging API errors are mapped to Docker-compatible error responses.

### Agent Injection

9. The backend provides an agent injection strategy for Cloud Run containers that does not require pre-built custom images.
10. **Startup command approach:** The container entrypoint is modified to a shell command that downloads the agent binary from a configured GCS path (e.g., `gs://sockerless-agents/sockerless-agent`), makes it executable, and then runs `["/sockerless-agent", "--", <original-entrypoint>, <original-cmd>...]`.
11. **Image layer approach (alternative):** The backend can be configured to reference a wrapper base image that already includes the agent binary. The user's image is used as-is with the entrypoint overridden.
12. The agent injection method is configurable via the `agent.injection_method` config key (values: `startup_command`, `image_layer`). Default: `startup_command`.
13. For the startup command approach, the GCS bucket and object path for the agent binary are configurable: `agent.gcs_bucket`, `agent.gcs_object` (default: `sockerless-agent`).

### Image Operations

14. `ImagePull` fetches the image manifest and config from the registry (Artifact Registry or Docker Hub) using registry HTTP API v2. It does NOT download image layers.
15. `ImagePull` returns a streaming JSON progress response compatible with Docker's pull output format.
16. `ImageInspect` returns stored image metadata (ID, RepoTags, Size, Config with Cmd/Entrypoint/Env/ExposedPorts/Volumes/Labels, etc.).
17. `ImageLoad` accepts a Docker tar archive, extracts the image manifest and layers, and pushes them to a configured Artifact Registry repository. Returns the resulting image reference.
18. `ImageTag` creates a new tag for an existing image in local state.
19. Registry authentication is handled via Docker's auth config format (base64-encoded credentials). Artifact Registry auth uses GCP service account credentials. Docker Hub uses username/password or token auth.
20. Image operations correctly handle both Artifact Registry (`REGION-docker.pkg.dev/PROJECT/REPO/IMAGE`) and Docker Hub (`docker.io/library/IMAGE`) references.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests with mock GCP clients for: Cloud Logging query construction, log entry formatting (multiplexed framing), follow mode polling, agent injection (startup command generation, image layer override), image manifest/config fetch, image load and push, image tag operations
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Cloud Logging API errors wrapped with context: `fmt.Errorf("cloudrun: container logs: %w", err)`
- [ ] Registry API errors mapped to Docker-compatible errors (e.g., manifest not found -> 404)
- [ ] Agent binary download failures produce clear error messages during container start
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated with log retrieval, agent injection, and image operation details

### Integration
- [ ] Log output compatible with frontend's streaming response handler
- [ ] Agent injection works with AG-001 (WebSocket server), AG-002 (exec), AG-003 (attach)
- [ ] Image metadata available for ContainerCreate to validate image existence and extract config

---

## Suggested File Paths

```
backends/cloudrun/
├── container_logs.go           # ContainerLogs: Cloud Logging query, streaming, follow mode
├── agent_inject.go             # Agent injection strategies (startup command, image layer)
├── image_pull.go               # ImagePull: registry manifest/config fetch
├── image_inspect.go            # ImageInspect: return stored metadata
├── image_load.go               # ImageLoad: tar extract, push to Artifact Registry
├── image_tag.go                # ImageTag: create new tag in local state
├── registry.go                 # Registry HTTP client (Artifact Registry + Docker Hub)
└── errors.go                   # (update) Cloud Logging and registry error mapping
```

---

## Notes

- Cloud Logging entries for Cloud Run Jobs use the resource type `cloud_run_job`. Filter by `resource.labels.job_name` and `resource.labels.location` to scope to a specific job execution. Additionally filter by `labels."run.googleapis.com/execution_name"` to scope to a specific execution.
- Cloud Logging returns structured log entries. The `textPayload` field contains the raw log line. If the entry uses `jsonPayload`, serialize it back to a single JSON line. The `severity` field determines stdout vs stderr routing.
- For the follow mode, Cloud Logging does not support real-time streaming (unlike CloudWatch Logs). Polling at 1-second intervals with an advancing timestamp filter is the recommended approach. Stop polling when the execution reaches a terminal state.
- The startup command agent injection generates a shell entrypoint like: `sh -c 'wget -q -O /tmp/sockerless-agent https://storage.googleapis.com/BUCKET/sockerless-agent && chmod +x /tmp/sockerless-agent && exec /tmp/sockerless-agent -- ORIGINAL_ENTRYPOINT ORIGINAL_CMD'`. This adds 1-3 seconds to container startup. The GCS bucket must be readable by the Cloud Run service account.
- For Artifact Registry, use the `REGION-docker.pkg.dev` hostname. The registry HTTP API v2 endpoints are standard OCI distribution spec endpoints (`/v2/`, `/v2/NAME/manifests/REFERENCE`, `/v2/NAME/blobs/DIGEST`).
- Image load (tar import) is primarily needed for GitLab Runner's helper image. The tar is extracted, layers are pushed to Artifact Registry, and the manifest is created. This is a heavy operation; prefer configuring `helper_image` to point to a pre-pushed registry image.
- The `google.golang.org/api/logging/v2` package or `cloud.google.com/go/logging/logadmin` can be used for Cloud Logging reads. The `logadmin` package provides a higher-level Go API.
- When using the startup command approach for agent injection, the container must have `wget` or `curl` available. Most CI base images include these. If neither is available, the image layer approach must be used instead. Consider detecting this at container start time and falling back gracefully.
- For the image layer approach, the backend needs access to a container registry where it can store wrapper images. The `agent.registry` config key specifies the Artifact Registry repository to use (e.g., `us-central1-docker.pkg.dev/my-project/sockerless-agents`). The wrapper image is built by prepending a layer containing the agent binary to the user's image manifest.
- Cloud Logging has a brief ingestion delay (typically 1-5 seconds). During `follow` mode, new log entries may not appear immediately. The polling interval of 1 second accounts for this, but the effective latency for log tailing is 2-6 seconds (ingestion delay + poll interval).
- For image pull progress streaming, emit Docker-compatible JSON objects: `{"status":"Pulling from library/alpine","id":"latest"}`, `{"status":"Pulling fs layer","progressDetail":{},"id":"sha256:abc..."}`, `{"status":"Pull complete","progressDetail":{},"id":"sha256:abc..."}`, `{"status":"Digest: sha256:..."}`, `{"status":"Status: Downloaded newer image for alpine:latest"}`. These are consumed by Docker CLI and CI runners.
- Registry auth for Artifact Registry: use `oauth2accesstoken` as the username and a valid OAuth2 access token as the password. The GCP SDK can generate these tokens from the service account credentials.
- The agent injection in this task provides the strategy and configuration. The actual entrypoint modification is applied in GCR-002 (`agent_inject.go`) during `ContainerCreate`. This task defines the injection logic that GCR-002 calls.
