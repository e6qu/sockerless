# FE-002: Multiplexed Stream Protocol Library

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** ---
**Estimated effort:** M

---

## Description

Implement Docker's 8-byte header multiplexed stream protocol as a standalone, reusable Go package. This protocol is used by the `attach`, `exec/start`, and `logs` endpoints when `Tty: false` (the standard case for CI runners). The library must produce output that is binary-compatible with Docker's `stdcopy.StdCopy` from the Docker Go SDK, since GitLab Runner uses that function to demultiplex output.

## Context

### Multiplexed Stream Protocol (spec Section 5.2)

When `Tty: false` (which is always the case for CI runners), attach and exec use Docker's multiplexed stream format:

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| STREAM | 0x00   | 0x00   | 0x00   | SIZE1  | SIZE2  | SIZE3  | SIZE4  |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

- **Byte 0 (STREAM):** `0` = stdin, `1` = stdout, `2` = stderr
- **Bytes 1-3:** Padding (zeros)
- **Bytes 4-7:** Payload size as big-endian uint32
- **Following bytes:** Payload (exactly `SIZE` bytes)

GitLab Runner uses `stdcopy.StdCopy` from the Docker Go SDK to demultiplex this. Any incorrect framing breaks CI job output.

### Stream Types

| Value | Stream | Direction |
|-------|--------|-----------|
| `0` | stdin | Client -> Server |
| `1` | stdout | Server -> Client |
| `2` | stderr | Server -> Client |

### Connection Hijacking (spec Section 5.3)

The `attach` and `exec/start` endpoints use HTTP connection hijacking:

1. Client sends HTTP POST request
2. Server responds with `101 Switching Protocols`
3. The TCP connection is now a raw bidirectional byte stream
4. Server writes multiplexed frames for stdout/stderr
5. Client writes raw bytes for stdin (NOT multiplexed when Tty=false)
6. Connection closes when the command/container exits

Content-Type: `application/vnd.docker.raw-stream` (or `application/vnd.docker.multiplexed-stream`)

### How CI Runners Read Streams

- **GitLab Runner:** Calls `stdcopy.StdCopy(stdout, stderr, hijackedConn.Reader)` to demultiplex. This reads the 8-byte header, routes to the correct writer, and loops until EOF.
- **GitHub Runner:** Uses the Docker SDK's `HijackedResponse` type, which also uses stdcopy internally.

## Acceptance Criteria

1. `Encoder` type writes correctly framed multiplexed headers: `Write(stream byte, payload []byte) (int, error)`
2. `Decoder` type reads and parses multiplexed frames: `Read() (stream byte, payload []byte, err error)`
3. Encode-then-decode round-trips correctly for all stream types (0, 1, 2)
4. Output is binary-compatible with Docker's `stdcopy.StdCopy` — a test encodes data with the Sockerless encoder and decodes it with the real `stdcopy.StdCopy` from `github.com/docker/docker/pkg/stdcopy`
5. Empty payloads (size=0) are handled correctly
6. Maximum payload size (uint32 max = 4 GiB) is handled without overflow
7. Partial reads are handled correctly (decoder reads from a slow stream)
8. Invalid stream type values (>2) return a descriptive error
9. Fuzz test with random stream types, payload sizes, and payload contents passes without panics
10. Concurrent writes from multiple goroutines are safe (encoder is goroutine-safe with mutex)

### Example Requests

This is a library, not an endpoint. The verification is programmatic:

```go
// Encode
var buf bytes.Buffer
enc := mux.NewEncoder(&buf)
enc.Write(mux.Stdout, []byte("hello world\n"))
enc.Write(mux.Stderr, []byte("error message\n"))

// Decode with Docker's stdcopy
var stdout, stderr bytes.Buffer
stdcopy.StdCopy(&stdout, &stderr, &buf)
// stdout.String() == "hello world\n"
// stderr.String() == "error message\n"
```

```bash
# Verify binary format with hexdump (for manual inspection)
# Stdout frame for "hi\n" (3 bytes):
# 01 00 00 00 00 00 00 03 68 69 0a
#  ^stream    ^padding   ^size(3)  ^payload
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Compatibility test using real `stdcopy.StdCopy` passes
- [ ] Fuzz test (`go test -fuzz`) runs for at least 30 seconds without failures
- [ ] Benchmark test for encode/decode throughput exists

## Suggested File Paths

```
frontends/docker/mux/
├── mux.go          # Constants (Stdin=0, Stdout=1, Stderr=2), HeaderSize=8
├── encoder.go      # Encoder type: Write(stream, payload)
├── decoder.go      # Decoder type: Read() (stream, payload, err)
├── mux_test.go     # Unit tests: round-trip, edge cases, stdcopy compat
├── fuzz_test.go    # Fuzz tests
└── bench_test.go   # Benchmarks
```

Alternatively, this could be a shared package at a higher level if other components need it. But since only the frontend uses it, `frontends/docker/mux/` is the natural location.

## Notes

- The header size is exactly 8 bytes. The `encoding/binary` package with `binary.BigEndian.PutUint32` / `binary.BigEndian.Uint32` is the right tool for encoding/decoding the size field.
- Stdin from the client is NOT multiplexed when `Tty=false` (raw bytes). Only server-to-client (stdout/stderr) uses the 8-byte header format. The encoder is used server-side; stdin is read as raw bytes.
- For the compatibility test, add `github.com/docker/docker` as a test-only dependency. The `stdcopy` package is at `github.com/docker/docker/pkg/stdcopy`.
- The `Encoder` should be safe for concurrent use (multiple goroutines writing stdout and stderr simultaneously). Use a `sync.Mutex` around the underlying writer.
- The `Decoder` does not need to be concurrent (it reads sequentially from one connection).
- Consider implementing `io.Writer` interface on a stream-specific writer: `enc.StdoutWriter()` returns an `io.Writer` that wraps each `Write` call in a stdout frame. This simplifies integration with `io.Copy`.
- Maximum theoretical payload per frame is `2^32 - 1` bytes (~4 GiB). In practice, payloads are small (line-buffered log output). But the implementation must handle large payloads without truncation.
