# FE-012: Exec create and inspect

**Component:** FE (Docker REST API frontend)
**Phase:** 1
**Depends on:** FE-005
**Estimated effort:** M

---

## Description

Implement the exec create and exec inspect endpoints. Exec create registers a new exec instance against a running container, storing the command configuration (Cmd, Env, WorkingDir, attach flags, Tty) without actually executing anything. Exec inspect returns the current status of an exec instance (Running, ExitCode, Pid). These are prerequisites for exec start (FE-013), which performs the actual execution. GitLab Runner uses exec for cleanup signal delivery and the newer CI Steps mode. GitHub Actions Runner uses exec as its PRIMARY execution mechanism for every workflow step.

---

## Context

### Exec create (Spec Section 4.4)

> `POST /containers/{id}/exec` -- Create Exec Instance
>
> Request body:
> ```json
> {
>   "AttachStdin": true,
>   "AttachStdout": true,
>   "AttachStderr": true,
>   "Tty": false,
>   "Cmd": ["sh", "-c", "echo hello"],
>   "Env": ["FOO=bar"],
>   "WorkingDir": "/app"
> }
> ```
>
> Response:
> ```json
> {
>   "Id": "<exec-id>"
> }
> ```
>
> Records the exec configuration. Does not execute anything yet.

### Exec inspect (Spec Section 4.4)

> `GET /exec/{id}/json` -- Inspect Exec Instance
>
> ```json
> {
>   "ID": "<exec-id>",
>   "Running": false,
>   "ExitCode": 0,
>   "Pid": 0
> }
> ```

### GitHub Actions Runner exec usage (Spec Section 13.2.2, 13.2.4)

> ```
> 9. Step Execution (for each workflow step)
>    docker exec -i --workdir <path> -e VAR1=val1 -e VAR2=val2 \
>      <container-id> bash -e /path/to/step-script.sh
>    # Exit code from `docker exec` process = step result
>    # NO retry on exec failure -- immediate step failure
> ```
>
> The runner uses `docker exec -i` for ALL step executions. The `-i` flag keeps stdin open. Exit codes are read from the `docker exec` process return code (not from `docker inspect`).

### GitLab Runner exec usage (Spec Section 13.1.3)

> Exec is used only for: (1) sending SIGTERM to container processes during cleanup (`execScriptOnContainer` runs `sh -c <sigterm-script>`), and (2) the newer CI Steps/Functions mode (`ContainerExecCreate` + `ContainerExecAttach`). Note: the runner uses `ContainerExecAttach` (which combines start + attach into one hijacked connection), NOT `ContainerExecStart` as a separate call.

### Exec reliability requirement (Spec Section 13.2.4, Gap 11)

> The runner does NOT retry failed exec calls. If exec fails once, the step fails. The agent must be ready to accept exec on the first attempt.

---

## Acceptance Criteria

1. `POST /containers/{id}/exec` accepts a JSON body with fields: `AttachStdin` (bool), `AttachStdout` (bool), `AttachStderr` (bool), `Tty` (bool), `Cmd` (string array, required), `Env` (string array), `WorkingDir` (string).
2. `POST /containers/{id}/exec` returns `201 Created` with body `{"Id": "<exec-id>"}`.
3. The generated exec ID is a unique identifier (e.g., 64-character hex string, matching Docker's format).
4. `POST /containers/{id}/exec` returns `404` with `{"message": "No such container: <id>"}` if the container does not exist.
5. `POST /containers/{id}/exec` returns `409` with `{"message": "Container <id> is not running"}` if the container is not in the "running" state.
6. `POST /containers/{id}/exec` returns `400` if the `Cmd` field is missing or empty.
7. The exec instance is stored in the backend's state with all configuration fields, linked to its parent container ID.
8. `GET /exec/{id}/json` returns `200` with body `{"ID": "<exec-id>", "Running": <bool>, "ExitCode": <int>, "Pid": <int>}`.
9. `GET /exec/{id}/json` returns `404` with `{"message": "No such exec instance: <id>"}` if the exec does not exist.
10. Before exec start, `Running` is `false`, `ExitCode` is `0`, and `Pid` is `0`.
11. After exec completes (via FE-013), `Running` is `false` and `ExitCode` reflects the actual process exit code.
12. Both endpoints accept the container referenced by full ID or name for `{id}` in the create path.

### Example Requests

```bash
# Create an exec instance
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{
    "AttachStdin": true,
    "AttachStdout": true,
    "AttachStderr": true,
    "Tty": false,
    "Cmd": ["bash", "-e", "/tmp/step-script.sh"],
    "Env": ["CI=true", "GITHUB_ACTIONS=true"],
    "WorkingDir": "/github/workspace"
  }' \
  http://localhost/v1.44/containers/abc123def456/exec
# Response: 201
# {"Id":"e90e34656806072..."}

# Create exec with minimal fields
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{"Cmd": ["echo", "hello"]}' \
  http://localhost/v1.44/containers/abc123def456/exec
# Response: 201
# {"Id":"a1b2c3d4e5f6..."}

# Exec create on non-existent container
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{"Cmd": ["ls"]}' \
  http://localhost/v1.44/containers/nonexistent/exec
# Response: 404
# {"message":"No such container: nonexistent"}

# Exec create on stopped container
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/json" \
  -d '{"Cmd": ["ls"]}' \
  http://localhost/v1.44/containers/stopped-container/exec
# Response: 409
# {"message":"Container stopped-container is not running"}

# Inspect an exec instance (before start)
curl -s --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/exec/e90e34656806072/json
# Response: 200
# {"ID":"e90e34656806072...","Running":false,"ExitCode":0,"Pid":0}

# Inspect an exec instance (after completion)
curl -s --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/exec/e90e34656806072/json
# Response: 200
# {"ID":"e90e34656806072...","Running":false,"ExitCode":0,"Pid":42}

# Inspect non-existent exec
curl -s --unix-socket /var/run/sockerless.sock \
  http://localhost/v1.44/exec/nonexistent/json
# Response: 404
# {"message":"No such exec instance: nonexistent"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for: exec create (success, missing cmd, container not found, container not running), exec inspect (before start, after completion, not found)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (NotFound, Conflict, BadRequest)
- [ ] Errors wrapped with context: `fmt.Errorf("exec create: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated if new public API is added

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Exec state is accessible to FE-013 (exec start) for subsequent execution
- [ ] Capability model consulted (backend may not support exec)

---

## Suggested File Paths

```
frontends/docker/
├── handler_exec_create.go    # POST /containers/{id}/exec handler
├── handler_exec_inspect.go   # GET /exec/{id}/json handler
└── routes.go                 # Register new routes (update existing)
```

---

## Notes

- Docker's exec create returns `201 Created`, not `200 OK`. Match this exactly.
- The exec ID format in Docker is a 64-character hex string. Use the same format for consistency with container IDs.
- The `Cmd` field is required. Docker returns `400 Bad Request` if it is missing or empty. The error message should be: `{"message":"No command specified"}`.
- The exec inspect response uses `"ID"` (uppercase) not `"Id"` (mixed case). This differs from container inspect. Match Docker's exact casing.
- Exec instances are ephemeral. They do not survive daemon restarts. This is consistent with Docker's behavior.
- Exec instances are linked to their parent container. If the container is removed, its exec instances should also be cleaned up.
- The `ContainerID` and `ProcessConfig` fields are also present in Docker's full exec inspect response but are not critical for CI runner compatibility. Include them for completeness if feasible.
- GitLab Runner uses `ContainerExecAttach` which combines exec start + stream attachment. Ensure the exec state created here is compatible with both the standard start flow (FE-013) and a combined start+attach flow.
