# FE-010: POST /containers/{id}/wait

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** FE-005
**Estimated effort:** S

---

## Description

Implement the `POST /containers/{id}/wait` endpoint. This is a long-polling endpoint that blocks until a container exits, then returns the exit status code. GitLab Runner uses it with `condition=not-running` to wait for job containers to finish. GitHub Actions Runner uses `docker wait` (which calls this endpoint) for container action steps.

## Context

### Container Wait (spec Section 4.3)

Query parameter:
- `condition` (string): `not-running` (used by GitLab Runner), `next-exit`, `removed`

**Response** (when container exits):
```json
{
  "StatusCode": 0,
  "Error": null
}
```

Long-polling endpoint. Blocks until the container reaches the specified condition. Sockerless polls the cloud backend task status and returns when the task completes.

### Condition Semantics

| Condition | Behavior |
|-----------|----------|
| `not-running` | Returns when the container is no longer running (i.e., state is `exited`, `dead`, or `removed`). If the container is already not running, returns immediately. **This is what GitLab Runner uses.** |
| `next-exit` | Returns on the *next* state transition to `exited`. If the container is already exited, waits for a restart and subsequent exit. |
| `removed` | Returns when the container is removed entirely. |

Default condition (if not specified): `not-running`.

### Error Response

If the container stopped with an error:
```json
{
  "StatusCode": 137,
  "Error": {
    "Message": "container killed by signal 9"
  }
}
```

### Internal API (spec Section 7.3)

Frontend sends: `WS /internal/v1/containers/{id}/wait` (WebSocket for long-poll). The backend sends a single message when the container reaches the specified condition, then closes the WebSocket.

### How CI Runners Use Wait

- **GitLab Runner:** Calls `ContainerWait(ctx, id, container.WaitConditionNotRunning)` after attaching. Blocks until the container exits, then reads the exit code to determine if the CI job passed or failed.
- **GitHub Actions Runner:** Uses `docker wait <container-id>` for container action steps. This calls `POST /containers/{id}/wait` with default condition (`not-running`).

## Acceptance Criteria

1. `POST /containers/{id}/wait` blocks until the container exits, then returns `200 OK`
2. Response body is `{"StatusCode": <int>, "Error": null}` on clean exit
3. Response body is `{"StatusCode": <int>, "Error": {"Message": "<reason>"}}` on error exit
4. `condition=not-running`: returns immediately if container is already stopped; blocks if running
5. `condition=next-exit`: waits for the next exit transition (does not return for already-exited containers)
6. `condition=removed`: waits until the container is deleted
7. Default condition (no query param) is `not-running`
8. Returns `404 Not Found` with `{"message": "No such container: <id>"}` if container does not exist
9. `StatusCode` matches the container's actual exit code (0 for success, non-zero for failure)
10. Multiple concurrent wait calls on the same container all receive the same result
11. Cancellation: if the client disconnects, the server-side wait is cleaned up (no goroutine leak)
12. Works with container ID prefix and container name resolution

### Example Requests

```bash
# Wait for a running container to exit (blocks until exit)
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/a1b2c3d4e5f6/wait"
# (blocks...)
# 200 {"StatusCode":0,"Error":null}

# Wait with explicit condition
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/a1b2c3d4e5f6/wait?condition=not-running"
# (blocks until not running...)
# 200 {"StatusCode":0,"Error":null}

# Wait on already-exited container (returns immediately for not-running)
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/exited-container/wait?condition=not-running"
# 200 {"StatusCode":1,"Error":{"Message":"exit code 1"}}

# Wait for container removal
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/a1b2c3d4e5f6/wait?condition=removed"
# (blocks until DELETE /containers/{id} is called...)
# 200 {"StatusCode":0,"Error":null}

# Container not found
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/nonexistent/wait"
# 404 {"message":"No such container: nonexistent"}

# Non-zero exit code
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/failed-container/wait"
# 200 {"StatusCode":137,"Error":{"Message":"container killed by signal 9"}}
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Long-poll behavior verified: blocks for running container, returns for exited
- [ ] `not-running` condition returns immediately for already-exited containers
- [ ] Exit code correctly propagated from backend
- [ ] Client disconnect does not leak goroutines
- [ ] Multiple concurrent wait calls all resolve correctly

## Suggested File Paths

```
frontends/docker/
└── handler_container_wait.go   # POST /containers/{id}/wait handler
```

## Notes

- This is a long-polling HTTP endpoint, NOT a WebSocket from the Docker client's perspective. The client sends a POST and the server holds the response open until the condition is met. The response is a single JSON object, not a stream.
- The internal API between frontend and backend uses WebSocket for this (to avoid HTTP timeout issues). The frontend opens a WebSocket to `WS /internal/v1/containers/{id}/wait`, the backend sends one message when the condition is met, and the frontend writes the HTTP response and closes the connection.
- Use `context.Context` for cancellation. The request context (`r.Context()`) is cancelled when the client disconnects. Pass this to the backend wait call so it can clean up.
- For the memory backend, implement wait as a channel-based mechanism: each container has a `done` channel that is closed when the container exits. Wait callers select on this channel and the request context.
- The `Error` field in the response is `null` (not absent) for clean exits. For error exits, it's `{"Message": "..."}`. The Docker SDK expects this exact structure.
- Be careful with the `next-exit` condition: if a container is restarted, `next-exit` waits for the *next* exit, not the current state. For Sockerless (no restart policy support in Phase 1), `next-exit` and `not-running` behave identically unless the container is already exited.
- The `removed` condition is useful for cleanup orchestration. The wait returns only after `DELETE /containers/{id}` removes the container from state.
- The HTTP response status is always `200 OK` (even for non-zero exit codes). The exit code is in the response body, not the HTTP status.
