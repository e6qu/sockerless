# AG-002: Agent exec handler

**Component:** Agent (Container agent)
**Phase:** 2
**Depends on:** AG-001
**Estimated effort:** L

---

## Description

Implement the exec handler in the sockerless agent. When the frontend sends an `exec` message over the WebSocket, the agent forks and execs the specified command as a child process inside the container. The agent streams stdin from the WebSocket to the child's stdin, and multiplexes the child's stdout and stderr back to the WebSocket as separate message types. When the child exits, the agent sends an `exit` message with the exit code. The handler must support multiple concurrent exec sessions, each identified by a unique `id` field.

---

## Context

### Exec flow (Spec Section 8.5)

> ```
> GitHub Runner               Frontend                    Backend              Agent
>     |                            |                          |                   |
>     | (container already running with "tail -f /dev/null")  |                   |
>     |                            |                          |                   |
>     |-- POST /containers/abc/    |                          |                   |
>     |   exec ------------------>| -- POST .../exec ------->| (store exec meta) |
>     | <-- {Id: "exec-1"} ------ | <-- {id: "exec-1"} ----- |                   |
>     |                            |                          |                   |
>     |-- POST /exec/exec-1/start | |                          |                   |
>     |   (hijacked connection)    |                          |                   |
>     |                            | -- ws://agent:9111 --------------------------->|
>     |                            | -- {"type":"exec",       |                   |
>     |                            |     "cmd":["sh","-c",    |                   |
>     |                            |     "script"]} ----------------------------->|
>     |                            |                          |                   |
>     | <-- mux stdout ----------- | <-- {"type":"stdout"} ---------------------- |
>     | ---- stdin --------------->| ---- {"type":"stdin"} ---------------------->|
>     | <-- mux stderr ----------- | <-- {"type":"stderr"} ---------------------- |
>     |                            |                          |                   |
>     | <-- exit code ------------ | <-- {"type":"exit","code":0} --------------- |
> ```

### WebSocket message types for exec (Spec Section 8.3)

**Frontend -> Agent (exec session):**
- `{"type":"exec", "id":"<session-id>", "cmd":["sh","-c","echo hello"], "env":["FOO=bar"], "workdir":"/app", "tty":false}` -- fork+exec command
- `{"type":"stdin", "id":"<session-id>", "data":"<base64>"}` -- pipe bytes to process stdin
- `{"type":"close_stdin", "id":"<session-id>"}` -- close stdin (EOF)
- `{"type":"signal", "id":"<session-id>", "signal":"SIGTERM"}` -- send signal to process

**Agent -> Frontend (exec session):**
- `{"type":"stdout", "id":"<session-id>", "data":"<base64>"}` -- stdout bytes
- `{"type":"stderr", "id":"<session-id>", "data":"<base64>"}` -- stderr bytes
- `{"type":"exit", "id":"<session-id>", "code":0}` -- process exited

### Exec reliability requirement (Spec Section 13.3, Gap 11)

> The runner does NOT retry failed exec calls. If exec fails once, the step fails. The agent must be ready to accept exec on the first attempt.
>
> The agent starts its WebSocket server as the first thing on startup (before running the user process). The backend waits for agent readiness (health probe to agent's WebSocket endpoint) before returning from `POST /containers/{id}/start`.

### GitHub Actions exec usage (Spec Section 13.2.4)

> The runner uses `docker exec -i` for ALL step executions. The `-i` flag keeps stdin open. Exit codes are read from the `docker exec` process return code. NO retry on exec failure -- immediate step failure.

---

## Acceptance Criteria

1. When the agent receives `{"type":"exec", "id":"<id>", "cmd":["sh","-c","echo hello"]}`, it forks and execs the specified command as a child process.
2. The `cmd` field is an array of strings. The first element is the executable, the rest are arguments. The agent uses `os/exec.CommandContext` to run the command.
3. If `env` is provided (array of `KEY=VALUE` strings), those environment variables are set on the child process (merged with the container's existing environment).
4. If `workdir` is provided, the child process's working directory is set to that path.
5. If `tty` is `true`, the child process is started with a pseudo-TTY allocated (using `github.com/creack/pty` or equivalent). Stdout and stderr are merged into a single stream on the TTY.
6. The agent reads the child's stdout in a goroutine and sends `{"type":"stdout", "id":"<id>", "data":"<base64>"}` messages over the WebSocket.
7. The agent reads the child's stderr in a separate goroutine and sends `{"type":"stderr", "id":"<id>", "data":"<base64>"}` messages over the WebSocket.
8. When the frontend sends `{"type":"stdin", "id":"<id>", "data":"<base64>"}`, the agent base64-decodes the data and writes it to the child's stdin pipe.
9. When the frontend sends `{"type":"close_stdin", "id":"<id>"}`, the agent closes the child's stdin pipe (sends EOF).
10. When the frontend sends `{"type":"signal", "id":"<id>", "signal":"SIGTERM"}`, the agent sends the corresponding signal to the child process. Supported signals: SIGTERM, SIGKILL, SIGINT, SIGHUP.
11. When the child process exits, the agent sends `{"type":"exit", "id":"<id>", "code":<exit-code>}`. The exit code is extracted from `exec.ExitError.ExitCode()`. If the process was killed by a signal, the exit code is `128 + signal_number`.
12. If the command cannot be found or exec fails, the agent sends `{"type":"error", "id":"<id>", "message":"exec: <error details>"}`.
13. Multiple exec sessions can run concurrently on the same WebSocket connection, identified by unique `id` values.
14. Multiple exec sessions can run concurrently across different WebSocket connections.
15. When the WebSocket connection closes, all exec sessions associated with that connection are terminated (SIGKILL to child processes).
16. Stdout/stderr reads use a reasonable buffer size (e.g., 32KB) to avoid excessive message fragmentation while keeping latency low.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing tests continue to pass
- [ ] Unit tests for: exec a simple command and receive stdout, exec with stderr output, exec with stdin piping, exec with close_stdin (EOF), exit code propagation (0, 1, 137), command-not-found error, concurrent exec sessions, signal delivery (SIGTERM), TTY mode
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Command-not-found and permission errors produce `error` messages with descriptive text
- [ ] Errors wrapped with context: `fmt.Errorf("exec session %s: %w", id, err)`
- [ ] Zerolog structured logging with session ID on all exec operations

### Documentation
- [ ] GoDoc comments on all exported types and functions
- [ ] Module `README.md` updated with exec handler details

### Integration
- [ ] Exec handler registered in the message router from AG-001
- [ ] Session lifecycle managed by the session registry from AG-001

---

## Suggested File Paths

```
agent/
├── exec.go                  # Exec session: fork+exec, stdin/stdout/stderr piping
├── exec_test.go             # Unit tests for exec handler
├── session.go               # (update) Register exec session type in session registry
└── message.go               # (update) Add exec-related message structs
```

---

## Notes

- Use `os/exec.CommandContext` with a cancellation context tied to the WebSocket connection lifetime. This ensures child processes are cleaned up when the connection drops.
- For TTY mode, use `github.com/creack/pty` to allocate a pseudo-terminal. In TTY mode, stdout and stderr are merged (single stream from the PTY master fd). Send all output as `stdout` type messages.
- Base64 encoding/decoding uses Go's `encoding/base64.StdEncoding`. Use standard encoding (not URL-safe) for compatibility.
- Buffer stdout/stderr reads with `bufio.Reader` or raw `io.Read` with a 32KB buffer. Do NOT use `bufio.Scanner` (line-buffered) as it would break binary output and introduce latency for partial lines.
- Exit code extraction: Go's `exec.ExitError` wraps the OS process state. On Linux, `ExitCode()` returns -1 if the process was killed by a signal. In that case, extract the signal from `ProcessState.Sys().(syscall.WaitStatus)` and compute `128 + signal`.
- The `id` field is generated by the frontend (or the Docker client). The agent does not generate IDs -- it uses whatever `id` the frontend sends in the `exec` message.
- Consider rate-limiting stdout/stderr messages if the child produces output faster than the WebSocket can send. Use a send buffer per session with backpressure.
