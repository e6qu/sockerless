# AG-004: Agent health check runner

**Component:** Agent (Container agent)
**Phase:** 2
**Depends on:** AG-001
**Estimated effort:** M

---

## Description

Implement the health check runner in the sockerless agent. When the container image defines a `HEALTHCHECK` instruction (or the container create request includes a `Healthcheck` config), the agent periodically executes the health check command inside the container and tracks the health status: `starting` -> `healthy` or `unhealthy`. The health status is reported via the WebSocket (as `health` messages) and also exposed on the agent's HTTP health endpoint so backends can query it. GitHub Actions Runner polls `docker inspect` for `.State.Health.Status` to determine when service containers are ready.

---

## Context

### Health check status reporting (Spec Section 13.3, Gap 9)

> If the image defines a `HEALTHCHECK` instruction (detected during image config fetch from registry), the agent runs the health check command inside the container at the specified interval. The agent reports health status to the backend. The backend stores it and returns it in `GET /containers/{id}/json` -> `State.Health.Status`.
>
> If no `HEALTHCHECK` is defined, `Config.Healthcheck` is absent/null and `State.Health` is omitted entirely (matching Docker's behavior). The runner skips health polling in this case.

### GitHub Actions health check polling (Spec Section 13.2.4)

> Uses `docker inspect --format '{{if .Config.Healthcheck}}{{print .State.Health.Status}}{{end}}'`. If `.Config.Healthcheck` is absent (no HEALTHCHECK instruction), the template outputs empty string and the runner skips health polling -- container is considered ready immediately. Polling uses exponential backoff: 2s, 3s, 7s, 13s... with ~5-6 retries (total ~30-60s).

### Docker Compose health checks (Spec Section 12.3)

> `docker compose up` with `depends_on` and health checks uses:
> 1. `POST /containers/create` with `Healthcheck` config from compose file
> 2. `GET /containers/{id}/json` polling `.State.Health.Status` until `"healthy"`
> 3. Sequential container startup based on dependency graph

### Docker HEALTHCHECK format

Docker's HEALTHCHECK config has these fields:
- `Test`: `["CMD-SHELL", "curl -f http://localhost/ || exit 1"]` or `["CMD", "curl", "-f", "http://localhost/"]` or `["NONE"]`
- `Interval`: duration between checks (default 30s)
- `Timeout`: max time for a single check (default 30s)
- `Retries`: consecutive failures needed to mark unhealthy (default 3)
- `StartPeriod`: grace period after start before failures count (default 0s)

---

## Acceptance Criteria

1. The agent accepts health check configuration via env var `SOCKERLESS_HEALTHCHECK` (JSON-encoded Docker Healthcheck struct) or via a WebSocket configuration message.
2. If a health check is configured, the agent begins executing it after the main process starts (or immediately in keep-alive mode).
3. During the `StartPeriod`, the health status is `"starting"`. Failed checks during this period do not count toward the retry threshold.
4. After the start period, the agent executes the health check command at the configured `Interval`.
5. Health check execution: for `CMD-SHELL`, run `["/bin/sh", "-c", "<command>"]`. For `CMD`, run the command array directly. For `NONE`, disable health checking.
6. Each health check execution has a `Timeout`. If the command does not exit within the timeout, it is killed and counted as a failure.
7. If `Retries` consecutive checks fail (exit code != 0 or timeout), the status transitions to `"unhealthy"`.
8. If a check succeeds (exit code 0), the status transitions to `"healthy"` and the failure counter resets.
9. The agent sends `{"type":"health", "status":"healthy", "log":"<last check output>"}` messages over active WebSocket connections whenever the health status changes.
10. `GET /health` on the agent's HTTP server returns the current health check status: `{"status":"ok", "container_health":"healthy"}` (or `"starting"`, `"unhealthy"`, `"none"`). `"none"` means no health check is configured.
11. The health check log (stdout+stderr of the last N checks, matching Docker's `State.Health.Log` format) is stored and available via a WebSocket query message or the HTTP health endpoint.
12. Health check history stores the last 5 results (matching Docker's behavior), each with: `Start` time, `End` time, `ExitCode`, `Output` (truncated to 4096 bytes).
13. If no health check is configured, no health check runs, and the HTTP health endpoint returns `"container_health":"none"`.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing tests continue to pass
- [ ] Unit tests for: health check with CMD-SHELL (success and failure), health check with CMD (success and failure), status transitions (starting -> healthy, starting -> unhealthy, unhealthy -> healthy), start period behavior (failures don't count), timeout handling (command killed), retry counting (consecutive failures), health check history (last 5 results), no health check configured (none status), NONE test type disables checking
- [ ] Tests are deterministic (use short intervals and timeouts for fast tests)

### Error Handling
- [ ] Health check command failures are logged but do not crash the agent
- [ ] Errors wrapped with context: `fmt.Errorf("health check: %w", err)`
- [ ] Zerolog structured logging with health status transitions

### Documentation
- [ ] GoDoc comments on all exported types and functions
- [ ] Module `README.md` updated with health check runner details

### Integration
- [ ] Health status exposed via HTTP endpoint (for backend polling)
- [ ] Health status sent via WebSocket messages (for frontend/backend integration)
- [ ] Compatible with Docker's `State.Health` response format for inspect

---

## Suggested File Paths

```
agent/
├── healthcheck.go           # Health check runner: timer, execution, status tracking
├── healthcheck_test.go      # Unit tests for health check runner
├── server.go                # (update) Extend /health endpoint with container_health
└── config.go                # (update) Parse SOCKERLESS_HEALTHCHECK env var
```

---

## Notes

- The health check runner is a long-lived goroutine started at agent initialization. It uses a `time.Ticker` for the interval. During the start period, use a separate timer or simply ignore failures.
- Health check execution uses the same `os/exec.CommandContext` mechanism as exec sessions. However, health check processes are transient -- they run, report, and exit. They are NOT exposed as sessions on the WebSocket.
- Output truncation: Docker truncates health check output to 4096 bytes. Match this behavior to prevent memory issues from health checks that produce excessive output.
- The `SOCKERLESS_HEALTHCHECK` env var contains the JSON-serialized Docker Healthcheck config. Example: `{"Test":["CMD-SHELL","curl -f http://localhost:8080/health || exit 1"],"Interval":10000000000,"Timeout":5000000000,"Retries":3,"StartPeriod":30000000000}`. Note that Docker durations are in nanoseconds.
- Consider thread safety: the health status is read by the HTTP handler (from any goroutine) and written by the health check runner goroutine. Use an `atomic.Value` or `sync.RWMutex` to protect it.
- The health check runner should stop gracefully when the agent shuts down. Use a context with cancellation.
