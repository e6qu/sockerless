# ECS-001: ECS backend scaffold

**Component:** ECS (AWS ECS Fargate backend)
**Phase:** 2
**Depends on:** API-002
**Estimated effort:** M

---

## Description

Build the scaffold for the ECS Fargate backend. This backend translates internal API calls into AWS ECS operations, running containers as Fargate tasks. This task sets up the binary entrypoint, AWS SDK v2 clients, configuration loading, capability reporting, and the HTTP server for the internal API. Individual operations (container create/start, logs, images, networking, volumes) are implemented in subsequent ECS-* tasks.

---

## Context

### ECS backend mapping (Spec Section 9.1)

> | Docker Concept | ECS Mapping |
> |---|---|
> | Container create + start | `RunTask` (Fargate launch type) with task definition registered from container config |
> | Container stop | `StopTask` |
> | Container kill | `StopTask` (ECS has no SIGKILL; tasks get 30s SIGTERM then forced stop) |
> | Container remove | Deregister task definition, clean up |
> | Container inspect | `DescribeTasks` |
> | Container logs | CloudWatch Logs (`GetLogEvents` / `FilterLogEvents`) |
> | Exec / Attach | Via sockerless-agent (agent address from task's ENI private IP) |
> | Image pull | ECS pulls from ECR / Docker Hub / any registry natively |
> | Network | VPC subnets, security groups, AWS Cloud Map for service discovery |
> | Volume | EFS mount, ephemeral storage (20-200 GB) |
>
> **Agent networking:** Fargate tasks get private IPs in the configured VPC. The frontend must be able to reach these IPs (same VPC, VPC peering, or transit gateway). Agent listens on port 9111 -- security group must allow inbound from frontend.
>
> **Startup latency:** 10-45 seconds (image pull + Fargate capacity allocation).

### Capability reporting (Spec Section 9.5)

ECS backend capabilities:
```json
{
  "backend": "ecs",
  "version": "0.1.0",
  "capabilities": {
    "exec": true,
    "attach": true,
    "logs": true,
    "logs_follow": true,
    "volumes": true,
    "networks": true,
    "health_checks": true,
    "image_pull": true,
    "image_load": true,
    "max_timeout_seconds": 0,
    "agent_required": true
  }
}
```

### ECS backend configuration (Spec Section 15.3)

> ```yaml
> ecs:
>   region: us-east-1
>   cluster: sockerless
>   subnets: ["subnet-abc123"]
>   security_groups: ["sg-abc123"]
>   task_role_arn: "arn:aws:iam::..."
>   execution_role_arn: "arn:aws:iam::..."
>   efs_filesystem_id: "fs-abc123"
>   log_group: /sockerless/containers
> ```

---

## Acceptance Criteria

1. `sockerless-backend-ecs` binary compiles and runs from `cmd/sockerless-backend-ecs/main.go`.
2. Server listens on a Unix socket (default `/var/run/sockerless-backend.sock`) or TCP address for internal API requests.
3. AWS SDK v2 clients are initialized for: `ecs`, `cloudwatchlogs`, `efs`, `servicediscovery` (Cloud Map), and `ecr`.
4. Configuration loads from YAML file, environment variables, and CLI flags (priority: flags > env > file > defaults). Required config: `region`, `cluster`, `subnets`, `security_groups`, `execution_role_arn`. Optional: `task_role_arn`, `efs_filesystem_id`, `log_group` (default `/sockerless/containers`).
5. `GET /internal/v1/capabilities` returns the capability JSON with `backend: "ecs"`, `agent_required: true`, and all container-backend capabilities `true`.
6. In-memory state store (or SQLite -- consistent with backend configuration from spec Section 15.3) for containers, images, networks, volumes, execs -- mapping sockerless IDs to AWS resource ARNs/IDs.
7. State store maps: `container_id -> {task_arn, task_definition_arn, agent_address, agent_token, ...}`, `network_id -> {security_group_id, cloud_map_namespace_arn, ...}`, `volume_name -> {efs_access_point_id, ...}`, `image_ref -> {config, digest, ...}`.
8. AWS credentials are loaded via the standard SDK v2 credential chain (env vars, shared config, IAM role, etc.).
9. Error responses use Docker's `{"message": "..."}` format. AWS SDK errors are mapped to appropriate HTTP status codes (e.g., `AccessDenied` -> 500, `ClusterNotFoundException` -> 500).
10. Graceful shutdown on SIGTERM/SIGINT: drain in-flight requests, clean exit.
11. All requests logged via zerolog with method, path, status code, duration, and AWS request IDs where applicable.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests for: configuration loading (YAML, env, flags, defaults), capability reporting, state store CRUD operations, AWS error mapping
- [ ] Tests use mock AWS clients (no real AWS calls in unit tests)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] AWS SDK errors wrapped with context: `fmt.Errorf("ecs: describe tasks: %w", err)`
- [ ] Zerolog structured logging on all error paths with AWS request IDs
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created with ECS backend overview, configuration, and prerequisites

### Integration
- [ ] Implements Backend interface from API-002 (stub methods return NotImplementedError for operations not yet implemented)
- [ ] Capability model accurately reflects ECS backend features

---

## Suggested File Paths

```
backends/ecs/
├── go.mod                          # module github.com/sockerless/backend-ecs, go 1.23
├── go.sum
├── README.md
├── server.go                       # HTTP server setup, route registration
├── capabilities.go                 # Capability reporting handler
├── config.go                       # YAML + env + flag config loading
├── aws.go                          # AWS SDK v2 client initialization
├── store.go                        # State store (container/network/volume -> AWS resource mapping)
├── errors.go                       # AWS error -> HTTP error mapping
└── cmd/
    └── sockerless-backend-ecs/
        └── main.go                 # Binary entrypoint
```

---

## Notes

- Use AWS SDK v2 (`github.com/aws/aws-sdk-go-v2/...`). SDK v1 is in maintenance mode.
- The state store must map between sockerless's 64-char hex IDs and AWS resource ARNs. A single SQL table or in-memory map per resource type is sufficient.
- For the state store, consider SQLite via `modernc.org/sqlite` (pure Go, no CGO) for persistence across restarts. The memory backend uses in-memory maps, but a production ECS backend benefits from surviving restarts.
- AWS SDK error handling: use `errors.As` to check for specific error types (e.g., `types.ClusterNotFoundException`, `types.AccessDeniedException`). Map these to appropriate HTTP error codes.
- The ECS cluster must exist before the backend starts. The backend does NOT create the cluster. Consider a startup validation check (`DescribeClusters`) that logs a warning if the cluster is not found.
- Security group configuration: the default security group should allow inbound on port 9111 from the frontend's network for agent connectivity. This is a deployment concern, but document it clearly.
- Import `github.com/sockerless/api` for shared types and the `Backend` interface.
