# FE-021: Frontend WebSocket bridge

**Component:** FE (Docker REST API frontend)
**Phase:** 2
**Depends on:** FE-009, FE-013, AG-001
**Estimated effort:** L

---

## Description

Implement the bridge between Docker client hijacked connections and the agent's WebSocket connection. When a Docker client calls attach or exec start, the frontend hijacks the HTTP connection and gets a raw TCP stream. For cloud backends (where `agent_required: true`), the frontend must open a WebSocket to the agent running inside the cloud container, then bidirectionally bridge the two connections: translating Docker's multiplexed stream protocol (8-byte header framing) to/from the agent's JSON WebSocket messages. The bridge must handle attach-before-start (buffering until the agent is reachable), concurrent bridges, and graceful teardown.

---

## Context

### Agent protocol overview (Spec Section 8)

The frontend connects to the agent on demand. The agent runs inside the cloud container at an address resolved by the backend (e.g., `10.0.1.47:9111`). Communication is via WebSocket with JSON messages.

### Attach-before-start (Spec Section 8.4, Gap 1)

> **Problem:** GitLab Runner calls `ContainerAttach` before `ContainerStart`. Docker returns the hijacked connection instantly because the daemon holds it. Cloud backends don't have a container to attach to yet.
>
> **Solution:** The frontend returns `101 Switching Protocols` immediately and holds the hijacked connection. When `ContainerStart` is called, the backend launches the cloud task. Once the agent is reachable (agent reports ready via backend polling), the frontend opens a WebSocket to the agent and begins bridging the buffered hijacked connection to the agent's stream.

### Exec flow (Spec Section 8.5)

> For exec, the frontend:
> 1. Receives `POST /exec/{id}/start` with hijacked connection
> 2. Looks up the exec instance to find the container ID and agent address
> 3. Opens a WebSocket to the agent
> 4. Sends `{"type":"exec", "id":"<exec-id>", "cmd":[...], ...}`
> 5. Bridges stdin from hijacked connection -> `stdin` WebSocket messages
> 6. Bridges `stdout`/`stderr` WebSocket messages -> multiplexed stream on hijacked connection
> 7. When `exit` message is received, closes the hijacked connection

### Multiplexed stream protocol (Spec Section 13.3, Gap 13)

> The frontend wraps each chunk in the 8-byte header format:
> - Byte 0: stream type (1=stdout, 2=stderr)
> - Bytes 1-3: padding (0x00)
> - Bytes 4-7: payload length (big-endian uint32)
> - Followed by payload bytes
>
> For stdin (client -> agent), the frontend reads raw bytes from the hijacked connection and forwards them as `{"type":"stdin","data":"<base64>"}` WebSocket messages.

### Exec reliability (Spec Section 13.3, Gap 11)

> The runner does NOT retry failed exec calls. If exec fails once, the step fails. The agent must be ready to accept exec on the first attempt. The backend waits for agent readiness before returning from `POST /containers/{id}/start`.

---

## Acceptance Criteria

1. For backends with `agent_required: true`, the attach endpoint (`POST /containers/{id}/attach`) bridges the hijacked connection to the agent's WebSocket instead of delegating to the backend's `ContainerAttach` method.
2. For backends with `agent_required: false` (Docker, Memory), the existing behavior from FE-009 is unchanged -- delegate to the backend directly.
3. **Attach bridge:** After hijacking, the frontend resolves the agent address from the container's inspect data (`agent_address` field). If the container is not yet started (no agent address), the frontend buffers the hijacked connection and waits for the container to start.
4. **Attach bridge:** Once the agent address is available, the frontend opens a WebSocket to `ws://<agent_address>/ws` with `Authorization: Bearer <token>` header.
5. **Attach bridge:** The frontend sends `{"type":"attach", "id":"<session-id>"}` to the agent.
6. **Attach bridge (stdin direction):** The frontend reads raw bytes from the hijacked connection and sends them as `{"type":"stdin", "id":"<session-id>", "data":"<base64>"}` WebSocket messages to the agent.
7. **Attach bridge (stdout/stderr direction):** When the frontend receives `{"type":"stdout", "id":"<id>", "data":"<base64>"}` from the agent, it decodes the base64 data, wraps it in an 8-byte multiplexed header (stream type 1 for stdout), and writes it to the hijacked connection.
8. **Attach bridge (stderr):** `{"type":"stderr", ...}` messages are wrapped with stream type 2 in the multiplexed header.
9. **Attach bridge (exit):** When the frontend receives `{"type":"exit", "id":"<id>", "code":<n>}`, it closes the hijacked connection. The attach bridge is complete.
10. **Exec bridge:** The exec start endpoint (`POST /exec/{id}/start`) bridges the hijacked connection to the agent's WebSocket similarly to attach.
11. **Exec bridge:** The frontend sends `{"type":"exec", "id":"<exec-id>", "cmd":[...], "env":[...], "workdir":"...", "tty":...}` using the exec config stored from `POST /containers/{id}/exec`.
12. **Exec bridge:** Stdin, stdout, stderr, and exit are bridged identically to the attach bridge.
13. **Exec bridge (exit code):** The exit code from the agent's `exit` message is stored in the exec instance state so `GET /exec/{id}/json` returns the correct `ExitCode`.
14. Multiple concurrent bridges are supported (one per attach/exec request).
15. If the agent WebSocket connection drops unexpectedly, the frontend closes the hijacked connection with an error (empty close, matching Docker's behavior on daemon crash).
16. If the hijacked connection drops (client disconnects), the frontend sends `{"type":"close_stdin", "id":"<id>"}` to the agent and closes the WebSocket.
17. The bridge adds no more than 1ms of latency per message in the hot path (simple copy, no buffering beyond what is necessary).

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New tests for: attach bridge (stdin->agent, stdout->client, stderr->client, exit closes connection), exec bridge (same), attach-before-start buffering, concurrent bridges, agent disconnect handling, client disconnect handling
- [ ] Tests run against memory backend by default (using a mock agent or in-process agent)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Agent unreachable: attach/exec returns error to client after timeout
- [ ] Errors wrapped with context: `fmt.Errorf("ws bridge: %w", err)`
- [ ] Zerolog structured logging with container ID, session ID, bridge direction

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated with WebSocket bridge architecture

### Integration
- [ ] Capability-aware: only used when `agent_required: true`
- [ ] No breaking changes to existing attach/exec behavior for non-agent backends
- [ ] Agent token retrieved from container inspect data

---

## Suggested File Paths

```
frontends/docker/
├── bridge.go                # WebSocket bridge: hijacked conn <-> agent WebSocket
├── bridge_attach.go         # Attach-specific bridge logic (attach-before-start buffering)
├── bridge_exec.go           # Exec-specific bridge logic (exec config forwarding)
├── handler_attach.go        # (update) Route to bridge for agent-required backends
├── handler_exec_start.go    # (update) Route to bridge for agent-required backends
└── mux_stream.go            # (update from FE-002) Multiplexed stream encode/decode helpers
```

---

## Notes

- The bridge is two goroutines per session: one for client->agent (stdin) and one for agent->client (stdout/stderr/exit). Both must be started and properly cleaned up.
- Use `gorilla/websocket` for the agent WebSocket client connection. Set reasonable timeouts: write deadline, pong wait, close handshake.
- Attach-before-start: when the container is created but not started, there is no agent address. The frontend should register a "pending attach" callback on the container state. When `ContainerStart` completes and populates the agent address, the callback fires and the bridge is established. Use a `sync.Cond` or channel for this coordination.
- For TTY mode (attach or exec with `Tty: true`), the multiplexed stream is NOT used. Instead, raw bytes flow in both directions without the 8-byte header. The frontend must check the attach/exec options to determine whether to frame or not.
- Base64 encoding adds ~33% overhead. For high-throughput streams, this is acceptable since the WebSocket is on the internal network (VPC). If performance is a concern, consider binary WebSocket frames in the future.
- The `agent_address` and `agent_token` are stored in the container's state by the backend during `ContainerStart`. The frontend reads these from `ContainerInspect`.
- Error handling for the attach-before-start case: if the container fails to start (exits immediately), the pending attach should be unblocked with an error, and the hijacked connection should be closed with the exit code.
