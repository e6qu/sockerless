# GCR-002: Cloud Run container operations

**Component:** GCR (Google Cloud Run backend)
**Phase:** 3
**Depends on:** GCR-001, AG-005
**Estimated effort:** XL

---

## Description

Implement `ContainerCreate`, `ContainerStart`, `ContainerInspect`, `ContainerList`, `ContainerStop`, `ContainerKill`, `ContainerRemove`, and `ContainerWait` for the Cloud Run backend. Container create builds a Cloud Run Job spec from the container config (image, env, cmd, resource limits, volumes, network). Container start calls `RunJob` (or `CreateExecution`), polls until the execution reaches RUNNING state, resolves the agent address from Cloud Run's internal URL, and verifies agent readiness before returning. The start call MUST block until the container is actually running -- this is critical because CI runners check container status immediately after start.

---

## Context

### Cloud Run container mapping (Spec Section 9.1)

> | Docker Concept | Cloud Run Mapping |
> |---|---|
> | Container create + start | `CreateJob` + `RunJob` (or `CreateExecution`) |
> | Container stop | `CancelExecution` |
> | Container logs | Cloud Logging (`entries.list`) |
> | Exec / Attach | Via sockerless-agent (agent on Cloud Run's ingress port) |

### Near-instant container start (Spec Section 13.3, Gap 2)

> **Problem:** After `docker start`, the runner immediately runs `docker ps --filter status=running` to verify the container started. Docker containers start in <1s. Cloud backends take 5-60s.
>
> **Solution:** The `POST /containers/{id}/start` endpoint MUST block until the cloud task is actually running (agent is reachable). Only then return `204 No Content`. This way, the subsequent `docker ps` check sees "running" status.

### Agent injection (Spec Section 8.6)

> The backend modifies the container's entrypoint to: `["/sockerless-agent", "--", <original-entrypoint>]`
>
> The agent starts the original command as a child process and serves WebSocket connections for exec/attach.
>
> For Cloud Run, the recommended injection method is **Image layer**: the backend builds (or references) a wrapper image with the agent included, since Cloud Run does not support volume mounts at startup time.

### Agent readiness (Spec Section 13.3, Gap 11)

> **Agent readiness check:** Backend polls `http://agent/health` (HTTP GET on the agent's ingress port). Agent responds with `200 OK` once its WebSocket server is accepting connections. Backend only returns `204` from start once this check passes.

### Cloud Run status mapping

> | Cloud Run Execution State | Docker Container State |
> |---|---|
> | RUNNING | running |
> | SUCCEEDED | exited (exit code 0) |
> | FAILED | exited (exit code non-zero) |
> | CANCELLED | exited (exit code 137 -- SIGKILL equivalent) |
> | PENDING / not yet started | created |

---

## Acceptance Criteria

1. `ContainerCreate` accepts a `ContainerCreateRequest` and creates a Cloud Run Job via `CreateJob` (or prepares the job spec for deferred creation).
2. The job spec maps: `Image` -> container image, `Env` -> environment variables, `Cmd` -> command/args, `Entrypoint` -> container command.
3. CPU and memory are mapped from Docker's resource limits: `HostConfig.NanoCPUs` / `HostConfig.CpuShares` -> Cloud Run CPU (e.g., "1", "2", "4"), `HostConfig.Memory` -> Cloud Run memory (e.g., "512Mi", "1Gi", "2Gi"). Defaults: 1 CPU, 512Mi memory.
4. The job spec includes the configured VPC connector for networking (if set) and the `PORT` environment variable set to the agent port.
5. The agent is injected into the container: the entrypoint is modified to `["/sockerless-agent", "--", <original-entrypoint>, <original-cmd>...]` or `["/sockerless-agent", "--keep-alive", "--"]` for tail-f-dev-null containers. Agent env vars (`SOCKERLESS_AGENT_PORT`, `SOCKERLESS_AGENT_TOKEN`) are added.
6. A unique agent token is generated (32 random bytes, hex-encoded) and stored in the state for later retrieval by the frontend.
7. The container is stored in the state with status `"created"` and a generated 64-char hex ID. The state includes the job name, agent token, and all original config.
8. `ContainerCreate` returns `ContainerCreateResponse` with the generated ID and any warnings.
9. `ContainerStart` creates a new execution for the job via `RunJob` or `CreateExecution`.
10. `ContainerStart` polls the execution status at 2-second intervals until the execution is RUNNING. Maximum wait: 5 minutes (configurable). If the execution fails to start (status FAILED), return an error with the failure reason.
11. Once the execution is RUNNING, the backend resolves the agent address from Cloud Run's internal URL (the execution's URI or a pre-configured service URL).
12. The backend polls `http://<agent-address>/health` until the agent responds with `200 OK`. Timeout: 60 seconds. Poll interval: 1 second.
13. Only after the agent is confirmed ready does `ContainerStart` return success (204).
14. Container state is updated to `"running"` with `StartedAt` timestamp.
15. `ContainerInspect` returns full container metadata by combining local state with execution status from `GetExecution`. Cloud Run execution states are mapped to Docker container states per the mapping table above.
16. `ContainerList` returns all containers matching the provided filters (label, id, name, status) by querying local state. The `all` flag controls whether stopped containers are included.
17. `ContainerStop` calls `CancelExecution` to cancel the running execution. Timeout parameter is accepted but Cloud Run does not support graceful stop periods -- cancellation is immediate.
18. `ContainerKill` also calls `CancelExecution` (Cloud Run has no signal differentiation). The signal parameter is accepted but only logged.
19. `ContainerRemove` deletes the Cloud Run Job via `DeleteJob` and removes the container from local state. Force flag allows removing running containers (cancel first, then delete).
20. `ContainerWait` long-polls until the execution reaches a terminal state (SUCCEEDED, FAILED, or CANCELLED) and returns the exit code.
21. Labels from the container create request are applied as Cloud Run Job labels.

### Example SDK Calls

```go
// CreateJob
runClient.CreateJob(ctx, &runpb.CreateJobRequest{
    Parent: "projects/PROJECT/locations/REGION",
    JobId:  "sockerless-" + containerID[:12],
    Job: &runpb.Job{
        Template: &runpb.ExecutionTemplate{
            Template: &runpb.TaskTemplate{
                Containers: []*runpb.Container{{
                    Image:   image,
                    Command: entrypoint,
                    Args:    cmd,
                    Env:     envVars,
                    Resources: &runpb.ResourceRequirements{
                        Limits: map[string]string{
                            "cpu":    "1",
                            "memory": "512Mi",
                        },
                    },
                    Ports: []*runpb.ContainerPort{{
                        ContainerPort: 9111,
                    }},
                }},
            },
        },
        Labels: labels,
    },
})

// RunJob (creates a new execution)
runClient.RunJob(ctx, &runpb.RunJobRequest{
    Name: jobName,
})

// GetExecution (polling)
runClient.GetExecution(ctx, &runpb.GetExecutionRequest{
    Name: executionName,
})
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests with mock GCP clients for: job creation, execution creation, execution status polling (running, succeeded, failed, cancelled, timeout), agent address resolution, agent readiness polling, agent token generation, tail-f-dev-null detection and keep-alive flag
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] GCP API errors mapped to Docker-compatible error responses
- [ ] Execution startup failures include Cloud Run failure reason in error message
- [ ] Agent unreachable after execution RUNNING produces clear error
- [ ] Errors wrapped with context: `fmt.Errorf("cloudrun: container start: %w", err)`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated with container lifecycle details

### Integration
- [ ] State store updated correctly for each lifecycle transition
- [ ] Agent injection compatible with AG-005 (keep-alive) and AG-002/AG-003 (exec/attach)
- [ ] Job labels include sockerless container ID for later lookup
- [ ] Cloud Run execution states correctly mapped to Docker container states

---

## Suggested File Paths

```
backends/cloudrun/
├── container_create.go         # ContainerCreate: job creation, state management
├── container_start.go          # ContainerStart: RunJob, polling, agent readiness
├── container_inspect.go        # ContainerInspect: merge state + execution status
├── container_list.go           # ContainerList: filter and return containers
├── container_lifecycle.go      # Stop, Kill, Remove, Wait operations
├── jobspec.go                  # Job spec builder (maps Docker config -> Cloud Run job)
├── agent_inject.go             # Agent entrypoint modification, token generation
├── status.go                   # Cloud Run state -> Docker state mapping
├── store.go                    # (update) Container state with job name, agent address, agent token
└── errors.go                   # (update) Cloud Run-specific error mapping
```

---

## Notes

- Cloud Run Jobs v2 API uses `CreateJob` to define a job and `RunJob` to create an execution. Each execution runs the job's container spec once. This maps well to Docker's create/start split.
- Cloud Run resource mappings: CPU can be fractional (e.g., "0.25", "1", "2", "4"), memory is a string like "256Mi", "512Mi", "1Gi", "2Gi", "4Gi". Use the closest valid value that meets or exceeds the Docker request.
- Agent networking on Cloud Run is fundamentally different from ECS. Cloud Run containers receive traffic on the `PORT` env var port. The agent must listen on this port. The frontend reaches the agent via the Cloud Run execution's URI (HTTPS). This means agent communication goes through Cloud Run's ingress, not a direct IP connection.
- For the agent binary injection, Cloud Run does not support volume mounts at container startup time (unlike ECS with EFS). The recommended approach is to build a wrapper image that includes the agent binary, or use a startup command that downloads the agent. The image layer approach is documented in Spec Section 8.6.
- The tail-f-dev-null detection: check if `Entrypoint == ["tail"]` and `Cmd == ["-f", "/dev/null"]`. Also check variations like `Entrypoint == ["tail", "-f", "/dev/null"]` with empty Cmd.
- Cloud Run Jobs have a maximum execution time of 24 hours (86400 seconds). Executions that exceed this are terminated.
- Consider implementing eager container provisioning: when `ContainerCreate` is called, begin creating the Cloud Run Job immediately (not waiting for `ContainerStart`). This reduces the perceived startup latency since `CreateJob` takes a few seconds.
