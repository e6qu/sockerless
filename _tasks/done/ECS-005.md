# ECS-005: Agent injection and address resolution

**Component:** ECS (AWS ECS Fargate backend)
**Phase:** 2
**Depends on:** ECS-002, AG-001
**Estimated effort:** M

---

## Description

Implement the full agent injection and address resolution strategy for the ECS backend. While ECS-002 establishes the basic entrypoint modification, this task handles the mechanism for getting the agent binary into the container (via EFS volume mount or init container), robust ENI IP resolution for agent connectivity, agent health check polling, and fallback strategies when the agent is unreachable. This task ensures that the frontend can reliably connect to the agent inside any Fargate task for exec and attach operations.

---

## Context

### Agent injection methods (Spec Section 8.6)

> The backend is responsible for injecting the agent into cloud containers:
>
> | Method | Description | Best For |
> |---|---|---|
> | **Volume mount** | Mount agent binary from cloud storage (EFS, GCS, Azure Files) and prepend to entrypoint | ECS, ACA |
> | **Init container** | Run init container that copies agent binary to shared volume | ECS, ACA |
> | **Image layer** | Backend builds a wrapper image with agent included | Cloud Run (no volume mount at startup) |
> | **Not needed** | Backend has native exec (Docker backend) | Docker, Memory |
>
> The backend modifies the container's entrypoint to: `["/sockerless-agent", "--", <original-entrypoint>]`
>
> The agent starts the original command as a child process and serves WebSocket connections for exec/attach.

### Agent networking (Spec Section 9.1)

> **Agent networking:** Fargate tasks get private IPs in the configured VPC. The frontend must be able to reach these IPs (same VPC, VPC peering, or transit gateway). Agent listens on port 9111 -- security group must allow inbound from frontend.

### Agent authentication (Spec Section 8.2)

> The backend generates a one-time token when launching the cloud task. This token is:
> 1. Injected into the container as env var `SOCKERLESS_AGENT_TOKEN`
> 2. Returned to the frontend as part of the container's inspect data
>
> When the frontend connects to the agent, it presents the token in the `Authorization: Bearer <token>` header. The agent validates the token and rejects unauthorized connections.

### Agent readiness (Spec Section 13.3, Gap 11)

> **Agent readiness check:** Backend polls `ws://agent:9111/health` (a simple HTTP GET on the same port). Agent responds with `200 OK` once its WebSocket server is accepting connections. Backend only returns `204` from start once this check passes.

### Agent configuration (Spec Section 15.4)

> The agent is configured entirely via environment variables (injected by the backend):
>
> | Env Var | Description |
> |---------|-------------|
> | `SOCKERLESS_AGENT_PORT` | Port to listen on (default: `9111`) |
> | `SOCKERLESS_AGENT_TOKEN` | Auth token for validating frontend connections |
> | `SOCKERLESS_ORIGINAL_ENTRYPOINT` | Original container entrypoint (agent runs this as child) |
> | `SOCKERLESS_ORIGINAL_CMD` | Original container CMD |

### Agent address in internal API (Spec Section 7.5)

> When the backend starts a container, it provisions the agent and records the agent's address. The container inspect response includes an `agent_address` field:
> ```json
> {
>   "id": "abc123...",
>   "agent_address": "10.0.1.47:9111",
>   "status": "running",
>   "...": "..."
> }
> ```
>
> The frontend reads this address when it needs to connect to the agent for exec/attach operations.

---

## Acceptance Criteria

### Agent binary injection via EFS
1. The ECS backend supports injecting the agent binary via an EFS volume mount. The agent binary is pre-staged on the configured EFS filesystem at a well-known path (e.g., `/sockerless/bin/sockerless-agent`).
2. When `efs_filesystem_id` is configured, the task definition includes an EFS volume mounting the agent binary directory, and a bind mount makes it available at `/sockerless-agent` inside the container.
3. The EFS volume mount uses an access point with read-only access to the agent binary directory.

### Agent binary injection via init container (alternative)
4. As an alternative to EFS, the backend supports an init container strategy: a small init container copies the agent binary from a known image (e.g., `sockerless/agent:latest`) to a shared ephemeral volume, which the main container then mounts.
5. When using init containers, the task definition has two containers: `init` (essential=false, runs first) and `main` (essential=true, depends on init container success).
6. The injection strategy is configurable via backend config (default: `efs` if `efs_filesystem_id` is set, otherwise `init-container`).

### Entrypoint modification
7. The container entrypoint is modified to `["/sockerless-agent", "--", <original-entrypoint>, <original-cmd>...]`. The original entrypoint and cmd are preserved in the container state for inspect responses.
8. For tail-f-dev-null containers (detected by ECS-002), the entrypoint is `["/sockerless-agent", "--keep-alive", "--"]`.
9. Agent environment variables are injected: `SOCKERLESS_AGENT_PORT` (default `9111`), `SOCKERLESS_AGENT_TOKEN` (unique per container), `SOCKERLESS_ORIGINAL_ENTRYPOINT`, `SOCKERLESS_ORIGINAL_CMD`.

### ENI IP resolution
10. After `RunTask` returns and the task reaches `RUNNING` state, the backend extracts the ENI private IP from the task's `attachments` array. The attachment with `type: "ElasticNetworkInterface"` contains a `details` array with key-value pairs; the key `"privateIPv4Address"` holds the IP.
11. If the task has multiple ENIs (future multi-network support), the primary ENI IP is used for agent connectivity.
12. The resolved agent address (`<ip>:9111`) is stored in the container state and returned in internal API inspect responses.

### Agent health checks
13. After resolving the agent address, the backend polls `GET http://<agent-address>/health` at 1-second intervals until the agent responds with `200 OK`.
14. The health check timeout is configurable (default 60 seconds). If the agent does not become healthy within this timeout, `ContainerStart` returns an error with a descriptive message including the agent address and timeout.
15. The health check uses a dedicated HTTP client with a 2-second per-request timeout, connection keep-alive disabled, and no TLS (agent communication is within the VPC).

### Error handling
16. If ENI IP extraction fails (no attachment, no `privateIPv4Address` key), return an error with the full `DescribeTasks` attachment data for debugging.
17. If the agent never becomes reachable, the error message includes: agent address, timeout duration, last connection error, and a suggestion to check security group rules (port 9111 inbound).
18. If the EFS filesystem is not accessible or the agent binary is missing, the task will fail to start -- the ECS stop reason is included in the error returned by `ContainerStart`.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] Unit tests with mock AWS clients for: EFS volume mount task definition generation, init container task definition generation, entrypoint modification (regular and keep-alive), ENI IP extraction (single ENI, missing ENI, multiple ENIs), agent health check polling (immediate success, delayed success, timeout failure)
- [ ] Tests for agent token generation (uniqueness, correct length, hex encoding)
- [ ] Tests for injection strategy selection (EFS when configured, init-container fallback)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] ENI extraction failure produces clear diagnostic error
- [ ] Agent health timeout includes actionable suggestion
- [ ] EFS mount failure surfaced with ECS stop reason
- [ ] Errors wrapped with context: `fmt.Errorf("ecs: agent injection: %w", err)`
- [ ] Zerolog structured logging with container ID, agent address, health check status

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] README updated with agent injection prerequisites (EFS setup, agent binary staging, security group rules)

### Integration
- [ ] Agent address available in container inspect for frontend exec/attach operations
- [ ] Compatible with AG-001 WebSocket server (token auth, health endpoint)
- [ ] Task definition compatible with both EFS and init-container injection strategies
- [ ] Entrypoint modification compatible with AG-005 keep-alive mode

---

## Suggested File Paths

```
backends/ecs/
├── agent_inject.go             # Agent binary injection (EFS mount, init container)
├── agent_health.go             # Agent health check polling, readiness verification
├── eni.go                      # ENI IP extraction from DescribeTasks attachments
├── taskdef.go                  # (update) Task definition with EFS volumes, init containers
├── config.go                   # (update) Agent injection strategy config
└── store.go                    # (update) Agent address, token stored in container state
```

---

## Notes

- The EFS approach is preferred for production because it avoids an extra container launch (init container adds startup latency). Pre-stage the agent binary on EFS once, and all tasks mount it read-only.
- For the EFS approach, the agent binary must be uploaded to the EFS filesystem before the backend is used. This is a deployment prerequisite, not a runtime concern. Document the setup steps (mount EFS, copy binary, set permissions).
- The init container approach is useful for development and environments without EFS. The init container image should be as small as possible (scratch + static Go binary).
- ENI IP extraction: the `DescribeTasks` response `attachments` field has this structure: `[{Type: "ElasticNetworkInterface", Details: [{Name: "privateIPv4Address", Value: "10.0.1.47"}, ...]}]`. Use the `details` key-value pairs, not the attachment `id` or `status`.
- Security groups: the task's security group must allow inbound TCP on port 9111 from the frontend's security group or CIDR. This is a deployment-time configuration, but the error message should suggest checking it when health checks fail.
- Consider caching the HTTP client used for health checks to avoid creating a new client for each poll iteration. However, do not reuse connections across different containers.
- The agent token should be cryptographically random (use `crypto/rand`, not `math/rand`).
