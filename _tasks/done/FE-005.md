# FE-005: POST /containers/{id}/start

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** FE-004
**Estimated effort:** M

---

## Description

Implement the `POST /containers/{id}/start` endpoint. This endpoint delegates to the backend to launch a container that was previously created via `POST /containers/create`. The backend translates the stored container configuration into a cloud task/job, launches it, and updates the container state to "running". The frontend returns `204 No Content` on success.

## Context

### Container Start (spec Section 4.3)

**Sockerless behavior:**
1. Translate the stored container configuration into a cloud backend task/job:
   - Image -> cloud task definition / job spec
   - Env -> cloud task environment variables
   - Cmd/Entrypoint -> cloud task command
   - Resource limits -> cloud task resource allocation
   - Network -> cloud VPC / network configuration
   - Volume binds -> cloud storage mounts
2. Launch the cloud backend task
3. Start the exec/attach agent inside the container (see Agent Protocol)
4. Update container state to `Running`

Response: `204 No Content` (same as Docker)

### Internal API (spec Section 7.3)

Frontend sends: `POST /internal/v1/containers/{id}/start`

### Gap 2: Near-Instant Container Start (spec Section 13.3)

**Problem:** After `docker start`, GitHub Actions Runner immediately runs `docker ps --filter status=running` to verify the container started. Docker containers start in <1s. Cloud backends take 5-60s.

**Solution:** The `POST /containers/{id}/start` endpoint MUST block until the cloud task is actually running (agent is reachable). Only then return `204 No Content`. This way, the subsequent `docker ps` check sees "running" status. The trade-off is that `docker start` takes 5-60s instead of <1s, but the runner doesn't have a timeout on the start call itself -- only the overall job timeout applies.

**Implementation:** Backend launches cloud task -> polls cloud API for task status -> returns 204 only when task is in "RUNNING" state. Frontend forwards the 204 to the Docker client.

### Gap 11: Exec Reliability (spec Section 13.3)

The agent starts its WebSocket server as the first thing on startup. The backend waits for agent readiness (health probe to agent's WebSocket endpoint) before returning from `POST /containers/{id}/start`. By the time the runner calls `docker exec`, the agent is guaranteed to be listening.

## Acceptance Criteria

1. `POST /containers/{id}/start` returns `204 No Content` on success
2. Container state transitions from `"created"` to `"running"` after successful start
3. Returns `304 Not Modified` if the container is already running
4. Returns `404 Not Found` with `{"message": "No such container: <id>"}` if the container does not exist
5. After start, `GET /containers/{id}/json` shows `State.Status: "running"` and `State.Running: true`
6. After start, `GET /containers/json` (without `all=true`) includes the container
7. The endpoint blocks until the backend confirms the container is running (critical for cloud backends)
8. `State.StartedAt` is set to the current timestamp on successful start
9. Short container ID prefix matching works (e.g., first 12 chars of the full 64-char ID)
10. Container name matching works (e.g., `POST /containers/myname/start`)

### Example Requests

```bash
# Start a created container (by ID)
curl -s -o /dev/null -w "%{http_code}" --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/a1b2c3d4e5f6/start"
# 204

# Start again (already running)
curl -s -i --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/a1b2c3d4e5f6/start"
# HTTP/1.1 304 Not Modified

# Start by name
curl -s -o /dev/null -w "%{http_code}" --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/mycontainer/start"
# 204

# Container not found
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/nonexistent/start"
# 404 {"message":"No such container: nonexistent"}

# Verify running state after start
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/json" | jq '.State'
# {
#   "Status": "running",
#   "Running": true,
#   "Pid": 1,
#   "ExitCode": 0,
#   "StartedAt": "2026-02-15T12:00:01Z",
#   "FinishedAt": "0001-01-01T00:00:00Z"
# }
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Blocking behavior verified: start does not return until container is running
- [ ] 304 response for already-started containers
- [ ] State transition from "created" to "running" verified via inspect

## Suggested File Paths

```
frontends/docker/
├── handler_container_start.go    # POST /containers/{id}/start handler
└── resolve.go                    # Container ID/name resolution helper (shared by all container endpoints)
```

## Notes

- The `{id}` path parameter can be a full 64-char hex ID, a short prefix (minimum 1 char, typically 12), or a container name. The resolution logic should try exact ID match first, then prefix match, then name match. If ambiguous (prefix matches multiple), return an error.
- The `304 Not Modified` response has no body. Docker clients treat this as "container already started, not an error."
- For the memory backend, start is effectively instant. For cloud backends (ECS, Cloud Run, etc.), start blocks for 5-60 seconds. The frontend must not timeout the internal API call prematurely -- use a long timeout or no timeout (let the client's context control it).
- The request body for start is typically empty (Docker has a deprecated `HostConfig` parameter in the body that is ignored since API v1.24). Accept and ignore any request body.
- Consider adding a `X-Sockerless-Start-Duration` response header (non-standard) for debugging startup latency on cloud backends.
