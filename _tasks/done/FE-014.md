# FE-014: Image pull

**Component:** FE (Docker REST API frontend)
**Phase:** 1
**Depends on:** FE-001, MEM-004
**Estimated effort:** M

---

## Description

Implement the image pull endpoint (`POST /images/create`). In Sockerless, pulling an image does NOT download layers locally. Instead, the frontend records the image reference in the backend's state store and optionally validates that the image exists in the registry via a HEAD request. The response is a streaming JSON progress output that mimics Docker's pull progress format, but the progress can be synthetic (immediate "Pull complete") since no actual download occurs locally. The cloud backend will pull the image when a container is created and started.

Both GitLab Runner and GitHub Actions Runner use this endpoint. GitHub Runner retries pull up to 3 times.

---

## Context

### Image pull endpoint (Spec Section 4.2)

> `POST /images/create` -- Pull Image
>
> Query parameters:
> - `fromImage` (required): Image reference (e.g., `docker.io/library/nginx:latest`)
> - `tag`: Tag (often included in `fromImage`)
> - `platform`: OS/arch (e.g., `linux/amd64`)
>
> Headers:
> - `X-Registry-Auth`: Base64-encoded JSON credentials (`{"username":"...","password":"...","serveraddress":"..."}`)
>
> **Response:** Streaming JSON (one JSON object per line), Docker pull progress format:
> ```json
> {"status":"Pulling from library/nginx","id":"latest"}
> {"status":"Pulling fs layer","progressDetail":{},"id":"abc123"}
> {"status":"Download complete","progressDetail":{},"id":"abc123"}
> {"status":"Pull complete","progressDetail":{},"id":"abc123"}
> {"status":"Digest: sha256:..."}
> {"status":"Status: Downloaded newer image for nginx:latest"}
> ```

### Sockerless pull behavior (Spec Section 4.2)

> **Sockerless behavior:**
> - Records the image reference in the internal state store
> - Does NOT actually pull the image locally -- the cloud backend will pull it when a container is created
> - Validates that the image exists in the registry (HEAD request to registry API) if credentials are provided
> - The progress output can be synthetic (immediate "Pull complete") since no actual download occurs locally

### Image config fetch for PATH extraction (Spec Section 13.3, Gap 3)

> When `POST /images/create` (pull) is called, the backend fetches the image's manifest and config blob from the registry API WITHOUT downloading any layers. The image config contains `Env`, `Cmd`, `Entrypoint`, `ExposedPorts`, `WorkingDir`, `Labels`, and `Healthcheck`. These are stored in the backend's image table and returned in both `GET /images/{name}/json` and merged into `GET /containers/{id}/json` -> `Config.Env`.
>
> **Registry API calls needed:** `GET /v2/<name>/manifests/<tag>` -> `GET /v2/<name>/blobs/<config-digest>`. These are lightweight (config blob is typically <10KB). Authentication uses the credentials from `X-Registry-Auth` or `POST /auth`.

### GitHub Runner pull retries (Spec Section 13.2.2)

> ```
> 3. Image Pull (with retries, 3 attempts)
>    docker pull <job-image>
>    docker pull <service-image>  # for each service
> ```

### GitLab Runner pull (Spec Section 13.1.2)

> ```
> 2. Image Pull Phase
>    ImageInspectWithRaw(helperImage)           # check if helper exists locally
>    ImageLoad(helperTar) -> ImageTag(id, ref)  # or: load from embedded tar
>    ImagePullBlocking(buildImage)              # pull build image
>    ImagePullBlocking(serviceImage)            # pull each service image
> ```

---

## Acceptance Criteria

1. `POST /images/create` accepts query parameters `fromImage` (required), `tag` (optional), and `platform` (optional).
2. The `X-Registry-Auth` header is decoded from base64 and parsed as JSON credentials (`username`, `password`, `serveraddress`).
3. The response uses chunked transfer encoding with `Content-Type: application/json`.
4. The response body is a stream of newline-delimited JSON objects matching Docker's pull progress format.
5. The final status line includes `"Status: Downloaded newer image for <image>:<tag>"` or `"Status: Image is up to date for <image>:<tag>"`.
6. The image reference is stored in the backend's image state after a successful pull.
7. If the image already exists in the state store, the pull succeeds and returns `"Status: Image is up to date"`.
8. If registry validation is enabled and the image does not exist, return an error status in the JSON stream: `{"error":"manifest unknown","errorDetail":{"message":"manifest unknown"}}`.
9. After a successful pull, the image appears in `GET /images/{name}/json` (FE-015).
10. The image's config metadata (Env, Cmd, Entrypoint, ExposedPorts, WorkingDir, Labels, Healthcheck) is fetched from the registry and stored alongside the image reference.
11. Credentials from `X-Registry-Auth` are stored for use by the backend when actually pulling the image at container start time.
12. Pulling `docker.io/library/nginx:latest` and `nginx:latest` and `nginx` all resolve to the same image (Docker Hub default registry and tag normalization).
13. The endpoint returns `200 OK` (not 201) with the streaming body, matching Docker's behavior.

### Example Requests

```bash
# Pull an image from Docker Hub (no auth)
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/create?fromImage=nginx&tag=latest"
# Response: 200 OK (streaming JSON)
# {"status":"Pulling from library/nginx","id":"latest"}
# {"status":"Pulling fs layer","progressDetail":{},"id":"a1b2c3d4e5f6"}
# {"status":"Pull complete","progressDetail":{},"id":"a1b2c3d4e5f6"}
# {"status":"Digest: sha256:abc123..."}
# {"status":"Status: Downloaded newer image for nginx:latest"}

# Pull with registry auth
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "X-Registry-Auth: $(echo -n '{"username":"user","password":"pass","serveraddress":"https://registry.example.com"}' | base64)" \
  "http://localhost/v1.44/images/create?fromImage=registry.example.com/myapp&tag=v1.0"
# Response: 200 OK (streaming JSON)
# {"status":"Pulling from myapp","id":"v1.0"}
# {"status":"Pull complete","progressDetail":{},"id":"..."}
# {"status":"Status: Downloaded newer image for registry.example.com/myapp:v1.0"}

# Pull with platform specification
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/create?fromImage=alpine&tag=3.19&platform=linux/amd64"
# Response: 200 OK (streaming JSON)

# Pull an image that does not exist
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/create?fromImage=nonexistent/image&tag=v999"
# Response: 200 OK (streaming JSON with error)
# {"error":"manifest unknown","errorDetail":{"message":"manifest unknown"}}

# Re-pull an already-pulled image
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/create?fromImage=nginx&tag=latest"
# Response: 200 OK
# {"status":"Pulling from library/nginx","id":"latest"}
# {"status":"Status: Image is up to date for nginx:latest"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for: pull success, re-pull (already exists), streaming response format verification, X-Registry-Auth header parsing, image reference normalization (short names, default tag)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors
- [ ] Errors wrapped with context: `fmt.Errorf("image pull: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] Pull errors reported in the streaming JSON body, not as HTTP error codes (matching Docker's behavior)

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated if new public API is added

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Image state is accessible to FE-015 (inspect), FE-004 (container create image validation)
- [ ] Stored credentials are accessible to the backend for container start

---

## Suggested File Paths

```
frontends/docker/
├── handler_image_pull.go     # POST /images/create handler
├── registry.go               # Registry reference normalization, auth header parsing
└── routes.go                 # Register new route (update existing)
```

---

## Notes

- Docker's `POST /images/create` always returns `200 OK` with a streaming body, even when the pull fails. Errors are embedded in the JSON stream as `{"error":"...", "errorDetail": {"message":"..."}}`. Do NOT return 404 or 500 as HTTP status codes for pull failures.
- The `fromImage` query parameter may include the tag (e.g., `nginx:latest`). When both `fromImage` contains a tag and the `tag` parameter is specified, the explicit `tag` parameter takes precedence.
- Image reference normalization rules: `nginx` -> `docker.io/library/nginx:latest`, `myuser/myapp` -> `docker.io/myuser/myapp:latest`, `registry.example.com/myapp:v1` -> `registry.example.com/myapp:v1`.
- The memory backend simulates pull by recording the image reference and generating a synthetic SHA256 digest. It does not contact any registry.
- For cloud backends, the registry config fetch (`GET /v2/<name>/manifests/<tag>` -> config blob) should happen during pull so that `GET /images/{name}/json` can return accurate image config. This is critical for GitHub Runner's PATH extraction.
- The streaming response must flush each JSON line immediately (not buffer the entire response). Use `http.Flusher` interface.
- An empty `X-Registry-Auth` header or a header containing `{}` (empty JSON) should be treated as unauthenticated (no error).
