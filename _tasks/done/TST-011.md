# TST-011: GitLab Runner end-to-end

**Component:** Test Infrastructure and Suites
**Phase:** 2
**Depends on:** FE-021, ECS-005, TST-010
**Estimated effort:** XL

---

## Description

End-to-end tests that validate the complete GitLab Runner docker-executor flow against the Sockerless frontend backed by ECS Fargate. Tests simulate the exact API call sequence GitLab Runner makes during a CI job: image pull, network and volume setup, helper container (git clone + artifacts), build container (script execution via attach), service containers (with health probes), and cleanup. This is the highest-fidelity test in the project -- it proves Sockerless can replace Docker for GitLab CI workloads.

---

## Context

### GitLab Runner job lifecycle (Spec Section 13.1.2)

The exact sequence of Docker API calls GitLab Runner makes during a CI job:

```
1. API Version Negotiation
   GET /_ping -> reads API-Version header

2. Image Pull Phase
   ImageInspectWithRaw(helperImage)           # check if helper exists
   ImageLoad(helperTar) -> ImageTag(id, ref)  # or: load from embedded tar
   ImagePullBlocking(buildImage)              # pull build image
   ImagePullBlocking(serviceImage)            # pull each service image

3. Network Setup
   NetworkCreate("runner-net-<guid>")         # per-build network

4. Volume Setup
   VolumeCreate("runner-<hash>-cache-<hash>") # cache volume
   VolumeCreate("runner-<hash>-build-<hash>") # build dir volume

5. Service Containers
   For each service:
     ContainerCreate(serviceImage, network, volumes, aliases)
     ContainerStart(serviceID)
     ContainerInspect(serviceID)              # poll until not "created"

6. Build Container
   ContainerCreate(buildImage, cmd=[shell], network, volumes, stdin=true)
   ContainerAttach(buildID, stdin=true, stdout=true, stderr=true)  # BEFORE START
   ContainerStart(buildID)
   # Stdin: pipe build script via multiplexed stream
   # Stdout/Stderr: read via multiplexed stream (stdcopy.StdCopy)
   ContainerWait(buildID, condition="not-running")

7. Helper Container (git clone, artifacts, cache)
   ContainerCreate(helperImage, cmd=["gitlab-runner-build"], network, SAME volumes)
   ContainerAttach(helperID, ...)             # BEFORE START
   ContainerStart(helperID)
   ContainerWait(helperID, ...)

8. Cleanup (parallel, 5-minute timeout)
   ContainerKill(id, "SIGTERM")
   ContainerStop(id, timeout=0)
   NetworkDisconnect(networkID, id, force=true)
   ContainerRemove(id, force=true, removeVolumes=true)
   NetworkRemove(networkID)
   VolumeRemove(volumeID)
```

### Attach-before-start pattern (Spec Section 13.1.3)

GitLab Runner calls `ContainerAttach()` BEFORE `ContainerStart()`. The frontend must return the hijacked connection immediately and buffer until the agent is reachable. The runner pipes the build script through the attach stdin connection. The container's `Cmd` is set to the shell, and the script is streamed as stdin. **Attach is the primary execution mechanism**, not exec.

### Frontend WebSocket bridge (FE-021)

The frontend bridges hijacked Docker connections to the agent's WebSocket connection. It translates between Docker's multiplexed stream protocol (8-byte header framing) and the agent's WebSocket JSON messages.

### Volume sharing (Spec Section 13.1.3)

ALL containers in the job (helper, build, services) get the same `Binds` list. Named volumes for `/builds/<namespace>/<project>` and `/cache` are shared between containers so the helper can clone the repo and the build container can read it.

### Service readiness (Spec Section 13.1.3)

The runner does NOT use Docker's built-in HEALTHCHECK. It creates a separate health-check container using the helper image running `["gitlab-runner-helper", "health-check"]` which TCP-probes the service's exposed ports. It polls `ContainerInspect` until `State.Status` is no longer `"created"`.

### Network aliases (Spec Section 13.1.3)

With `FF_NETWORK_PER_BUILD`, the runner creates a per-build user-defined network. Service aliases (e.g., `["postgres", "db"]`) are set via `NetworkingConfig.EndpointsConfig[networkName].Aliases`. Cloud DNS (Cloud Map for ECS) resolves these aliases within the network.

### Recommended GitLab Runner config for Sockerless (Spec Section 13.1.4)

```toml
[runners.docker]
  host = "unix:///var/run/sockerless.sock"
  helper_image = "registry.example.com/sockerless/gitlab-runner-helper:latest"
  pull_policy = "always"
  wait_for_services_timeout = 120

[runners.feature_flags]
  FF_NETWORK_PER_BUILD = true
```

---

## Acceptance Criteria

### Version negotiation

1. `GET /_ping` returns `API-Version: 1.44` header. Sockerless responds without contacting any backend.

### Image operations

2. `POST /images/create?fromImage=alpine&tag=latest` succeeds and streams JSON progress messages.
3. `GET /images/alpine:latest/json` returns image metadata including `Config.Env`, `Config.Cmd`, and `Config.Entrypoint`.

### Network and volume setup

4. `POST /networks/create` with `Name: "runner-net-<guid>"` and labels returns `201` with a valid network ID.
5. `POST /volumes/create` with `Name: "runner-<hash>-build"` returns `201` with the volume metadata.

### Service container

6. `POST /containers/create` with a service image (e.g., `postgres:16-alpine`), network aliases `["postgres", "db"]`, and the shared volumes returns `201`.
7. `POST /containers/{id}/start` for the service container returns `204`.
8. `GET /containers/{id}/json` for the service container returns `State.Status: "running"` and `NetworkSettings.Networks` includes the runner network with the specified aliases.

### Build container with attach-before-start

9. `POST /containers/create` with `Image: "alpine:latest"`, `Cmd: ["sh"]`, `OpenStdin: true`, `AttachStdin: true`, `AttachStdout: true`, `AttachStderr: true`, the runner network, and shared volumes returns `201`.
10. `POST /containers/{id}/attach?stdin=true&stdout=true&stderr=true&stream=true` returns `101 Switching Protocols` with a hijacked connection BEFORE the container is started.
11. `POST /containers/{id}/start` returns `204` and the attach stream becomes active (agent is reachable).
12. Writing a script to the attach stdin (e.g., `echo "build-output"\nexit 0\n`) produces `build-output` on the attach stdout stream.
13. `POST /containers/{id}/wait?condition=not-running` blocks until the container exits and returns `{"StatusCode": 0}`.

### Helper container

14. `POST /containers/create` with the helper image, the same network and same volumes as the build container, and `Cmd: ["sh", "-c", "echo helper-output"]` returns `201`.
15. The helper container attach-before-start flow works identically to the build container (AC 10-13) and produces `helper-output` on stdout.

### Cleanup sequence

16. `POST /containers/{id}/kill` with signal `SIGTERM` returns `204` for a running container.
17. `POST /networks/{id}/disconnect` with `Force: true` removes each container from the network.
18. `DELETE /containers/{id}?force=true&v=true` removes each container.
19. `DELETE /networks/{id}` removes the runner network.
20. `DELETE /volumes/{name}` removes the build and cache volumes.
21. After cleanup, `GET /containers/json?all=true` does not include any of the job's containers, and `GET /networks` does not include the runner network.

### Full flow integration

22. A single test executes the complete lifecycle (AC 1-21) in sequence, matching the exact API call order GitLab Runner uses, and all steps succeed.

### Example Requests

```bash
# 1. Version negotiation
curl --unix-socket /var/run/sockerless.sock \
  -I http://localhost/_ping
# Expected: API-Version: 1.44

# 2. Pull build image
curl --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/images/create?fromImage=alpine&tag=latest"

# 3. Create network
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/networks/create \
  -H "Content-Type: application/json" \
  -d '{"Name":"runner-net-test","Labels":{"com.gitlab.gitlab-runner.managed":"true"}}'

# 4. Create build container with attach-before-start
curl --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/containers/create?name=build-test" \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine:latest","Cmd":["sh"],"OpenStdin":true,"AttachStdin":true,"AttachStdout":true,"AttachStderr":true}'

# 5. Cleanup
curl --unix-socket /var/run/sockerless.sock \
  -X DELETE "http://localhost/containers/build-test?force=true&v=true"
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 22 acceptance criteria pass
- [ ] Full lifecycle test (AC 22) runs as a single sequential test function
- [ ] Tests are skipped when AWS credentials are absent (reuse `skipIfNoAWS` from TST-010)
- [ ] Cleanup runs via `t.Cleanup` even if mid-test assertions fail
- [ ] Attach-before-start tests use a real hijacked HTTP connection (not a mock)
- [ ] Multiplexed stream framing is validated for both stdin writes and stdout/stderr reads
- [ ] Total test timeout is 10 minutes to account for Fargate startup of multiple containers

---

## Suggested File Paths

```
tests/
├── gitlab_runner_e2e_test.go      # TestGitLabRunnerFullLifecycle,
│                                  # TestGitLabRunnerAttachBeforeStart,
│                                  # TestGitLabRunnerServiceContainer,
│                                  # TestGitLabRunnerCleanup
└── helpers/
    ├── ecs.go                     # (from TST-010) skipIfNoAWS, Fargate helpers
    ├── container.go               # (from TST-003) create/start/inspect/remove
    ├── exec.go                    # (from TST-005) exec create/start/inspect
    ├── network.go                 # (from TST-007) createNetwork, removeNetwork
    ├── volume.go                  # (from TST-008) createVolume, removeVolume
    ├── hijack.go                  # (from TST-004) HTTP connection hijacking
    ├── mux_stream.go              # (from TST-004) multiplexed stream encode/decode
    └── gitlab_runner.go           # simulateGitLabJob, buildContainerConfig, helperContainerConfig
```

---

## Notes

- This is the most complex test in the project. Start with a simplified flow (single build container, no services) and incrementally add service containers and volume sharing.
- The attach-before-start pattern is the most critical behavior. The test must call `POST /containers/{id}/attach` BEFORE `POST /containers/{id}/start`. Verify stdin writes are buffered and delivered once the agent connects.
- For the build script piping test, write `echo "build-output"\nexit 0\n` to stdin. Verify `build-output` on stdout and `ContainerWait` returns `StatusCode: 0`.
- Service container testing with `postgres:16-alpine` requires polling `ContainerInspect` until `State.Status != "created"`, then TCP-probing the service port.
- Volume sharing: create named volumes, bind to both helper and build containers, verify a file written by the helper is readable by the build container.
- Cleanup must match GitLab Runner's exact order: kill -> stop -> network disconnect -> container remove -> volume remove -> network remove.
- Use `-timeout 10m` and tag with `//go:build integration` to exclude from default `go test` runs.
