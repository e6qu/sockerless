# ECS-006: Image operations

**Component:** ECS (AWS ECS Fargate backend)
**Phase:** 2
**Depends on:** ECS-001
**Estimated effort:** M

---

## Description

Implement image operations for the ECS backend: pull, inspect, load, and tag. Unlike Docker, the ECS backend does not download image layers locally -- ECS Fargate pulls images natively from registries at task launch time. Instead, the ECS image operations focus on fetching image manifests and config blobs from container registries (ECR and Docker Hub) to extract metadata that CI runners require (Env, Cmd, Entrypoint, ExposedPorts, Healthcheck). This metadata is stored in the state and returned by image inspect and container inspect endpoints. The pull endpoint validates the image exists and streams synthetic progress output.

---

## Context

### Image operations in ECS (Spec Section 9.1)

> | Docker Concept | ECS Mapping |
> |---|---|
> | Image pull | ECS pulls from ECR / Docker Hub / any registry natively |

### Image pull behavior (Spec Section 4.2)

> **Sockerless behavior:**
> - Records the image reference in the internal state store
> - Does NOT actually pull the image locally -- the cloud backend will pull it when a container is created
> - Validates that the image exists in the registry (HEAD request to registry API) if credentials are provided
> - The progress output can be synthetic (immediate "Pull complete") since no actual download occurs locally

### Image config extraction (Spec Section 13.3, Gap 3)

> **Problem:** The runner reads `Config.Env` from `docker inspect` to extract the `PATH` environment variable. Sockerless doesn't pull images locally, so it doesn't have the image config.
>
> **Solution:** When `POST /images/create` (pull) is called, the backend fetches the image's manifest and config blob from the registry API WITHOUT downloading any layers. The image config contains `Env`, `Cmd`, `Entrypoint`, `ExposedPorts`, `WorkingDir`, `Labels`, and `Healthcheck`. These are stored in the backend's image table and returned in both `GET /images/{name}/json` and merged into `GET /containers/{id}/json` -> `Config.Env`.
>
> **Registry API calls needed:** `GET /v2/<name>/manifests/<tag>` -> `GET /v2/<name>/blobs/<config-digest>`. These are lightweight (config blob is typically <10KB). Authentication uses the credentials from `X-Registry-Auth` or `POST /auth`.

### GitLab Runner image usage (Spec Section 13.1.2)

> GitLab Runner reads `Config.Env` and `Config.Cmd` from image inspect. The runner tries three strategies in order: (1) `ImageInspectWithRaw` to check if image exists, (2) `ImageLoad` from embedded `.docker.tar.zst` file + `ImageTag`, (3) `ImagePullBlocking` from registry.

### GitHub Actions Runner image usage (Spec Section 13.2)

> The runner reads `Config.Env` from `docker inspect` to extract the `PATH` environment variable. It iterates through the array looking for entries starting with `PATH=`.

### Helper image loading (Spec Section 13.3, Gap 5)

> **Solution (recommended):** Configure `helper_image` in GitLab Runner's `config.toml` to point to a registry-hosted copy. This bypasses tar loading entirely.
>
> **Solution (fallback):** Implement `POST /images/load` to accept the tar stream, extract the image manifest and layers, and push them to a configured staging registry. Then store the image reference for later use.

---

## Acceptance Criteria

### Image pull (registry manifest/config fetch)
1. `ImagePull` accepts an image reference (e.g., `nginx:latest`, `registry.gitlab.com/org/project:v1`, `123456789.dkr.ecr.us-east-1.amazonaws.com/repo:tag`) and fetches the image manifest and config blob from the registry.
2. For Docker Hub images (docker.io prefix or no prefix), the backend authenticates against `registry-1.docker.io` using the Docker Hub token auth flow: `GET /v2/` -> 401 with `Www-Authenticate` -> `GET /token?service=...&scope=...` -> bearer token -> retry with `Authorization: Bearer <token>`.
3. For ECR images (`*.dkr.ecr.*.amazonaws.com`), the backend uses the AWS ECR `GetAuthorizationToken` API to obtain Docker registry credentials, then authenticates against the ECR registry endpoint.
4. For other private registries, credentials from `POST /auth` or `X-Registry-Auth` header are used for HTTP Basic authentication.
5. The manifest is fetched via `GET /v2/<name>/manifests/<reference>` with `Accept: application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.manifest.v1+json`. The config digest is extracted from the manifest.
6. The config blob is fetched via `GET /v2/<name>/blobs/<config-digest>`. This JSON blob contains `Env`, `Cmd`, `Entrypoint`, `ExposedPorts`, `WorkingDir`, `Labels`, `Healthcheck`, and `Volumes`.
7. The image metadata (config, digest, repo tags, size) is stored in the state store for later retrieval.
8. The pull response streams synthetic JSON progress lines matching Docker's format: `{"status":"Pulling from <name>","id":"<tag>"}` ... `{"status":"Status: Image is up to date for <reference>"}`.

### Image inspect
9. `ImageInspect` returns the image metadata from the state store in Docker's format: `Id` (sha256 digest), `RepoTags`, `RepoDigests`, `Config` (with `Env`, `Cmd`, `Entrypoint`, `ExposedPorts`, `Labels`, `WorkingDir`, `Healthcheck`), `Os`, `Architecture`.
10. If the image has not been pulled (not in state), return 404 with `{"message":"No such image: <reference>"}`.
11. Image lookup supports reference by tag (`nginx:latest`), digest (`nginx@sha256:...`), and short ID prefix.

### Image load
12. `ImageLoad` accepts a tar stream, extracts the image manifest and config from it, and stores the image metadata in state. The image is recorded as available for container creation.
13. The load response streams JSON including a line matching `{"stream":"Loaded image: sha256:<digest>\n"}` or `{"stream":"Loaded image ID: sha256:<digest>\n"}` for GitLab Runner compatibility.
14. If a staging registry is configured, the loaded image layers are pushed to it so ECS can pull the image at task launch time.

### Image tag
15. `ImageTag` records a new tag for an existing image in the state store. No registry interaction is needed.
16. If the source image does not exist, return 404.

### Registry auth
17. `AuthCheck` validates credentials against the registry and stores them for later use during pulls. Returns `{"Status": "Login Succeeded"}` on success.
18. Stored credentials are keyed by registry hostname and used automatically in subsequent pull requests.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] Unit tests with mock HTTP registry for: Docker Hub auth flow, manifest fetch, config blob fetch, ECR auth token exchange, private registry basic auth
- [ ] Unit tests for: image inspect from state, image not found, image load from tar (extract config), image tag, auth credential storage
- [ ] Unit tests for synthetic pull progress stream output
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Image not found in registry returns 404 with descriptive message
- [ ] Registry auth failure returns 401 with `{"message":"unauthorized"}`
- [ ] ECR `GetAuthorizationToken` failure wrapped with context
- [ ] Network errors during manifest fetch produce retryable error
- [ ] Errors wrapped with context: `fmt.Errorf("ecs: image pull: %w", err)`
- [ ] Zerolog structured logging with image reference, registry, digest

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] README updated with supported registries and auth configuration

### Integration
- [ ] Image config available for container inspect `Config.Env` merging (ECS-003)
- [ ] ECR auth uses the same AWS credentials as the ECS backend
- [ ] Image state store entries used by container create for validation
- [ ] Credential store shared across pull and auth operations

---

## Suggested File Paths

```
backends/ecs/
├── image_pull.go               # ImagePull: registry manifest/config fetch, progress stream
├── image_inspect.go            # ImageInspect: state lookup, Docker-format response
├── image_load.go               # ImageLoad: tar extraction, optional registry push
├── image_tag.go                # ImageTag: state store tag recording
├── registry.go                 # Registry HTTP client: auth flows, manifest/blob fetch
├── registry_ecr.go             # ECR-specific auth (GetAuthorizationToken)
├── registry_dockerhub.go       # Docker Hub token auth flow
├── auth.go                     # Credential storage and retrieval
└── store.go                    # (update) Image state: config, digest, tags, credentials
```

---

## Notes

- The registry client is the most complex part of this task. Docker Hub, ECR, and generic V2 registries all have slightly different auth flows. Consider using a library like `google/go-containerregistry` for registry interactions -- it handles auth, manifest negotiation, and config fetching. However, evaluate whether the dependency is worth it vs. a focused implementation for just manifest + config blob fetch.
- ECR auth tokens expire after 12 hours. Cache the token and refresh when it expires. Use the `expiresAt` field from `GetAuthorizationToken` response.
- Docker Hub rate limits anonymous pulls (100/6h per IP) and authenticated pulls (200/6h per user). Log rate limit headers (`RateLimit-Remaining`) for observability.
- The config blob is small (typically 2-15KB) and contains all metadata CI runners need. No layer downloads are required.
- For `ImageLoad`, the tar format contains a `manifest.json` file listing the config and layers. Only the config file needs to be extracted. If no staging registry is configured, store the image metadata but warn that ECS will not be able to pull it (the image is only in the tar, not in any registry).
- Multi-architecture images: the manifest may be a manifest list (fat manifest). In that case, select the `linux/amd64` manifest (or the platform matching the ECS task's architecture) and fetch that specific manifest's config.
- Consider caching image configs in the state store with a TTL to avoid re-fetching for frequently used images.
- When parsing image references, handle these common formats: `nginx` (Docker Hub official, implicit `library/nginx:latest`), `nginx:1.25` (Docker Hub official with tag), `myuser/myimage:v1` (Docker Hub user repo), `registry.example.com/path/image:tag` (private registry), `123456789.dkr.ecr.us-east-1.amazonaws.com/repo:tag` (ECR). Normalizing the reference to a full form (registry + path + tag/digest) early simplifies downstream logic.
