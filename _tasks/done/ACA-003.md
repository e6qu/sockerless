# ACA-003: ACA logs, agent injection, and image operations

**Component:** ACA (Azure Container Apps backend)
**Phase:** 3
**Depends on:** ACA-001, AG-001
**Estimated effort:** L

---

## Description

Implement log retrieval via Azure Monitor / Log Analytics, agent sidecar injection into Container Apps Jobs, and image operations (registry config fetch from ACR and Docker Hub) for the ACA backend. Log retrieval queries the Log Analytics workspace associated with the managed environment. Agent injection prepends the sockerless-agent to the container entrypoint (via volume mount from Azure Files or baked into the image). Image operations fetch manifest and config blobs from container registries without downloading layers.

---

## Context

### ACA log retrieval (Spec Section 9.1)

> | Docker Concept | ACA Mapping |
> |---|---|
> | Container logs | Azure Monitor / Log Analytics |
>
> Container Apps Jobs emit logs to the Log Analytics workspace configured on the managed environment. Logs are queryable via Kusto Query Language (KQL) against the `ContainerAppConsoleLogs_CL` table (custom logs) or `ContainerAppSystemLogs_CL` table.

### Cloud logging for containers (Spec Section 13.1.4)

> | Requirement | Priority | Sockerless Solution |
> |---|---|---|
> | `ContainerLogs` with `stdout=true, stderr=true, timestamps=true` | P0 | Fetch from cloud logging (CloudWatch, Cloud Logging, Azure Monitor) |

### Agent injection (Spec Section 8.6)

> | Method | Description | Best For |
> |---|---|---|
> | **Volume mount** | Mount agent binary from cloud storage (EFS, GCS, Azure Files) and prepend to entrypoint | ECS, ACA |
> | **Init container** | Run init container that copies agent binary to shared volume | ECS, ACA |
>
> The backend modifies the container's entrypoint to: `["/sockerless-agent", "--", <original-entrypoint>]`
>
> The agent starts the original command as a child process and serves WebSocket connections for exec/attach.

### Image operations (Spec Section 13.3, Gap 3)

> **Solution:** When `POST /images/create` (pull) is called, the backend fetches the image's manifest and config blob from the registry API WITHOUT downloading any layers. The image config contains `Env`, `Cmd`, `Entrypoint`, `ExposedPorts`, `WorkingDir`, `Labels`, and `Healthcheck`. These are stored in the backend's image table and returned in both `GET /images/{name}/json` and merged into `GET /containers/{id}/json` -> `Config.Env`.
>
> **Registry API calls needed:** `GET /v2/<name>/manifests/<tag>` -> `GET /v2/<name>/blobs/<config-digest>`. These are lightweight (config blob is typically <10KB).

### Image load and tag (Spec Section 13.3, Gap 5)

> **Solution (fallback):** Implement `POST /images/load` to accept the tar stream, extract the image manifest and layers, and push them to a configured staging registry (e.g., ECR, Artifact Registry, ACR). Then store the image reference for later use.

---

## Acceptance Criteria

### Logs

1. `ContainerLogs` queries the Log Analytics workspace using KQL against the `ContainerAppConsoleLogs_CL` table, filtering by the job name and execution name stored in the container's state.
2. Logs are returned in Docker's multiplexed stream format (8-byte header framing) when `stdout=true` and/or `stderr=true`.
3. The `tail` parameter limits the number of log lines returned (KQL `| top N by TimeGenerated desc` reversed to chronological order).
4. The `timestamps` parameter prepends RFC3339Nano timestamps to each log line when set to `true`.
5. The `since` and `until` parameters filter logs by time range using KQL `where TimeGenerated >= datetime(...)`.
6. The `follow` parameter enables log streaming by polling Log Analytics at 2-second intervals for new entries. The stream stays open until the client disconnects or the container exits.
7. When both `stdout` and `stderr` are requested, the stream type byte in the multiplexed header correctly identifies each line's source. If Log Analytics does not distinguish stdout vs stderr, all output is sent as stdout (stream type 1).

### Agent Injection

8. The agent binary is injected into the container via one of: (a) Azure Files volume mount containing the agent binary mounted at a known path, or (b) requiring the agent binary baked into the container image at `/sockerless-agent`.
9. When using the sidecar pattern, an init container copies the agent binary from Azure Files to a shared ephemeral volume, which is then mounted into the main container.
10. The container entrypoint is rewritten to `["/sockerless-agent", "--", <original-entrypoint>, <original-cmd>...]`. For keep-alive containers (tail -f /dev/null pattern), the entrypoint is `["/sockerless-agent", "--keep-alive", "--"]`.
11. Agent environment variables are injected: `SOCKERLESS_AGENT_PORT=9111`, `SOCKERLESS_AGENT_TOKEN=<generated-token>`.
12. The agent token is stored in the container state for retrieval by the frontend during exec/attach operations.

### Image Operations

13. `ImagePull` fetches the image manifest and config blob from the container registry (ACR or Docker Hub) via the OCI Distribution API (`/v2/<name>/manifests/<tag>`, `/v2/<name>/blobs/<config-digest>`). No image layers are downloaded.
14. ACR authentication uses the configured registry credentials (username/password or managed identity via `azcontainerregistry` SDK). Docker Hub authentication uses credentials from `X-Registry-Auth` header or `POST /auth`.
15. The image config (`Env`, `Cmd`, `Entrypoint`, `ExposedPorts`, `WorkingDir`, `Labels`, `Healthcheck`) is parsed and stored in the backend's image table.
16. `ImageInspect` returns the stored image metadata in Docker's image inspect response format.
17. `ImageLoad` accepts a tar stream, extracts the image, and pushes it to the configured ACR registry. Returns a response with `{"stream":"Loaded image: sha256:<digest>\n"}`.
18. `ImageTag` records a new tag for an existing image in the backend's image table.
19. Streaming progress is returned during pull operations: `{"status":"Pulling from library/alpine","id":"latest"}` and similar Docker-compatible progress JSON lines.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests with mock Azure and registry clients for: KQL query construction, log formatting with multiplexed headers, timestamp injection, tail/since/until filtering, agent injection entrypoint rewriting, image manifest/config fetch, image config parsing, ACR auth flow
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Log Analytics query failures produce Docker-compatible `{"message": "..."}` errors
- [ ] Registry unreachable or auth failure -> `{"message": "pull access denied..."}` with 404 status
- [ ] Agent injection failures are clearly logged with remediation hints
- [ ] Errors wrapped with context: `fmt.Errorf("aca: container logs: %w", err)`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated with log retrieval, agent injection, and image operations details

### Integration
- [ ] Log output is compatible with Docker's `stdcopy.StdCopy` demultiplexer
- [ ] Agent injection works with AG-001 (WebSocket server), AG-005 (keep-alive mode)
- [ ] Image metadata is available for `ContainerInspect` (merged into container config)

---

## Suggested File Paths

```
backends/aca/
├── logs.go                  # ContainerLogs: KQL query, Log Analytics client, multiplexed streaming
├── logs_follow.go           # Log follow (polling) implementation
├── agent_inject.go          # Agent entrypoint modification, sidecar/volume mount setup
├── image_pull.go            # ImagePull: registry manifest/config fetch (ACR + Docker Hub)
├── image_ops.go             # ImageInspect, ImageLoad (tar -> ACR push), ImageTag
├── registry.go              # OCI Distribution API client, ACR auth, Docker Hub auth
└── store.go                 # (update) Image table with config, digest, tags
```

---

## Notes

- Log Analytics queries have a slight delay (30-120 seconds) before logs appear. For the `follow` mode, poll at 2-second intervals and accept that real-time latency is higher than Docker's native log follow. Document this as a known limitation.
- KQL query pattern for container logs: `ContainerAppConsoleLogs_CL | where ContainerGroupName_s == '<job-name>' and ContainerName_s == '<execution-name>' | project TimeGenerated, Log_s | order by TimeGenerated asc`.
- The Log Analytics workspace ID is obtained from the managed environment's properties (`appLogsConfiguration.logAnalyticsConfiguration.customerId`). If not explicitly configured, query the environment to discover it.
- For ACR authentication with managed identity, use the `azcontainerregistry.NewClient()` with `DefaultAzureCredential`. For username/password, use the registry login server with basic auth.
- Image load to ACR: use the `azcontainerregistry` SDK or the OCI Distribution push API (`PUT /v2/<name>/blobs/uploads/`, `PUT /v2/<name>/manifests/<tag>`). This is a complex operation; consider using `oras-go` library for OCI artifact push.
- The multiplexed stream format (8-byte header) is handled in the frontend for Docker client responses, but the backend must correctly tag log lines with the stream type (stdout=1, stderr=2) so the frontend can frame them correctly.
- Azure Monitor may not distinguish between stdout and stderr from Container Apps. If this is the case, send all logs as stdout (stream type 1) and document the limitation.
- For the agent sidecar pattern with init containers: the init container image should be a minimal image containing only the agent binary. Store this image in ACR and reference it in the job template. The init container copies the binary to an ephemeral shared volume mounted at `/sockerless-bin/`, and the main container mounts the same volume.
- Registry manifest fetch uses the OCI Distribution Spec. For Docker Hub, the registry hostname is `registry-1.docker.io` with token-based authentication via `auth.docker.io/token`. For ACR, use the Azure-specific token exchange endpoint or basic auth.
- The `follow` log implementation should track a `lastTimestamp` cursor and only query for logs newer than this timestamp on each poll iteration. This prevents duplicate log lines in the stream.
- Azure SDK packages needed for this task: `github.com/Azure/azure-sdk-for-go/sdk/monitor/azquery` for Log Analytics queries, `github.com/Azure/azure-sdk-for-go/sdk/containers/azcontainerregistry` for ACR operations.
- Log Analytics has a query rate limit. For production workloads with many containers streaming logs simultaneously, consider batching queries or implementing a log cache to reduce API calls.
- When fetching image config from Docker Hub for private images, the `X-Registry-Auth` header from the Docker client contains base64-encoded JSON with `username`, `password`, `serveraddress`. Decode and use these credentials for the registry token exchange.
- The image table in the state store should be keyed by the fully qualified image reference (e.g., `docker.io/library/alpine:3.18`) and store the raw config JSON for future inspection requests. Tag operations update the reference-to-digest mapping without re-fetching the config.
- For multi-arch images, select the `linux/amd64` platform manifest from the manifest list (index). ACA currently runs Linux containers on amd64 infrastructure.
- The agent sidecar volume name should use a consistent convention (e.g., `sockerless-agent-vol`) across all job definitions to simplify cleanup and debugging.
