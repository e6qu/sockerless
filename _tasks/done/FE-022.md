# FE-022: Docker Compose Label Support

**Component:** Docker REST API Frontend
**Phase:** 3
**Depends on:** FE-007, FE-018
**Estimated effort:** M

---

## Description

Add Docker Compose compatibility to the Sockerless frontend by supporting Compose-specific labels on containers and networks. Docker Compose v2 communicates with the Docker daemon via the standard REST API — it does NOT use any special endpoints. The key integration point is label-based filtering: Compose sets well-known labels on all objects it manages and uses those labels to filter, group, and reconcile state.

This task ensures that containers and networks created with Compose labels are correctly stored, returned in inspect responses, and filterable via the existing `GET /containers/json` and `GET /networks` endpoints. It also adds project-based grouping to the container list response, so `docker compose ps` works correctly.

No new endpoints are required. This task extends the existing filter and list logic from FE-007 (container list) and FE-018 (network endpoints) to handle Compose label patterns.

---

## Context

### Docker Compose Support (Spec Section 12)

Docker Compose v2 communicates with the Docker daemon via the same REST API. The compose operations map to supported endpoints:

| Compose Command | Docker API Calls |
|---|---|
| `docker compose up` | Pull images, Create networks, Create volumes, Create containers, Start containers |
| `docker compose down` | Stop containers, Remove containers, Remove networks, (optionally remove volumes) |
| `docker compose ps` | List containers filtered by `com.docker.compose.project` label |
| `docker compose logs` | Get container logs for each service |

### Required Compose Labels (Spec Section 12.2)

Docker Compose sets these labels on all objects. Sockerless must store and filter by them:

| Label | Purpose |
|---|---|
| `com.docker.compose.project` | Project name (directory name or `-p` flag) |
| `com.docker.compose.service` | Service name from compose file |
| `com.docker.compose.container-number` | Instance number (for `scale`) |
| `com.docker.compose.oneoff` | `"True"` for `docker compose run` containers |
| `com.docker.compose.project.config_files` | Compose file paths |
| `com.docker.compose.project.working_dir` | Project working directory |

### Service Dependencies and Health Checks (Spec Section 12.3)

`docker compose up` with `depends_on` and health checks uses:
1. `POST /containers/create` with `Healthcheck` config from compose file
2. `GET /containers/{id}/json` polling `.State.Health.Status` until `"healthy"`
3. Sequential container startup based on dependency graph

### Container List Filtering (Spec Section 4.3)

The existing `GET /containers/json` endpoint supports filtering by label:
```
filters={"label":["com.docker.compose.project=myapp"]}
```

Multiple labels are ANDed. Multiple values within a label filter are ORed.

### Network Filtering

`GET /networks?filters={"label":["com.docker.compose.project=myapp"]}` returns networks belonging to a Compose project.

---

## Acceptance Criteria

### Label Storage and Retrieval

1. `POST /containers/create` with Compose labels in `Labels` field stores all six Compose labels correctly
2. `GET /containers/{id}/json` returns all Compose labels in the `Config.Labels` field exactly as provided at creation time
3. `POST /networks/create` with Compose labels in `Labels` field stores all Compose labels correctly
4. `GET /networks/{id}` returns all Compose labels in the `Labels` field exactly as provided at creation time

### Container List Filtering by Compose Labels

5. `GET /containers/json?filters={"label":["com.docker.compose.project=myapp"]}` returns only containers belonging to the `myapp` project
6. `GET /containers/json?filters={"label":["com.docker.compose.project=myapp","com.docker.compose.service=web"]}` returns only containers matching BOTH labels (AND logic)
7. `GET /containers/json?filters={"label":["com.docker.compose.oneoff=True"]}` returns only one-off containers (from `docker compose run`)
8. `GET /containers/json?filters={"label":["com.docker.compose.project"]}` (key-only, no value) returns all Compose-managed containers regardless of project name

### Network List Filtering by Compose Labels

9. `GET /networks?filters={"label":["com.docker.compose.project=myapp"]}` returns only networks belonging to the `myapp` project
10. `GET /networks?filters={"label":["com.docker.compose.project"]}` (key-only) returns all Compose-managed networks

### Project-Based Grouping

11. When multiple containers exist with different `com.docker.compose.project` values, filtering by project returns only that project's containers
12. When multiple containers exist with the same project but different `com.docker.compose.service` values, all are returned when filtering by project alone
13. Container `Names` field follows Docker Compose naming convention: the leading `/` prefix is preserved (e.g., `["/myapp-web-1"]`)

### Network Prune with Compose Labels

14. `POST /networks/prune?filters={"label":["com.docker.compose.project=myapp"]}` removes only empty networks with the matching Compose project label
15. `POST /networks/prune` without filters does NOT remove networks that have connected containers, even if they have Compose labels

### Compose Lifecycle Integration

16. A full Compose lifecycle works: create network with Compose labels, create containers with Compose labels referencing that network, list containers filtered by project, stop and remove containers, remove network
17. The `com.docker.compose.container-number` label is stored as a string (e.g., `"1"`, `"2"`) and filterable

### Example Requests

```bash
# Create a Compose-style network
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/v1.44/networks/create \
  -H "Content-Type: application/json" \
  -d '{
    "Name": "myapp_default",
    "Labels": {
      "com.docker.compose.project": "myapp",
      "com.docker.compose.network": "default"
    }
  }'
# Expected: 201 {"Id":"<hex>","Warning":""}

# Create a Compose-managed container
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/v1.44/containers/create?name=myapp-web-1 \
  -H "Content-Type: application/json" \
  -d '{
    "Image": "nginx:latest",
    "Labels": {
      "com.docker.compose.project": "myapp",
      "com.docker.compose.service": "web",
      "com.docker.compose.container-number": "1",
      "com.docker.compose.oneoff": "False",
      "com.docker.compose.project.config_files": "/home/user/myapp/docker-compose.yml",
      "com.docker.compose.project.working_dir": "/home/user/myapp"
    }
  }'
# Expected: 201 {"Id":"<hex>","Warnings":[]}

# List containers by Compose project (docker compose ps)
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/json?all=true&filters=%7B%22label%22%3A%5B%22com.docker.compose.project%3Dmyapp%22%5D%7D" \
  | jq '.[].Names'
# Expected: [["/myapp-web-1"]]

# List all Compose-managed containers (key-only filter)
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/json?all=true&filters=%7B%22label%22%3A%5B%22com.docker.compose.project%22%5D%7D" \
  | jq '.[].Labels["com.docker.compose.project"]'
# Expected: "myapp"

# Filter by project AND service
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/json?all=true&filters=%7B%22label%22%3A%5B%22com.docker.compose.project%3Dmyapp%22%2C%22com.docker.compose.service%3Dweb%22%5D%7D" \
  | jq length
# Expected: 1

# Prune networks by Compose project label
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/networks/prune?filters=%7B%22label%22%3A%5B%22com.docker.compose.project%3Dmyapp%22%5D%7D"
# Expected: 200 {"NetworksDeleted":["myapp_default"]}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 17 acceptance criteria pass
- [ ] Compose label filtering works with both key=value and key-only forms
- [ ] Labels with dots in the key name are handled correctly (no key-splitting)
- [ ] Network prune respects label filters for Compose cleanup
- [ ] Tests cover multi-project scenarios (two projects coexisting)

---

## Suggested File Paths

```
frontends/docker/
├── handler_container_list.go   # Extended: Compose label filter patterns
├── handler_network.go          # Extended: Compose label filter on network list/prune
├── filters.go                  # Existing filter logic (no structural changes expected)
tests/
├── compose_labels_test.go      # TestComposeContainerLabels, TestComposeNetworkLabels,
│                                # TestComposeProjectFilter, TestComposeLifecycle
└── helpers/
    └── compose.go              # createComposeContainer, createComposeNetwork helpers
```

---

## Notes

- This task does NOT implement `docker compose` itself. It ensures the underlying REST API endpoints work correctly when Compose sends requests with its well-known labels. Compose is a client-side tool that orchestrates standard Docker API calls.
- Label keys containing dots (e.g., `com.docker.compose.project`) must be stored and matched as-is. Do not split on dots or treat them as hierarchical.
- The `com.docker.compose.oneoff` label uses the string `"True"` or `"False"` (capitalized), not a boolean. Filter matching must be case-sensitive string comparison.
- The `com.docker.compose.container-number` is a string representation of an integer (e.g., `"1"`), not a numeric type.
- Docker Compose v2 relies heavily on `docker compose ps` which is just `GET /containers/json` with a project label filter. If this filter works correctly, most Compose operations will work.
- Network cleanup uses both `docker network rm <name>` and `docker network prune --filter label=<hash>`. Both paths must work with Compose labels.
- When testing, create containers from at least two different Compose "projects" to verify that project-scoped filtering does not leak across projects.
