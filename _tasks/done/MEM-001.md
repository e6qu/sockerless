# MEM-001: Memory backend scaffold and state store

**Component:** In-memory Backend
**Phase:** 1
**Depends on:** API-002
**Estimated effort:** M

---

## Description

Build the in-memory backend for Sockerless. This backend stores all state (containers, images, networks, volumes, exec instances) in Go maps protected by `sync.RWMutex` locks. No data survives a restart -- this is by design, as the memory backend exists for fast integration testing without cloud credentials or a Docker daemon.

The backend is a standalone binary (`sockerless-backend-memory`) that listens on a Unix socket or TCP address and serves the internal API (`/internal/v1/...`). It implements the `Backend` interface defined in API-002 and reports full capabilities (simulated) except for cloud-specific features like `agent_required`.

This task creates the scaffold: binary entrypoint, state store, capability reporting, and the HTTP server that accepts internal API calls. Individual operations (container lifecycle, exec, images, networks, volumes) are implemented in subsequent MEM-* tasks.

---

## Context

### Memory backend role (Spec Section 9.4)

> In-memory backend for fast unit/integration tests. All state is in-memory, containers are simulated (no actual processes run). Exec returns mock output.
>
> **Capabilities:** All true (simulated). `agent_required: false`

### Backend architecture (Spec Section 6.4)

Each backend is a **stateful** daemon that:

1. Listens on a Unix socket (or TCP) for internal API calls from the frontend
2. Owns all persistent state (containers, networks, volumes, images)
3. Translates internal API calls into provider operations (in this case, in-memory maps)
4. Reports its capabilities so the frontend can return `501 Not Implemented` for unsupported operations

### State ownership (Spec Section 6.4)

| Object | State Fields |
|--------|-------------|
| Container | ID, name, config, status, cloud task ID, agent address, IP, ports, timestamps, exit code, labels |
| Network | ID, name, labels, IPAM subnet, connected containers |
| Volume | ID, name, labels, cloud storage ID, mount references |
| Image | Reference, digest, config (env/cmd/entrypoint), pulled timestamp |
| Exec | ID, container ID, cmd, env, workdir, running, exit code |

### Capability reporting (Spec Section 7.4)

`GET /internal/v1/capabilities` returns:

```json
{
  "backend": "memory",
  "version": "0.1.0",
  "capabilities": {
    "exec": true,
    "attach": true,
    "logs": true,
    "logs_follow": true,
    "volumes": true,
    "networks": true,
    "health_checks": true,
    "image_pull": true,
    "image_load": true,
    "max_timeout_seconds": 0,
    "agent_required": false
  }
}
```

### Internal API transport (Spec Section 7.2)

| Operation Type | Transport | Examples |
|---|---|---|
| CRUD (request-response) | HTTP/JSON | create/start/stop/inspect/list/remove |
| Streaming (long-lived) | WebSocket | logs with `follow=true`, container wait |

All routes prefixed with `/internal/v1/`.

---

## Acceptance Criteria

1. `sockerless-backend-memory` binary compiles and runs from `cmd/sockerless-backend-memory/main.go`.
2. Server listens on a Unix socket (default `/var/run/sockerless-backend.sock`) or TCP address and responds to internal API requests.
3. `GET /internal/v1/capabilities` returns the capability JSON above with `backend: "memory"` and all capabilities `true` except `agent_required: false`.
4. In-memory state store provides typed maps: `containers map[string]*Container`, `images map[string]*Image`, `networks map[string]*Network`, `volumes map[string]*Volume`, `execs map[string]*ExecInstance`.
5. Each resource map is protected by its own `sync.RWMutex` -- read operations take `RLock`, write operations take `Lock`.
6. Configuration loads from CLI flags (`--socket`, `--tcp`, `--log-level`) and environment variables (`SOCKERLESS_BACKEND_SOCKET`, `SOCKERLESS_BACKEND_TCP`).
7. Server returns `{"message": "..."}` format for all error responses.
8. Graceful shutdown on SIGTERM/SIGINT: drain in-flight requests, clean exit.
9. All requests are logged via zerolog with method, path, status code, and duration.
10. Unrecognized routes return `404` with `{"message": "page not found"}`.

### Example Requests

```bash
# Capability check
curl --unix-socket /var/run/sockerless-backend.sock \
  http://localhost/internal/v1/capabilities
# Expected: 200
# {
#   "backend": "memory",
#   "version": "0.1.0",
#   "capabilities": {
#     "exec": true,
#     "attach": true,
#     "logs": true,
#     "logs_follow": true,
#     "volumes": true,
#     "networks": true,
#     "health_checks": true,
#     "image_pull": true,
#     "image_load": true,
#     "max_timeout_seconds": 0,
#     "agent_required": false
#   }
# }

# Unknown route
curl --unix-socket /var/run/sockerless-backend.sock \
  http://localhost/internal/v1/nonexistent
# Expected: 404 {"message": "page not found"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Binary entrypoint works: `go run ./cmd/sockerless-backend-memory/main.go --help`
- [ ] Capabilities endpoint returns correct JSON
- [ ] State store is safe for concurrent access (verified by `go test -race`)
- [ ] Configuration loaded from flags and env vars

---

## Suggested File Paths

```
backends/memory/
├── go.mod                         # module github.com/sockerless/backend-memory, go 1.23
├── go.sum
├── README.md
├── store.go                       # State store with typed maps and per-resource mutexes
├── server.go                      # HTTP server setup, route registration
├── capabilities.go                # Capability reporting handler
├── config.go                      # CLI flags, env vars
├── errors.go                      # Error response helpers
└── cmd/
    └── sockerless-backend-memory/
        └── main.go                # Binary entrypoint
```

---

## Notes

- Use `sync.RWMutex` per resource type, not a single global lock. This allows concurrent reads on different resource types (e.g., listing containers while inspecting a network).
- The store should expose methods like `GetContainer(id)`, `PutContainer(c)`, `DeleteContainer(id)`, `ListContainers(filters)` rather than raw map access. This encapsulates locking.
- ID generation: use `crypto/rand` to generate 64-character hex strings for container and network IDs. This matches Docker's ID format.
- The state store struct should be passed to all operation handlers (MEM-002 through MEM-004) as a dependency.
- Consider using `chi` or `gorilla/mux` for routing, same as the frontend for consistency.
- The module depends on `api/` for shared types. Import as `github.com/sockerless/api`.
- State is intentionally ephemeral. Document this in the README: "All state is lost on restart. This backend is for testing only."
