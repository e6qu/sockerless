# FE-016: Image load and tag

**Component:** FE (Docker REST API frontend)
**Phase:** 1
**Depends on:** FE-014
**Estimated effort:** M

---

## Description

Implement the image load endpoint (`POST /images/load`) and image tag endpoint (`POST /images/{name}/tag`). Image load accepts a Docker image tar archive, extracts metadata from it, and either pushes the image to a configured staging registry or records it in the backend's state store. Image tag records a new tag for an existing image. These are primarily used by GitLab Runner for its helper image: the runner loads the helper from an embedded tar, parses the response for the loaded image ID, then tags it with the desired reference.

---

## Context

### Image load (Spec Section 4.2)

> `POST /images/load` -- Load Image from Tar
>
> Accepts a tar stream containing a Docker image. For sockerless:
> - Extract image metadata from the tar
> - Push the image to a configured registry (cloud backends pull from registries, not local stores)
> - Or: record the image in internal state for later use
> - GitLab Runner uses this for its helper image

### Image tag (Spec Section 4.2)

> `POST /images/{name}/tag` -- Tag Image
>
> Records a new tag for an existing image in the internal state. No cloud backend interaction needed.

### GitLab Runner helper image loading (Spec Section 13.1.3)

> **Helper image loading:**
> The runner tries three strategies in order: (1) `ImageInspectWithRaw` to check if image exists, (2) `ImageLoad` from embedded `.docker.tar.zst` file + `ImageTag`, (3) `ImagePullBlocking` from `registry.gitlab.com`. After loading from tar, it reads the JSON response stream for `"Loaded image:"` to get the image ID, then tags it. The `helper_image` config setting bypasses tar loading entirely and pulls from a registry.

### ImageTag after ImageLoad (Spec Section 13.3, Gap 14)

> **Problem:** After `ImageLoad`, the runner parses the response for `"Loaded image: <id>"` or `"Loaded image ID: <id>"`, then calls `ImageTag(id, name+":"+tag)`. Sockerless must return a compatible response format.
>
> **Solution:** `POST /images/load` response must stream JSON objects including a line matching `{"stream":"Loaded image: sha256:<digest>\n"}` or `{"stream":"Loaded image ID: sha256:<digest>\n"}`. The subsequent `POST /images/{name}/tag` records the new tag in the backend's image table.

### GitLab helper image strategy (Spec Section 13.3, Gap 5)

> **Solution (recommended):** Configure `helper_image` in GitLab Runner's `config.toml` to point to a registry-hosted copy of the helper image. This bypasses tar loading entirely. The runner will use `ImagePullBlocking` instead.
>
> **Solution (fallback):** Implement `POST /images/load` to accept the tar stream, extract the image manifest and layers, and push them to a configured staging registry (e.g., ECR, Artifact Registry, ACR). Then store the image reference for later use.

---

## Acceptance Criteria

1. `POST /images/load` accepts a request body with `Content-Type: application/x-tar` (or `application/octet-stream`) containing a Docker image tar archive.
2. The response uses chunked transfer encoding with `Content-Type: application/json`.
3. The response body is a stream of newline-delimited JSON objects, including a final line matching `{"stream":"Loaded image: sha256:<digest>\n"}` or `{"stream":"Loaded image ID: sha256:<digest>\n"}`.
4. The tar is parsed to extract: image manifest (`manifest.json`), image config (including Env, Cmd, Entrypoint, Labels), and repository/tag metadata (`repositories` file).
5. The extracted image metadata is stored in the backend's image state, keyed by the image digest.
6. The loaded image is available via `GET /images/{name}/json` using the digest or any tag from the tar.
7. `POST /images/load` returns `200 OK` with the streaming body.
8. `POST /images/load` returns `500` with `{"message":"..."}` if the tar is malformed or missing required metadata.
9. `POST /images/{name}/tag` accepts query parameters `repo` (required) and `tag` (optional, defaults to `latest`).
10. `POST /images/{name}/tag` returns `201 Created` with no body on success.
11. `POST /images/{name}/tag` returns `404` with `{"message": "No such image: <name>"}` if the source image does not exist.
12. After tagging, the image is accessible via `GET /images/{repo}:{tag}/json`.
13. Tagging does not create a copy -- it adds an alias to the existing image entry.
14. The `{name}` parameter for tag accepts image ID (`sha256:...`) or existing tag reference.

### Example Requests

```bash
# Load an image from a tar file
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/x-tar" \
  --data-binary @helper-image.tar \
  http://localhost/v1.44/images/load
# Response: 200 OK (streaming JSON)
# {"stream":"Loading layer [====================>]  1.234MB/1.234MB\n"}
# {"stream":"Loaded image: sha256:a1b2c3d4e5f6...\n"}

# Load a zstd-compressed tar (GitLab Runner sends .docker.tar.zst)
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  -H "Content-Type: application/x-tar" \
  --data-binary @helper-image.tar.zst \
  http://localhost/v1.44/images/load
# Response: 200 OK (streaming JSON)
# {"stream":"Loaded image ID: sha256:a1b2c3d4e5f6...\n"}

# Tag a loaded image
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/sha256:a1b2c3d4e5f6/tag?repo=registry.gitlab.com/gitlab-org/gitlab-runner/gitlab-runner-helper&tag=x86_64-v16.8.0"
# Response: 201 Created (no body)

# Tag a non-existent image
curl -s -X POST --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/sha256:nonexistent/tag?repo=myimage&tag=v1"
# Response: 404
# {"message":"No such image: sha256:nonexistent"}

# Verify the tag was applied
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/images/registry.gitlab.com/gitlab-org/gitlab-runner/gitlab-runner-helper:x86_64-v16.8.0/json"
# Response: 200 OK (full image metadata)
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for: load from valid tar (verify streaming response format), load from invalid tar, tag after load (full GitLab Runner flow), tag non-existent image, inspect after tag
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (NotFound, BadRequest)
- [ ] Errors wrapped with context: `fmt.Errorf("image load: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated if new public API is added

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Image state is shared with FE-014 (pull) and FE-015 (inspect)
- [ ] Loaded images are usable by FE-004 (container create)

---

## Suggested File Paths

```
frontends/docker/
├── handler_image_load.go     # POST /images/load handler
├── handler_image_tag.go      # POST /images/{name}/tag handler
├── tarutil.go                # Docker image tar parsing utilities
└── routes.go                 # Register new routes (update existing)
```

---

## Notes

- Docker image tar format: The tar contains `manifest.json` (JSON array of manifest entries), each entry having `Config` (path to config JSON blob), `RepoTags` (array of tag strings), and `Layers` (array of layer tar paths). The config blob contains the image config with Env, Cmd, Entrypoint, etc.
- GitLab Runner sends zstd-compressed tars (`.docker.tar.zst`). The load endpoint should detect and decompress zstd before parsing the tar. Use the `klauspost/compress/zstd` Go library.
- The response format must include `{"stream":"Loaded image: sha256:<digest>\n"}` exactly. GitLab Runner uses a regex to parse this line. The `\n` at the end of the stream value is required.
- For cloud backends, consider pushing the loaded image to a staging registry so that containers can actually pull it. This is a backend-level concern -- the frontend just passes the tar to the backend.
- The memory backend can store the image metadata from the tar without pushing anywhere. Layer data can be discarded since the memory backend simulates container execution.
- The `POST /images/{name}/tag` endpoint path contains the source image name, and the `repo` and `tag` query parameters specify the new reference. This is the reverse of what you might expect.
- Docker's tag endpoint returns `201 Created` with no body. Some older Docker versions return `201` with empty JSON `{}`. Return no body for consistency.
