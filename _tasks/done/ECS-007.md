# ECS-007: Network operations (VPC/Cloud Map)

**Component:** ECS (AWS ECS Fargate backend)
**Phase:** 2
**Depends on:** ECS-001
**Estimated effort:** L

---

## Description

Implement network operations for the ECS backend: create, list, inspect, disconnect, remove, and prune. Docker networks map to VPC security groups for isolation and AWS Cloud Map service discovery namespaces for DNS-based alias resolution. CI runners create per-job networks so service containers (postgres, redis) are reachable by DNS name from the build container. This task manages security group lifecycle, Cloud Map private DNS namespaces, and service instance registration so that container aliases resolve to the correct Fargate task ENI IPs.

---

## Context

### Network emulation strategy (Spec Section 11.2)

> Each sockerless network maps to an isolated cloud networking construct:
>
> | Cloud Backend | Network Emulation |
> |---|---|
> | AWS ECS | VPC security group per network; AWS Cloud Map service discovery namespace for DNS aliases |

### Network lifecycle (Spec Section 11.4)

> | Docker Operation | Sockerless Action |
> |---|---|
> | `POST /networks/create` | Create cloud networking construct (security group, Cloud Map namespace, etc.) |
> | Container create with `NetworkMode`/`EndpointsConfig` | Assign virtual IP, register DNS aliases |
> | `POST /networks/{id}/disconnect` | Remove DNS alias, detach from security group |
> | `DELETE /networks/{id}` | Tear down cloud networking construct |
> | `POST /networks/prune` | Clean up unused cloud networking constructs |

### IP address assignment (Spec Section 11.3)

> Sockerless assigns virtual IPs from a private subnet (e.g., `172.18.0.0/16`) to each container on a network. These IPs are returned in inspect responses. Actual cloud networking may use different IPs, but the sockerless-level IPs provide the correct inspect output for CI runners.
>
> For DNS-based service discovery (which is what CI runners actually rely on), the container aliases are registered in the cloud's DNS service so they resolve to the actual cloud IPs.

### Network aliases for CI runners (Spec Section 13.3, Gap 10)

> **Problem:** Both runners rely on DNS resolution for service aliases. GitLab uses `EndpointsConfig.Aliases`; GitHub uses network-scoped container names.
>
> **Solution (ECS):** AWS Cloud Map service discovery. Create a private DNS namespace. Register each container as a service instance with its aliases. Cloud Map DNS resolves aliases to task ENI IPs.

### GitLab Runner network usage (Spec Section 13.1.2)

> ```
> 3. Network Setup
>    NetworkCreate("runner-net-<guid>")   # per-build network (FF_NETWORK_PER_BUILD)
> ```
>
> With `FF_NETWORK_PER_BUILD` enabled, the runner creates a per-build user-defined bridge network. Service aliases (e.g., `["postgres", "db"]`) are set via `NetworkingConfig.EndpointsConfig[networkName].Aliases`. Docker's embedded DNS resolves these aliases within the network.

### ExtraHosts support (Spec Section 11.5)

> GitLab Runner uses `ExtraHosts` when `FF_NETWORK_PER_BUILD` is disabled (legacy mode). Sockerless passes these as environment entries or injects them into `/etc/hosts` via the exec agent.

### Docker network create request (Spec Section 4.5)

> ```json
> {
>   "Name": "github_network_abc123",
>   "Labels": {"com.gitlab.gitlab-runner.managed": "true"},
>   "EnableIPv6": false,
>   "Driver": "bridge",
>   "Options": {"com.docker.network.driver.mtu": "1500"}
> }
> ```
>
> **Response:** `{"Id": "<64-char-hex>", "Warning": ""}`

### Network inspect response (Spec Section 4.5)

> ```json
> {
>   "Name": "build-network",
>   "Id": "<hex>",
>   "Created": "2026-02-15T12:00:00Z",
>   "Scope": "local",
>   "Driver": "bridge",
>   "EnableIPv6": false,
>   "IPAM": {
>     "Driver": "default",
>     "Config": [{"Subnet": "172.18.0.0/16", "Gateway": "172.18.0.1"}]
>   },
>   "Containers": {
>     "<container-id>": {
>       "Name": "postgres",
>       "IPv4Address": "172.18.0.2/16"
>     }
>   },
>   "Labels": {}
> }
> ```

---

## Acceptance Criteria

### NetworkCreate
1. `NetworkCreate` creates a VPC security group in the configured VPC with a name tag `sockerless-net-<network-id-prefix>`.
2. The security group allows all inbound traffic from itself (self-referencing ingress rule) so all containers on the same network can communicate on all ports.
3. The security group allows inbound TCP on port 9111 from the frontend's CIDR or security group (for agent connectivity).
4. A Cloud Map private DNS namespace is created for the network with the name `<network-name>.sockerless.local`. The namespace is associated with the configured VPC.
5. The network is stored in the state with a generated 64-char hex ID, the security group ID, the Cloud Map namespace ARN, labels, and creation timestamp.
6. A virtual IPAM subnet (e.g., `172.18.0.0/16`) is assigned to the network for inspect-response compatibility. Gateway IP is `172.18.0.1`.
7. `NetworkCreate` returns `{"Id": "<64-char-hex>", "Warning": ""}`.

### Container network registration
8. When a container is connected to a network (during container create via `NetworkingConfig.EndpointsConfig`), a virtual IP from the network's subnet is assigned and stored in the container state.
9. DNS aliases from `EndpointsConfig[networkName].Aliases` are registered as Cloud Map service instances. Each alias creates a Cloud Map service with an A record pointing to the container's task ENI IP.
10. The container name is also registered as a Cloud Map service instance (containers are reachable by name).
11. The container's security groups in the task definition include the network's security group (in addition to the default security group).

### NetworkInspect
12. `NetworkInspect` returns the network metadata from state in Docker's format, including `Name`, `Id`, `Created`, `Scope` ("local"), `Driver` ("bridge"), `IPAM` config, `Containers` map (with name and virtual IP for each connected container), and `Labels`.
13. Inspect by full ID, short ID prefix, or network name all work.

### NetworkList
14. `NetworkList` returns all networks from the state store, filtered by the `Filters` map.
15. Supported filters: `id`, `name`, `label` (key, key=value), `driver`, `scope`.

### NetworkDisconnect
16. `NetworkDisconnect` deregisters the container's Cloud Map service instances (DNS aliases) for the specified network.
17. The container's virtual IP for this network is released.
18. The network's security group is removed from the container's active security groups (note: this cannot modify a running Fargate task's security groups -- store the disconnection in state and apply on next task launch).

### NetworkRemove
19. `NetworkRemove` deletes the Cloud Map namespace and all its services/instances.
20. `NetworkRemove` deletes the VPC security group.
21. If containers are still connected, return `403 Forbidden` with a descriptive message (unless force mode).
22. The network is removed from the state store.

### NetworkPrune
23. `NetworkPrune` removes all networks with no connected containers.
24. Returns `{"NetworksDeleted": ["net1", "net2"]}` with the names of deleted networks.
25. Filters (e.g., `label`) are respected.

### Example SDK Calls

```go
// CreateSecurityGroup
ec2.CreateSecurityGroup(&ec2.CreateSecurityGroupInput{
    GroupName:   aws.String("sockerless-net-abc123"),
    Description: aws.String("Sockerless network: build-network"),
    VpcId:       &vpcId,
    TagSpecifications: []types.TagSpecification{{
        ResourceType: types.ResourceTypeSecurityGroup,
        Tags: []types.Tag{{Key: aws.String("sockerless-network"), Value: &networkID}},
    }},
})

// CreatePrivateDnsNamespace (Cloud Map)
servicediscovery.CreatePrivateDnsNamespace(&servicediscovery.CreatePrivateDnsNamespaceInput{
    Name: aws.String("build-network.sockerless.local"),
    Vpc:  &vpcId,
})

// RegisterInstance (Cloud Map)
servicediscovery.RegisterInstance(&servicediscovery.RegisterInstanceInput{
    ServiceId:  &serviceId,
    InstanceId: aws.String(containerID[:12]),
    Attributes: map[string]string{
        "AWS_INSTANCE_IPV4": eniPrivateIP,
    },
})
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] Unit tests with mock AWS clients for: security group creation (with ingress rules), Cloud Map namespace creation, service instance registration/deregistration, network inspect (with and without containers), network list with filters, network disconnect, network remove (empty and with containers), network prune
- [ ] Tests for virtual IP assignment (sequential allocation, no conflicts)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Network not found returns 404 with Docker-format message
- [ ] Remove network with connected containers returns 403
- [ ] AWS errors (VPC not found, security group limit) wrapped with context
- [ ] Cloud Map namespace creation failure produces clear error
- [ ] Errors wrapped with context: `fmt.Errorf("ecs: network create: %w", err)`
- [ ] Zerolog structured logging with network ID, security group ID, namespace ARN

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] README updated with VPC and Cloud Map prerequisites

### Integration
- [ ] Network security groups applied to container task definitions (ECS-002)
- [ ] Cloud Map DNS aliases resolvable from within Fargate tasks on the same VPC
- [ ] Network state used by container inspect for `NetworkSettings` (ECS-003)
- [ ] Virtual IPs returned in inspect response match Docker's format

---

## Suggested File Paths

```
backends/ecs/
├── network_create.go           # NetworkCreate: security group + Cloud Map namespace
├── network_inspect.go          # NetworkInspect and NetworkList: state lookup, Docker format
├── network_disconnect.go       # NetworkDisconnect: Cloud Map deregistration
├── network_remove.go           # NetworkRemove and NetworkPrune: cleanup security group + namespace
├── network_dns.go              # Cloud Map service/instance registration for DNS aliases
├── network_ipam.go             # Virtual IP allocation from subnet pool
└── store.go                    # (update) Network state: security group ID, namespace ARN, container membership
```

---

## Notes

- Cloud Map namespace creation is asynchronous -- `CreatePrivateDnsNamespace` returns an operation ID. Poll `GetOperation` until the operation is complete before proceeding. This typically takes 10-30 seconds.
- Cloud Map has a limit of 1,000 namespaces per account/region. For high-volume CI, consider reusing namespaces or implementing namespace pooling.
- Security group limits: 2,500 per VPC by default (adjustable). Each network creates one security group. For CI workloads with many concurrent jobs, this limit may be reached. Monitor usage and document the limit.
- The self-referencing security group ingress rule is key: it allows all containers on the same network to communicate on any port, matching Docker's bridge network behavior.
- Cloud Map DNS propagation is nearly instant (< 5 seconds) for private DNS namespaces within the same VPC.
- Virtual IP assignment from the `172.18.0.0/16` range is purely cosmetic -- it provides Docker-compatible inspect output. Actual container-to-container communication uses the real ENI IPs resolved via Cloud Map DNS.
- When a container is created with `NetworkMode` set to a network name, the backend should look up the network by name and apply the security group. If the network does not exist, return 404.
- Consider implementing batch operations for security group rule management to reduce API calls.
- EC2 API client (`ec2`) is needed for security group operations. Ensure this client is initialized in ECS-001.
