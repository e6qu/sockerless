# FE-008: GET /containers/{id}/logs

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** FE-005, FE-002
**Estimated effort:** M

---

## Description

Implement the `GET /containers/{id}/logs` endpoint. This endpoint returns container logs using Docker's multiplexed stream protocol (8-byte header framing) when `Tty=false`. It supports one-shot log retrieval and streaming (`follow=true`). Both GitLab Runner and GitHub Actions Runner rely on this endpoint to capture CI job output.

## Context

### Container Logs (spec Section 4.3)

Query parameters:
- `stdout` (bool): Include stdout
- `stderr` (bool): Include stderr
- `follow` (bool): Stream logs (long-poll)
- `timestamps` (bool): Add RFC3339Nano timestamps
- `tail` (string): Number of lines from end (`"all"` or number)
- `details` (bool): Include extra attributes

**Response format:** Multiplexed stream (when `Tty: false`, which is the CI runner case):
```
[stream_type: 1 byte][0x00 0x00 0x00][size: 4 bytes big-endian][payload: size bytes]
```
Where `stream_type` = `1` (stdout) or `2` (stderr).

### Multiplexed Stream Protocol (spec Section 5.2)

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| STREAM | 0x00   | 0x00   | 0x00   | SIZE1  | SIZE2  | SIZE3  | SIZE4  |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

- **Byte 0 (STREAM):** `0` = stdin, `1` = stdout, `2` = stderr
- **Bytes 1-3:** Padding (zeros)
- **Bytes 4-7:** Payload size as big-endian uint32
- **Following bytes:** Payload (exactly SIZE bytes)

### How CI Runners Read Logs

- **GitLab Runner:** Reads logs with `stdout=true, stderr=true, timestamps=true, follow=false` (one-shot, 64KB limit). Uses `stdcopy.StdCopy` to demultiplex.
- **GitHub Runner:** Reads logs with `details=true, stdout=true, stderr=true`. Also uses stdcopy.

### Sockerless Behavior (spec Section 4.3)

- Fetch logs from the cloud backend's logging service (CloudWatch, Cloud Logging, Azure Monitor)
- Format into Docker's multiplexed stream protocol
- For `follow=true`, keep the connection open and stream new log entries

### Internal API (spec Section 7.3)

- One-shot logs: `GET /internal/v1/containers/{id}/logs` with query params
- Streaming logs: `WS /internal/v1/containers/{id}/logs/stream`

## Acceptance Criteria

1. `GET /containers/{id}/logs` returns `200 OK` with multiplexed stream body when `Tty=false`
2. Returns `404 Not Found` with `{"message": "No such container: <id>"}` if container does not exist
3. `stdout=true` includes stdout frames (stream type `1`); `stdout=false` excludes them
4. `stderr=true` includes stderr frames (stream type `2`); `stderr=false` excludes them
5. At least one of `stdout` or `stderr` must be true; if both false, return `400 Bad Request`
6. `follow=false` (default): returns all available logs and closes the connection
7. `follow=true`: keeps the connection open and streams new log lines as they appear
8. `tail=N` returns only the last N lines; `tail=all` (default) returns all lines
9. `timestamps=true` prepends RFC3339Nano timestamp to each log line (e.g., `2026-02-15T12:00:00.123456789Z hello world`)
10. Response is correctly framed using the FE-002 multiplexed stream encoder
11. Output is compatible with Docker SDK's `stdcopy.StdCopy` (verified via integration test)
12. `follow=true` connection closes when the container exits
13. Logs for a container that has not produced output yet return an empty response (not an error)

### Example Requests

```bash
# Get all logs (one-shot)
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/logs?stdout=true&stderr=true" \
  --output - | xxd | head -5
# 00000000: 0100 0000 0000 000c 6865 6c6c 6f20 776f  ........hello wo
# 00000010: 726c 640a                                 rld.
# (stdout frame: stream=1, size=12, payload="hello world\n")

# Get last 10 lines
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/logs?stdout=true&stderr=true&tail=10" \
  --output -

# Get logs with timestamps (GitLab Runner pattern)
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/logs?stdout=true&stderr=true&timestamps=true" \
  --output -
# Frame payload: "2026-02-15T12:00:00.123456789Z hello world\n"

# Follow logs (streaming)
curl -s -N --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/logs?stdout=true&stderr=true&follow=true" \
  --output -
# (connection stays open, frames arrive as logs are produced)

# Logs with details (GitHub Runner pattern)
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/a1b2c3d4e5f6/logs?stdout=true&stderr=true&details=true" \
  --output -

# Container not found
curl -s --unix-socket /var/run/sockerless.sock \
  "http://localhost/v1.44/containers/nonexistent/logs?stdout=true"
# 404 {"message":"No such container: nonexistent"}
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Multiplexed framing verified with `stdcopy.StdCopy` compatibility test
- [ ] `follow=true` streaming tested (connection stays open, receives new data)
- [ ] `tail=N` correctly limits output to last N lines
- [ ] `timestamps=true` prepends RFC3339Nano timestamps

## Suggested File Paths

```
frontends/docker/
├── handler_container_logs.go   # GET /containers/{id}/logs handler
└── stream_writer.go            # Helper to write multiplexed frames to ResponseWriter
```

## Notes

- The response for logs uses chunked transfer encoding. Set `Content-Type: application/vnd.docker.raw-stream` and use `http.Flusher` to flush each frame immediately.
- When `Tty=true`, logs are NOT multiplexed (raw bytes). For Sockerless, CI runners always use `Tty=false`, but handle the `Tty=true` case by writing raw bytes without headers.
- The `follow=true` mode requires the `ResponseWriter` to implement `http.Flusher`. Call `flusher.Flush()` after each frame to ensure the client receives data promptly.
- For the memory backend, logs can be stored as an in-memory buffer. For cloud backends, logs come from the cloud logging service. The frontend does not need to know the source -- it receives log data from the backend via the internal API and frames it.
- The `tail` parameter applies before streaming. If `tail=10` and `follow=true`, return the last 10 lines first, then stream new lines.
- Docker's behavior when the container is still running and `follow=false`: return all logs produced so far and close. The response is complete even though the container may produce more logs later.
- The `details` parameter adds label information as key-value pairs at the beginning of each log line. This is rarely used but GitHub Runner sets it. If no extra details are available, it has no effect.
