# TST-013: Cloud Run Integration Tests

**Component:** Test Infrastructure and Suites
**Phase:** 3
**Depends on:** GCR-002, GCR-003, GCR-004
**Estimated effort:** L

---

## Description

Integration test suite that validates the complete container lifecycle on the Google Cloud Run backend. Tests exercise container create, start, inspect, list, logs, stop, and remove operations against actual Cloud Run Jobs, verifying that the Sockerless Cloud Run backend correctly translates Docker API semantics to GCP Cloud Run Jobs API operations. Tests also cover agent connectivity (exec/attach via the sockerless-agent running inside Cloud Run), Cloud Logging log retrieval, and network/volume operations (Cloud DNS and GCS FUSE).

All tests in this suite require GCP credentials and a configured GCP project. Tests are automatically skipped when credentials are not available, so CI pipelines without GCP access continue to pass.

---

## Context

### Cloud Run Backend Mapping (Spec Section 9.1)

| Docker Concept | Cloud Run Mapping |
|---|---|
| Container create + start | `CreateJob` + `RunJob` (or `CreateExecution`) |
| Container stop | `CancelExecution` |
| Container logs | Cloud Logging (`entries.list`) |
| Exec / Attach | Via sockerless-agent (agent on Cloud Run's ingress port) |
| Image pull | Cloud Run pulls from Artifact Registry / GCR / Docker Hub natively |
| Network | VPC Connector or Direct VPC Egress |
| Volume | Cloud Storage FUSE, GCS, in-memory (tmpfs) |

**Agent networking:** Cloud Run containers serve traffic on the port defined by `PORT` env var. The agent can share this port (mux HTTP + WebSocket) or use Cloud Run's sidecar support. Frontend reaches agent via Cloud Run's internal URL.

**Startup latency:** 5-30 seconds.

### Capability Matrix (Spec Section 9.1)

| Capability | Cloud Run |
|---|---|
| Long-running | Yes (24h max) |
| Exec | Yes (via agent) |
| Attach | Yes (via agent) |
| Log stream | Yes |
| Log follow | Yes |
| Volumes | Partial (GCS FUSE) |
| Networks | Yes |
| Health checks | Yes |
| Agent needed | Yes |
| Startup latency | 5-30s |

### Cloud Logging Integration (Spec Section 9.1)

Container logs are retrieved from Cloud Logging via `entries.list` API. The backend queries by job execution resource name and formats entries into Docker-compatible multiplexed log frames with stdout/stderr separation and optional timestamps.

### Cloud DNS for Network Aliases (Spec Section 13.3, Gap 10)

Cloud Run uses Cloud DNS private zones for service discovery. Container aliases create A records pointing to container internal IPs. Tests verify that containers on the same network can resolve each other by name.

### GCS FUSE Volume Mounts (Spec Section 10.3)

Named volumes map to GCS bucket paths mounted via Cloud Storage FUSE. Multiple Cloud Run jobs can mount the same bucket path for shared data access.

---

## Acceptance Criteria

### Prerequisites and Skip Logic

1. Tests detect GCP credentials via `GOOGLE_APPLICATION_CREDENTIALS` env var or Application Default Credentials; if absent, all tests in this suite are skipped with `t.Skip("GCP credentials not available")`
2. Tests detect the target GCP project via `SOCKERLESS_GCP_PROJECT` env var; if absent, tests are skipped
3. Tests detect the target GCP region via `SOCKERLESS_GCP_REGION` env var (default: `us-central1`)

### Container Lifecycle

4. `POST /containers/create` with a public image (e.g., `alpine:latest`) succeeds and returns a valid container ID
5. `POST /containers/{id}/start` blocks until the Cloud Run job execution is in RUNNING state and the agent is reachable, then returns `204`
6. `GET /containers/{id}/json` returns container state `"running"` with correct `Config` fields (Image, Env, Cmd, Entrypoint, Labels)
7. `GET /containers/{id}/json` returns `NetworkSettings` with an assigned IP address
8. `GET /containers/json?filters={"id":["<id-prefix>"]}` returns the container in the list
9. `POST /containers/{id}/stop` stops the Cloud Run job execution; subsequent inspect shows state `"exited"`
10. `DELETE /containers/{id}` removes the container from state and cleans up the Cloud Run job resource

### Agent Connectivity

11. After container start, `POST /containers/{id}/exec` with `Cmd: ["echo", "hello"]` creates an exec instance
12. `POST /exec/{id}/start` returns the command output (`hello\n`) via the agent WebSocket bridge
13. Exec exit code is correctly returned: `sh -c "exit 0"` returns 0, `sh -c "exit 1"` returns 1
14. `GET /exec/{id}/json` returns the correct `ExitCode` and `Running: false` after completion

### Log Retrieval

15. `GET /containers/{id}/logs?stdout=true&stderr=true` returns log output retrieved from Cloud Logging
16. `GET /containers/{id}/logs?stdout=true&stderr=true&timestamps=true` includes RFC3339Nano timestamps prefixed to each log line
17. `GET /containers/{id}/logs?tail=10` returns at most the last 10 log lines
18. Logs contain output from commands executed via exec (verifying that Cloud Logging captures agent-relayed output)

### Image Operations

19. `POST /images/create?fromImage=alpine&tag=latest` records the image reference without downloading layers; returns streaming JSON progress
20. `GET /images/alpine:latest/json` returns image metadata including `Config.Env` (fetched from registry manifest/config)

### Network Operations

21. `POST /networks/create` with a name and labels succeeds on the Cloud Run backend
22. Containers created on the same network can resolve each other by container name (verified by exec-ing a DNS lookup or curl command)
23. `DELETE /networks/{id}` cleans up Cloud DNS resources

### Volume Operations

24. `POST /volumes/create` with a name succeeds on the Cloud Run backend
25. A container started with a volume mount can write data; a second container mounting the same volume can read the data (shared GCS FUSE)
26. `DELETE /volumes/{name}` cleans up the GCS bucket path

### Error Handling

27. `POST /containers/{id}/start` for a non-existent container returns `404` with Docker-format error message
28. `GET /containers/{id}/json` for a non-existent container returns `404`
29. `POST /containers/create` with an invalid image reference returns an appropriate error

### Resource Cleanup

30. Every test cleans up all created Cloud Run jobs, networks, and volumes via `defer` statements, even on test failure

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default (Cloud Run tests skipped without credentials)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 30 acceptance criteria pass (when GCP credentials are available)
- [ ] Tests are skipped cleanly without credentials (no failures, no errors)
- [ ] Test timeouts account for Cloud Run startup latency (5-30s per container)
- [ ] Each test uses unique resource names to avoid collisions with parallel runs
- [ ] All GCP resources are cleaned up after each test, even on failure
- [ ] Tests pass with `go test -v -timeout 600s` (10-minute overall timeout)

---

## Suggested File Paths

```
tests/
├── cloudrun_integration_test.go       # TestCloudRunContainerLifecycle, TestCloudRunExec,
│                                       # TestCloudRunLogs, TestCloudRunNetwork, TestCloudRunVolume
├── cloudrun_agent_test.go             # TestCloudRunAgentConnectivity, TestCloudRunExecExitCodes
└── helpers/
    ├── cloudrun.go                    # skipIfNoGCPCredentials, gcpProject, gcpRegion helpers
    └── cloud_common.go                # waitForRunning (with extended timeout), cloudCleanup helpers
```

---

## Notes

- **Credential detection:** Use `google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")` to detect credentials. If it returns an error, skip the entire test file. Do NOT fail the test — this allows the test suite to pass in environments without GCP access.
- **Startup latency:** Cloud Run jobs take 5-30 seconds to start. All tests that call `POST /containers/{id}/start` should use extended timeouts (at minimum 60s per container start). Use a helper like `waitForRunning(t, containerID, 60*time.Second)`.
- **Cloud Logging delay:** Cloud Logging entries may take 1-5 seconds to become available after they are written. Log retrieval tests should include a short retry loop (poll every 2s for up to 30s) before asserting on log content.
- **Cost awareness:** Each test creates real Cloud Run jobs and GCS resources that incur costs. Keep the test suite focused on essential scenarios. Use `testing.Short()` to skip expensive multi-container tests in quick CI runs.
- **Parallel execution:** Tests within this suite should NOT run in parallel (`t.Parallel()` is omitted) to avoid resource contention and simplify cleanup. The overall suite is fast enough (2-5 minutes) that parallelism is unnecessary.
- **Image choice:** Use `alpine:latest` or `busybox:latest` for test containers. These are small, widely available, and start quickly. Avoid large images that increase pull time.
- **Cleanup resilience:** Use `defer` for all cleanup, and make cleanup helpers idempotent (ignore "not found" errors on delete). This ensures resources are cleaned up even if the test panics.
