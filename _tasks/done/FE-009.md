# FE-009: POST /containers/{id}/attach

**Component:** Docker REST API Frontend
**Phase:** 1
**Depends on:** FE-005, FE-002
**Estimated effort:** L

---

## Description

Implement the `POST /containers/{id}/attach` endpoint -- the most critical endpoint for GitLab Runner compatibility. This is a connection-hijacking endpoint: after the HTTP response headers, the connection becomes a raw bidirectional byte stream using Docker's multiplexed frame protocol. The frontend must support the attach-before-start pattern where GitLab Runner calls attach BEFORE calling start.

## Context

### Container Attach (spec Section 4.3)

This is a **connection-hijacking** endpoint. After the HTTP response headers, the connection is "hijacked" -- it becomes a raw bidirectional byte stream.

Query parameters:
- `stream` (bool): Stream attached
- `stdin` (bool): Attach stdin
- `stdout` (bool): Attach stdout
- `stderr` (bool): Attach stderr

**Response:** HTTP 101 Switching Protocols (or 200 with hijacked connection), then multiplexed stream.

Content-Type: `application/vnd.docker.raw-stream`

### Connection Hijacking Protocol (spec Section 5.3)

1. Client sends HTTP POST request
2. Server responds with `101 Switching Protocols` (or `200 OK` with `Connection: Upgrade`)
3. The TCP connection is now a raw bidirectional byte stream
4. Server writes multiplexed frames for stdout/stderr (8-byte header + payload)
5. Client writes raw bytes for stdin (NOT multiplexed when Tty=false)
6. Connection closes when the command/container exits

### How GitLab Runner Uses Attach (spec Section 4.3)

This is the **most critical flow** for GitLab Runner:

1. Creates container with `Cmd` set to the script, `OpenStdin: true`
2. Calls `POST /containers/{id}/attach` with `stream=true, stdin=true, stdout=true, stderr=true` **BEFORE starting the container**
3. Calls `POST /containers/{id}/start`
4. Streams stdin (the build script) over the hijacked connection
5. Reads stdout/stderr from the hijacked connection using the 8-byte multiplexed frame protocol
6. Connection closes when container exits

### Gap 1: Attach-Before-Start Timing (spec Section 13.3)

**Problem:** GitLab Runner calls `ContainerAttach` before `ContainerStart`. Docker returns the hijacked connection instantly because the daemon holds it. Cloud backends don't have a container to attach to yet.

**Solution:** The frontend returns `101 Switching Protocols` immediately and holds the hijacked connection. When `ContainerStart` is called, the backend launches the cloud task. Once the agent is reachable (agent reports ready via backend polling), the frontend opens a WebSocket to the agent and begins bridging the buffered hijacked connection to the agent's stream.

**Risk:** If the job timeout is very short and cloud startup takes too long, the attach will sit idle until the job times out. No mitigation needed -- this is the correct behavior (the runner's context controls the timeout).

### Multiplexed Stream Protocol (spec Section 5.2)

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| STREAM | 0x00   | 0x00   | 0x00   | SIZE1  | SIZE2  | SIZE3  | SIZE4  |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

- Byte 0 (STREAM): `0` = stdin, `1` = stdout, `2` = stderr
- Bytes 1-3: Padding (zeros)
- Bytes 4-7: Payload size as big-endian uint32

Server-to-client: multiplexed frames (stdout/stderr with headers)
Client-to-server: raw bytes (stdin without headers) when Tty=false

## Acceptance Criteria

1. `POST /containers/{id}/attach?stream=true&stdin=true&stdout=true&stderr=true` returns `101 Switching Protocols`
2. Response headers include `Content-Type: application/vnd.docker.raw-stream` and `Connection: Upgrade`
3. After 101, the connection is hijacked -- the server can read/write raw bytes
4. Server writes stdout as multiplexed frames (stream type `1` + 8-byte header)
5. Server writes stderr as multiplexed frames (stream type `2` + 8-byte header)
6. Server reads stdin as raw bytes (no multiplexed header) from the client
7. **Attach-before-start works:** calling attach on a `"created"` container returns 101 immediately and buffers until start
8. After the container is started, stdin data is forwarded to the container's stdin
9. After the container is started, container stdout/stderr is streamed back to the client as multiplexed frames
10. Connection closes (EOF) when the container exits
11. Returns `404 Not Found` with `{"message": "No such container: <id>"}` if container does not exist
12. Attach with `stdin=false` does not read from the client connection
13. Attach with `stdout=false` does not send stdout frames
14. Attach with `stderr=false` does not send stderr frames
15. Output is compatible with Docker SDK's `stdcopy.StdCopy`
16. Multiple concurrent attaches to the same container are supported (fan-out stdout/stderr)

### Example Requests

```bash
# Attach to a container (note: curl cannot fully test hijacked connections,
# but it can initiate the upgrade)
curl -v --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/a1b2c3d4e5f6/attach?stream=true&stdout=true&stderr=true"
# < HTTP/1.1 101 Switching Protocols
# < Content-Type: application/vnd.docker.raw-stream
# < Connection: Upgrade
# < Upgrade: tcp
# (connection is now hijacked -- binary multiplexed stream follows)

# GitLab Runner flow (pseudocode, not curl):
# 1. POST /containers/create -> {"Id": "abc123..."}
# 2. POST /containers/abc123.../attach?stream=true&stdin=true&stdout=true&stderr=true -> 101
#    (connection hijacked, waiting for container to start)
# 3. POST /containers/abc123.../start -> 204
#    (container starts, attach connection becomes live)
# 4. Write build script bytes to stdin over hijacked connection
# 5. Read multiplexed stdout/stderr frames from hijacked connection
# 6. Container exits, connection EOF

# Attach to non-existent container
curl -s --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/v1.44/containers/nonexistent/attach?stream=true&stdout=true"
# 404 {"message":"No such container: nonexistent"}
```

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract (unless the task explicitly requires it)
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Connection hijacking works: `http.Hijacker` interface used correctly
- [ ] Attach-before-start tested: attach on created container, then start, verify data flows
- [ ] Multiplexed framing verified with stdcopy.StdCopy
- [ ] Stdin -> container, stdout/stderr -> client data flow verified
- [ ] Connection closes cleanly on container exit

## Suggested File Paths

```
frontends/docker/
├── handler_container_attach.go   # POST /containers/{id}/attach handler
├── hijack.go                     # Connection hijacking utilities
└── bridge.go                     # Bridge between hijacked conn and agent WebSocket
```

## Notes

- Connection hijacking in Go uses the `http.Hijacker` interface: `hijacker, ok := w.(http.Hijacker); conn, bufrw, err := hijacker.Hijack()`. After hijacking, the `http.ResponseWriter` is no longer usable -- all I/O goes through the raw `net.Conn`.
- The `101 Switching Protocols` response must be written BEFORE calling `Hijack()`. Write it manually: `bufrw.WriteString("HTTP/1.1 101 UPGRADED\r\nContent-Type: application/vnd.docker.raw-stream\r\nConnection: Upgrade\r\nUpgrade: tcp\r\n\r\n"); bufrw.Flush()`.
- For the attach-before-start pattern, the frontend must maintain a map of container ID -> pending attach connections. When `POST /containers/{id}/start` completes, it signals the waiting attach goroutine to begin bridging.
- Use `sync.Cond` or a channel to synchronize between the attach handler (waiting) and the start handler (signaling).
- Buffer stdin data received before the container starts. When the container starts and the agent is connected, flush the buffered stdin and then stream live.
- The bridge between the hijacked Docker connection and the backend/agent needs bidirectional copy. Use two goroutines: one copying client stdin -> agent stdin, one copying agent stdout/stderr -> client (with multiplexed framing).
- When the container exits, close the hijacked connection by sending EOF. The Docker SDK detects this as the end of the attach session.
- Be careful with goroutine leaks: if the client disconnects before the container starts, clean up the pending attach. Use context cancellation.
- This endpoint is NOT used by GitHub Actions Runner (it uses exec instead). But it is P0 for GitLab Runner.
