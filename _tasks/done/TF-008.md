# TF-008: FaaS Terraform modules and test environments

**Component:** Terraform
**Phase:** 4
**Depends on:** TF-001
**Estimated effort:** L

---

## Description

Create Terraform modules and test environments for all three FaaS backends: AWS Lambda, Google Cloud Functions (2nd gen), and Azure Functions. Since FaaS backends have simpler infrastructure requirements than the container-based backends (no VNet integration, no agent networking, no shared volumes), all three modules and their test environments are combined into a single task.

Each module provisions the cloud infrastructure needed by its respective backend (LAM-001, GCF-001, AZF-001). Each test environment instantiates its module with cost-optimized defaults, configures a remote state backend, and outputs the values needed by TST-015 (FaaS capability tests).

---

## Context

### FaaS backend capabilities (Spec Section 9.2)

FaaS backends have hard limitations compared to container-based backends. They report reduced capabilities:

> | Capability | Lambda | CR Func | Az Func |
> |---|:---:|:---:|:---:|
> | Long-running | No (15m) | No (60m) | No (10m) |
> | Exec | **No** | **No** | **No** |
> | Attach | **No** | **No** | **No** |
> | Log stream | Yes | Yes | Yes |
> | Log follow | No | No | No |
> | Volumes | No | No | No |
> | Networks | No | No | No |
> | Health checks | No | No | No |
> | Agent needed | No | No | No |

### AWS Lambda mapping (Spec Section 9.2)

> | Docker Concept | Lambda Mapping |
> |---|---|
> | Container create + start | Create/update Lambda function + invoke |
> | Container stop/kill | N/A (function exits on its own) |
> | Container logs | CloudWatch Logs |
> | Exec / Attach | **Not supported** (reported via capabilities) |
> | Image pull | Lambda pulls container images from ECR |
> | Max timeout | 15 minutes |
>
> **Capabilities:** `exec: false, attach: false, logs: true, logs_follow: false, max_timeout_seconds: 900, agent_required: false`

### Google Cloud Run Functions mapping (Spec Section 9.2)

> | Docker Concept | Cloud Run Functions Mapping |
> |---|---|
> | Container create + start | Deploy function (2nd gen, container-based) + invoke |
> | Container stop/kill | N/A |
> | Container logs | Cloud Logging |
> | Exec / Attach | **Not supported** |
> | Image pull | Functions pull from Artifact Registry |
> | Max timeout | 60 minutes (2nd gen) |
>
> **Capabilities:** `exec: false, attach: false, logs: true, logs_follow: false, max_timeout_seconds: 3600, agent_required: false`

### Azure Functions mapping (Spec Section 9.2)

> | Docker Concept | Azure Functions Mapping |
> |---|---|
> | Container create + start | Deploy function (custom container) + invoke |
> | Container stop/kill | N/A |
> | Container logs | Azure Monitor |
> | Exec / Attach | **Not supported** |
> | Image pull | Functions pull from ACR |
> | Max timeout | 5-10 minutes (consumption plan) |
>
> **Capabilities:** `exec: false, attach: false, logs: true, logs_follow: false, max_timeout_seconds: 600, agent_required: false`

### FaaS use cases (Spec Section 13.4)

> **FaaS backends ARE useful for:** Short-lived, fire-and-forget container workloads that don't need exec or attach -- batch processing, webhooks, scheduled tasks. These use cases work with `docker run` (create + start + logs + wait + remove) without exec or attach.

---

## Acceptance Criteria

### Lambda Module (`terraform/modules/lambda/`)

1. The module creates an IAM execution role with policies for: `AWSLambdaBasicExecutionRole` (CloudWatch Logs permissions), and `ecr:GetDownloadUrlForLayer`, `ecr:BatchGetImage`, `ecr:GetAuthorizationToken` (ECR image pull).
2. A CloudWatch Logs log group is created with configurable retention period (default 7 days) and a name pattern `/sockerless/lambda/${name_prefix}`.
3. An ECR repository is created with image scanning enabled, configurable image tag mutability (default `MUTABLE`), and a lifecycle policy that expires untagged images after 7 days.
4. A Lambda function configuration template resource is created (using `aws_lambda_function` with `package_type = "Image"`) with configurable memory (default 512 MB), timeout (default 900 seconds / 15 minutes), and environment variables.
5. Optional VPC configuration is supported via variables: `vpc_subnet_ids` and `vpc_security_group_ids`. When provided, the execution role is granted `AWSLambdaVPCAccessExecutionRole` permissions.
6. All resources are tagged with: `environment`, `project = "sockerless"`, `managed-by = "terraform"`, plus `extra_tags`.
7. Outputs include: `execution_role_arn`, `log_group_name`, `log_group_arn`, `ecr_repository_url`, `ecr_repository_arn`, `lambda_function_name`.

### Cloud Functions Module (`terraform/modules/gcf/`)

8. The module enables required GCP APIs: `cloudfunctions.googleapis.com` (Cloud Functions v2), `artifactregistry.googleapis.com`, `logging.googleapis.com`, `cloudbuild.googleapis.com` (required by Cloud Functions deployments), `run.googleapis.com` (2nd gen functions run on Cloud Run).
9. An Artifact Registry repository is created with Docker format for container images.
10. An IAM service account is created with roles: `roles/cloudfunctions.invoker` (invoke functions), `roles/logging.logWriter` (write logs), `roles/artifactregistry.reader` (pull images from Artifact Registry).
11. Cloud Logging is configured via the service account's logging permissions (no separate resource needed; Cloud Functions logs to Cloud Logging automatically).
12. Optional VPC connector is supported via `vpc_connector_id` variable. When provided, the function egress settings default to `PRIVATE_RANGES_ONLY`.
13. All resources are labeled with: `environment`, `project = "sockerless"`, `managed-by = "terraform"`, plus `extra_labels`.
14. Outputs include: `service_account_email`, `artifact_registry_repo`, `project_id`, `region`.

### Azure Functions Module (`terraform/modules/azf/`)

15. The module creates a resource group (or uses an existing one) via `create_resource_group` variable.
16. A storage account is created (required by Azure Functions runtime for triggers, bindings, and internal state) with Standard_LRS SKU and HTTPS-only.
17. An App Service Plan is created with `os_type = "Linux"` and configurable SKU (default `Y1` consumption plan; `EP1` for premium/elastic plan option).
18. An Azure Container Registry instance is created with configurable SKU (default `Basic`).
19. A user-assigned managed identity is created with RBAC roles: `AcrPull` on the ACR, `Storage Blob Data Contributor` on the storage account, `Monitoring Reader` on the resource group.
20. An Application Insights instance is created for monitoring and logs, connected to a Log Analytics workspace (created or referenced via variable).
21. All resources are tagged with: `environment`, `project = "sockerless"`, `managed-by = "terraform"`, plus `extra_tags`.
22. Outputs include: `resource_group_name`, `app_service_plan_id`, `storage_account_name`, `storage_account_connection_string` (sensitive), `acr_login_server`, `managed_identity_client_id`, `application_insights_instrumentation_key` (sensitive), `application_insights_connection_string` (sensitive).

### Lambda Test Environment (`terraform/environments/lambda-test/`)

23. The environment instantiates the Lambda module with cost-optimized defaults: 512 MB memory, 900s timeout, 7-day log retention, no VPC configuration.
24. State backend is configured as S3 with configurable bucket and key (default key `sockerless/lambda-test/terraform.tfstate`).
25. `terraform.tfvars.example` is provided with all required variables (AWS region, name prefix).
26. Outputs include all values needed by TST-015: `execution_role_arn`, `ecr_repository_url`, `log_group_name`, `lambda_function_name`, `region`.

### Cloud Functions Test Environment (`terraform/environments/gcf-test/`)

27. The environment instantiates the Cloud Functions module with test defaults: no VPC connector, minimal IAM scope.
28. State backend is configured as GCS with configurable bucket and prefix (default prefix `sockerless/gcf-test`).
29. `terraform.tfvars.example` is provided with all required variables (GCP project ID, region).
30. Outputs include all values needed by TST-015: `service_account_email`, `artifact_registry_repo`, `project_id`, `region`.

### Azure Functions Test Environment (`terraform/environments/azf-test/`)

31. The environment instantiates the Azure Functions module with cost-optimized defaults: consumption plan (Y1 SKU), Basic ACR, 30-day log retention.
32. State backend is configured as Azure Blob with configurable storage account, container, and key (default key `sockerless/azf-test/terraform.tfstate`).
33. `terraform.tfvars.example` is provided with all required variables (subscription ID, location).
34. Outputs include all values needed by TST-015: `resource_group_name`, `app_service_plan_id`, `acr_login_server`, `storage_account_name`, `managed_identity_client_id`, `application_insights_connection_string`.

### Cross-Cutting

35. `terraform validate` passes with zero errors in all three modules and all three test environments.
36. `terraform fmt -check` passes with zero formatting deviations in all files.
37. Each module has a `README.md` documenting usage, variables, and outputs.
38. Each test environment has a `README.md` documenting prerequisites, setup, output mapping to backend environment variables, and teardown.
39. No hard-coded account IDs, project IDs, subscription IDs, or credentials in any file.
40. Provider version constraints are pinned to minor version across all modules (AWS `~> 5.0`, Google `~> 5.0`, AzureRM `~> 4.0`).

---

## Definition of Done

### Code Quality
- [ ] `terraform validate` passes with zero errors in all 6 directories (3 modules + 3 environments)
- [ ] `terraform fmt -check` passes with zero formatting deviations in all files
- [ ] `terraform fmt -recursive` produces no changes from the `terraform/` root
- [ ] No deprecated resource types or provider features used
- [ ] Provider version constraints are pinned to minor version
- [ ] All variables have type constraints, descriptions, and validation rules where appropriate
- [ ] No hard-coded account identifiers or credentials

### Testing
- [ ] `terraform plan` succeeds with valid credentials in each environment (dry run, no apply required for DoD)
- [ ] All outputs are defined and referenced correctly
- [ ] Variable defaults are sensible for test environments (cost-optimized)
- [ ] Modules can be instantiated multiple times with different `name_prefix` values (no naming collisions)

### Documentation
- [ ] `README.md` in each module directory with usage example, input variables table, and outputs table
- [ ] `README.md` in each environment directory with prerequisites, setup, and teardown
- [ ] `terraform.tfvars.example` in each environment with all required variables documented
- [ ] Inline comments on non-obvious configuration choices

### Integration
- [ ] Lambda module outputs match the configuration keys expected by the Lambda backend (LAM-001)
- [ ] Cloud Functions module outputs match the configuration keys expected by the Cloud Functions backend (GCF-001)
- [ ] Azure Functions module outputs match the configuration keys expected by the Azure Functions backend (AZF-001)
- [ ] All test environment outputs provide values needed by TST-015 (FaaS capability tests)
- [ ] State backend configurations are consistent with TF-001 conventions

---

## Suggested File Paths

```
terraform/modules/lambda/
├── main.tf                    # IAM role, Lambda function, CloudWatch log group
├── variables.tf               # Input variables
├── outputs.tf                 # Outputs for backend configuration
├── ecr.tf                     # ECR repository and lifecycle policy
├── iam.tf                     # Execution role and policies
├── versions.tf                # Terraform and AWS provider version constraints
└── README.md                  # Module documentation

terraform/modules/gcf/
├── main.tf                    # API enablement, Artifact Registry, service account
├── variables.tf               # Input variables
├── outputs.tf                 # Outputs for backend configuration
├── iam.tf                     # Service account and IAM bindings
├── versions.tf                # Terraform and Google provider version constraints
└── README.md                  # Module documentation

terraform/modules/azf/
├── main.tf                    # Resource group, App Service Plan, Application Insights
├── variables.tf               # Input variables
├── outputs.tf                 # Outputs for backend configuration
├── storage.tf                 # Storage account
├── acr.tf                     # Azure Container Registry
├── identity.tf                # Managed identity and RBAC
├── versions.tf                # Terraform and AzureRM provider version constraints
└── README.md                  # Module documentation

terraform/environments/lambda-test/
├── main.tf                    # Module instantiation
├── variables.tf               # Input variables (region, name_prefix)
├── outputs.tf                 # Outputs for test runner
├── providers.tf               # AWS provider configuration
├── backend.tf                 # S3 remote state backend
├── terraform.tfvars.example   # Example variable values
└── README.md                  # Setup and teardown

terraform/environments/gcf-test/
├── main.tf                    # Module instantiation
├── variables.tf               # Input variables (project_id, region)
├── outputs.tf                 # Outputs for test runner
├── providers.tf               # Google provider configuration
├── backend.tf                 # GCS remote state backend
├── terraform.tfvars.example   # Example variable values
└── README.md                  # Setup and teardown

terraform/environments/azf-test/
├── main.tf                    # Module instantiation
├── variables.tf               # Input variables (subscription_id, location)
├── outputs.tf                 # Outputs for test runner
├── providers.tf               # AzureRM provider configuration
├── backend.tf                 # Azure Blob remote state backend
├── terraform.tfvars.example   # Example variable values
└── README.md                  # Setup and teardown
```

---

## Notes

- **Lambda:** The Lambda function resource in the module serves as a template configuration. The actual Lambda function creation and invocation happen in the Lambda backend (LAM-001) at runtime. The Terraform module ensures the IAM role, ECR repo, and log group exist. The backend uses the execution role ARN and ECR repo URL from the module outputs.
- **Lambda VPC:** Most FaaS use cases do not require VPC connectivity. The VPC option is provided for edge cases where Lambda functions need to access VPC resources. When VPC is enabled, cold start latency increases significantly (10-30s). Document this tradeoff.
- **Cloud Functions:** 2nd gen Cloud Functions are built on Cloud Run. The module enables both `cloudfunctions.googleapis.com` and `run.googleapis.com` APIs. The `cloudbuild.googleapis.com` API is required because Cloud Functions uses Cloud Build to build container images during deployment.
- **Cloud Functions Artifact Registry:** The repository stores container images deployed as functions. Cloud Functions v2 can deploy directly from container images in Artifact Registry, which aligns with the Sockerless pattern of pushing pre-built images.
- **Azure Functions consumption plan:** The Y1 (consumption) SKU is pay-per-execution with a generous free tier (1 million executions/month). This is the most cost-effective option for testing. The EP1 (elastic premium) SKU provides pre-warmed instances and VNet integration but has a minimum monthly cost (~$100/month).
- **Azure Functions storage account:** Azure Functions requires a storage account for its internal operation (function metadata, trigger state, logs). This is separate from the application's data storage needs. The storage account name must be globally unique.
- **Application Insights:** Azure Functions integrates natively with Application Insights for monitoring, tracing, and log querying. The instrumentation key or connection string is passed to the function app as a configuration setting.
- **Cost estimates for idle test environments:** Lambda: $0 (no idle cost). Cloud Functions: $0 (no idle cost, but Artifact Registry has minimal storage cost ~$0.10/GB/month). Azure Functions consumption plan: ~$1-2/month (storage account minimum).
- **State backend bootstrapping:** Each test environment needs its state backend created before `terraform init`. Provide bootstrap scripts or Makefile targets for each cloud provider. This is consistent with the pattern from TF-003 and TF-005.
- **Cross-provider consistency:** All three modules follow the same structural conventions: `main.tf` for primary resources, `variables.tf` for inputs, `outputs.tf` for outputs, `versions.tf` for constraints. This makes navigation consistent across the project.
- **IAM principle of least privilege:** All IAM roles and policies should follow least-privilege. Avoid granting broad permissions (e.g., `AdministratorAccess`, `Owner`, `roles/editor`). The module documentation should list the exact permissions granted and why.
- **ECR lifecycle policy:** The lifecycle policy ensures untagged images are cleaned up after 7 days, preventing unbounded storage growth during testing. Tagged images are retained indefinitely unless explicitly deleted.
- **Module versioning:** Since all modules are in the same repository, they are versioned together. Use relative paths (`../../modules/lambda/`) in environment configurations. If the modules are later published to a registry, update the source to use versioned references.
