# ACA-002: ACA container operations

**Component:** ACA (Azure Container Apps backend)
**Phase:** 3
**Depends on:** ACA-001, AG-005
**Estimated effort:** XL

---

## Description

Implement `ContainerCreate`, `ContainerStart`, `ContainerStop`, `ContainerKill`, `ContainerRemove`, `ContainerInspect`, `ContainerList`, and `ContainerWait` for the ACA backend. Container create provisions an Azure Container Apps Job from the container config (image, env, cmd, resource limits, volumes, network). Container start calls `Start Job Execution`, polls the execution until it reaches Running state, resolves the agent address from the container's VNet IP, and verifies agent readiness before returning. The start call MUST block until the container is actually running -- this is critical because CI runners check container status immediately after start.

---

## Context

### ACA container mapping (Spec Section 9.1)

> | Docker Concept | ACA Mapping |
> |---|---|
> | Container create + start | `Create Job` + `Start Job Execution` |
> | Container stop | `Stop Job Execution` |
> | Container logs | Azure Monitor / Log Analytics |
> | Exec / Attach | Via sockerless-agent (agent on container port, VNet accessible) |
> | Image pull | ACA pulls from ACR / Docker Hub natively |
> | Network | VNet integration (managed environment) |
> | Volume | Azure Files, ephemeral storage |

### Near-instant container start (Spec Section 13.3, Gap 2)

> **Problem:** After `docker start`, the runner immediately runs `docker ps --filter status=running` to verify the container started. Docker containers start in <1s. Cloud backends take 5-60s.
>
> **Solution:** The `POST /containers/{id}/start` endpoint MUST block until the cloud task is actually running (agent is reachable). Only then return `204 No Content`. This way, the subsequent `docker ps` check sees "running" status.
>
> **Implementation:** Backend launches cloud task -> polls cloud API for task status -> returns 204 only when task is in "RUNNING" state. Frontend forwards the 204 to the Docker client.

### Agent injection (Spec Section 8.6)

> The backend modifies the container's entrypoint to: `["/sockerless-agent", "--", <original-entrypoint>]`
>
> The agent starts the original command as a child process and serves WebSocket connections for exec/attach.
>
> For ACA, agent injection uses **sidecar container** or **volume mount** from Azure Files:
> | Method | Description | Best For |
> |---|---|---|
> | **Volume mount** | Mount agent binary from Azure Files and prepend to entrypoint | ACA |
> | **Init container** | Run init container that copies agent binary to shared volume | ACA |

### Agent readiness (Spec Section 13.3, Gap 11)

> **Agent readiness check:** Backend polls `ws://agent:9111/health` (a simple HTTP GET on the same port). Agent responds with `200 OK` once its WebSocket server is accepting connections. Backend only returns `204` from start once this check passes.

### ACA status mapping

Container Apps Job execution states must be mapped to Docker container states:

| ACA Execution Status | Docker State |
|---|---|
| `Running` | `running` |
| `Succeeded` | `exited` (exit code 0) |
| `Failed` | `exited` (exit code non-zero) |
| `Degraded` / `Processing` | `running` (still starting) |
| `Stopped` | `exited` |
| (job created, not started) | `created` |

---

## Acceptance Criteria

1. `ContainerCreate` accepts a `ContainerCreateRequest` and creates an Azure Container Apps Job via the `armappcontainers` SDK.
2. The job definition maps: `Image` -> container image, `Env` -> environment variables, `Cmd` -> command, `Entrypoint` -> entrypoint args.
3. CPU and memory are mapped from Docker's resource limits: `HostConfig.NanoCPUs` / `HostConfig.CpuShares` -> ACA container CPU (0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 4.0), `HostConfig.Memory` -> ACA container memory (0.5Gi-8Gi). Defaults: 0.25 CPU, 0.5Gi memory.
4. The job is configured with `triggerType: "Manual"` and `replicaCompletionCount: 1`.
5. Registry credentials from configuration are applied to the job (ACR managed identity or username/password, Docker Hub credentials).
6. The agent is injected into the container: the entrypoint is modified to `["/sockerless-agent", "--", <original-entrypoint>, <original-cmd>...]` or `["/sockerless-agent", "--keep-alive", "--"]` for tail-f-dev-null containers. Agent env vars (`SOCKERLESS_AGENT_PORT`, `SOCKERLESS_AGENT_TOKEN`) are added.
7. A unique agent token is generated (32 random bytes, hex-encoded) and stored in the state for later retrieval by the frontend.
8. The container is stored in the state with status `"created"` and a generated 64-char hex ID. The state includes the job name, agent token, and all original config.
9. `ContainerCreate` returns `ContainerCreateResponse` with the generated ID and any warnings.
10. `ContainerStart` calls `Start Job Execution` on the created job.
11. `ContainerStart` polls the job execution status at 2-second intervals until the execution status is `Running`. Maximum wait: 5 minutes (configurable). If the execution fails to start (status `Failed`), return an error with the failure reason.
12. Once the execution is Running, the backend resolves the container's IP address from the execution's replica properties within the VNet.
13. The backend constructs the agent address as `<container-ip>:9111` and stores it in the container state.
14. The backend polls `http://<agent-address>/health` until the agent responds with `200 OK`. Timeout: 60 seconds. Poll interval: 1 second.
15. Only after the agent is confirmed ready does `ContainerStart` return success (204).
16. Container state is updated to `"running"` with `StartedAt` timestamp.
17. `ContainerStop` calls the stop execution API. Container state updated to `"exited"`.
18. `ContainerKill` maps to the same stop execution API (ACA has no signal-level granularity; documents this as a known limitation).
19. `ContainerRemove` deletes the Container Apps Job. If `force=true`, stops the execution first.
20. `ContainerInspect` returns full container metadata with state, config, host config, and network settings. ACA execution status is mapped to Docker state per the status mapping table.
21. `ContainerList` returns all containers from the state store, filtered by label, id, name, status. The `all` flag includes stopped/exited containers.
22. `ContainerWait` long-polls until the execution reaches a terminal state (`Succeeded`, `Failed`, `Stopped`), then returns the exit code.
23. Labels from the container create request are applied as tags on the Container Apps Job resource.

### Example SDK Calls

```go
// Create Job
client.BeginCreateOrUpdate(ctx, resourceGroup, jobName, armappcontainers.Job{
    Location: &location,
    Properties: &armappcontainers.JobProperties{
        EnvironmentID: &managedEnvironmentID,
        Configuration: &armappcontainers.JobConfiguration{
            TriggerType:            to.Ptr(armappcontainers.TriggerTypeManual),
            ReplicaTimeout:         to.Ptr[int32](3600),
            ReplicaRetryLimit:      to.Ptr[int32](0),
            Registries:             registries,
        },
        Template: &armappcontainers.JobTemplate{
            Containers: []*armappcontainers.Container{{
                Name:    &containerName,
                Image:   &image,
                Command: command,
                Env:     envVars,
                Resources: &armappcontainers.ContainerResources{
                    CPU:              to.Ptr[float64](0.25),
                    Memory:           to.Ptr("0.5Gi"),
                },
            }},
            Volumes: volumes,
        },
    },
}, nil)

// Start Job Execution
client.BeginStart(ctx, resourceGroup, jobName,
    armappcontainers.JobExecutionTemplate{}, nil)

// Get Job Execution (polling)
client.GetExecution(ctx, resourceGroup, jobName, executionName, nil)
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests with mock Azure clients for: job creation, Start Job Execution call, execution status polling (running, failed, timeout), IP extraction, agent readiness polling, agent token generation, tail-f-dev-null detection and keep-alive flag, status mapping
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Azure API errors mapped to Docker-compatible error responses
- [ ] Execution startup failures include Azure error details in error message
- [ ] Agent unreachable after execution Running produces clear error
- [ ] Errors wrapped with context: `fmt.Errorf("aca: container start: %w", err)`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated with container lifecycle details

### Integration
- [ ] State store updated correctly for each lifecycle transition
- [ ] Agent injection compatible with AG-005 (keep-alive) and AG-002/AG-003 (exec/attach)
- [ ] Job tags include sockerless container ID for later lookup

---

## Suggested File Paths

```
backends/aca/
├── container_create.go      # ContainerCreate: job creation, state creation
├── container_start.go       # ContainerStart: start execution, polling, IP extraction, agent readiness
├── container_ops.go         # ContainerStop, Kill, Remove, Inspect, List, Wait
├── jobdef.go                # Job definition builder (maps Docker config -> ACA job)
├── agent_inject.go          # Agent entrypoint modification, token generation
├── status.go                # ACA execution status -> Docker state mapping
├── store.go                 # (update) Container state with job name, agent address, agent token
└── errors.go                # (update) ACA-specific error mapping
```

---

## Notes

- ACA resource mappings: CPU must be one of 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, or 4.0 cores. Memory must match CPU tier (e.g., 0.25 CPU allows 0.5Gi memory). Use the closest valid combination that meets or exceeds the Docker request. If no limits are specified, default to 0.25 CPU / 0.5Gi memory.
- Job names have restrictions: lowercase letters, numbers, and hyphens only, 2-32 characters, must start with a letter. Generate names like `sk-<container-id-prefix-12>` to stay within limits.
- The `BeginCreateOrUpdate` and `BeginStart` methods return pollers (long-running operations). Use the poller's `PollUntilDone` or manual polling to wait for completion.
- For agent binary injection, the initial approach requires the agent binary in the container image (either baked in or via an init container that copies from Azure Files to a shared ephemeral volume). Document the requirement that images must include the agent binary at `/sockerless-agent`.
- The tail-f-dev-null detection: check if `Entrypoint == ["tail"]` and `Cmd == ["-f", "/dev/null"]`. Also check variations like `Entrypoint == ["tail", "-f", "/dev/null"]` with empty Cmd.
- Container IP resolution within the VNet depends on the managed environment's networking configuration. The environment must be VNet-integrated (`vnetConfiguration` set during environment creation). The execution replica's IP is accessible within that VNet.
- Consider implementing eager container provisioning: when `ContainerCreate` is called, begin provisioning the ACA job immediately (not waiting for `ContainerStart`). This reduces perceived startup latency. However, this is an optimization that can be added later.
