# MEM-003: Memory backend exec operations

**Component:** In-memory Backend
**Phase:** 1
**Depends on:** MEM-001
**Estimated effort:** M

---

## Description

Implement exec create, start (simulated), and inspect operations in the memory backend. Since the memory backend does not run real processes, exec "runs" by returning synthetic output (e.g., echoing the command that would have been executed). This provides the API surface needed for integration tests to verify the exec protocol without requiring a real agent or container runtime.

---

## Context

### Exec create (Spec Section 4.4)

Request body:
```json
{
  "AttachStdin": true,
  "AttachStdout": true,
  "AttachStderr": true,
  "Tty": false,
  "Cmd": ["sh", "-c", "echo hello"],
  "Env": ["FOO=bar"],
  "WorkingDir": "/app"
}
```

Response: `{"Id": "<exec-id>"}`

Records the exec configuration. Does not execute anything yet.

### Exec start (Spec Section 4.4)

Request body: `{"Detach": false, "Tty": false}`

When `Detach: false`, the exec command runs and streams stdout/stderr. For the memory backend, this is simulated -- the backend returns a synthetic response without actually running a process.

### Exec inspect (Spec Section 4.4)

```json
{
  "ID": "<exec-id>",
  "Running": false,
  "ExitCode": 0,
  "Pid": 0
}
```

### Internal API endpoints for exec (Spec Section 7.3)

| Method | Path | Operation |
|--------|------|-----------|
| `POST` | `/internal/v1/containers/{id}/exec` | Create exec instance |
| `GET` | `/internal/v1/exec/{id}` | Inspect exec instance |

Note from spec: `POST /exec/{id}/start` is NOT proxied through the backend. The frontend handles exec streaming directly by connecting to the agent. The backend only stores exec metadata.

### Agent not needed for memory backend (Spec Section 6.5)

> **When the agent is NOT needed:**
> - Docker backend: uses Docker's native exec/attach
> - Memory backend: direct in-process execution

### Memory backend exec behavior (Spec Section 9.4)

> All state is in-memory, containers are simulated (no actual processes run). Exec returns mock output.

---

## Acceptance Criteria

1. `POST /internal/v1/containers/{id}/exec` accepts a JSON body with `Cmd` (required), `Env`, `WorkingDir`, `Tty`, `AttachStdin`, `AttachStdout`, `AttachStderr` fields.
2. Returns `{"Id": "<exec-id>"}` with a unique exec ID (hex string).
3. Returns `409 Conflict` if the container is not in `running` state, with `{"message": "Container <id> is not running"}`.
4. Returns `404` if the container does not exist, with `{"message": "No such container: <id>"}`.
5. The exec instance is stored in the execs map with `Running: false`, `ExitCode: 0`, linked to the parent container ID.
6. `GET /internal/v1/exec/{id}` returns the exec instance with `ID`, `Running`, `ExitCode`, `Pid`, `ContainerID`, and the original `Cmd`.
7. `GET /internal/v1/exec/{id}` returns `404` if the exec ID does not exist.
8. After exec start is simulated (triggered by the frontend or test), the exec record transitions to `Running: false`, `ExitCode: 0` (successful completion).
9. The memory backend provides a `SimulateExecStart(execID)` method (or equivalent) that marks the exec as completed with synthetic output, for use by the frontend's exec start handler.
10. Synthetic output for a simulated exec is the command itself echoed back, e.g., for `Cmd: ["echo", "hello"]`, output is `"echo hello\n"`.

### Example Requests

```bash
# Create exec on a running container
curl --unix-socket /var/run/sockerless-backend.sock \
  -X POST http://localhost/internal/v1/containers/abc123/exec \
  -H "Content-Type: application/json" \
  -d '{"Cmd":["sh","-c","echo hello"],"AttachStdout":true,"AttachStderr":true}'
# Expected: 201 {"Id": "exec-a1b2c3..."}

# Inspect exec
curl --unix-socket /var/run/sockerless-backend.sock \
  http://localhost/internal/v1/exec/exec-a1b2c3
# Expected: 200
# {"ID":"exec-a1b2c3...","Running":false,"ExitCode":0,"Pid":0}

# Create exec on non-running container
curl --unix-socket /var/run/sockerless-backend.sock \
  -X POST http://localhost/internal/v1/containers/stopped123/exec \
  -H "Content-Type: application/json" \
  -d '{"Cmd":["echo","hello"]}'
# Expected: 409 {"message": "Container stopped123 is not running"}

# Create exec on non-existent container
curl --unix-socket /var/run/sockerless-backend.sock \
  -X POST http://localhost/internal/v1/containers/nonexistent/exec \
  -H "Content-Type: application/json" \
  -d '{"Cmd":["echo","hello"]}'
# Expected: 404 {"message": "No such container: nonexistent"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` updated

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] Exec create returns valid ID on running container
- [ ] Exec create rejects non-running and non-existent containers
- [ ] Exec inspect returns correct state
- [ ] Simulated exec produces synthetic output

---

## Suggested File Paths

```
backends/memory/
├── exec.go                    # ExecCreate and ExecInspect handlers, SimulateExecStart
└── store.go                   # (extended) PutExec, GetExec, ListExecsByContainer methods
```

---

## Notes

- Exec IDs should be generated the same way as container IDs (64-char hex via `crypto/rand`).
- The exec store should index by exec ID and also allow lookup by container ID (to list all execs for a container, useful for cleanup on container remove).
- Since the frontend handles `POST /exec/{id}/start` directly (it connects to the agent or simulates), the backend only needs to store exec metadata and provide a way to update the exec's `Running` and `ExitCode` fields.
- For the memory backend, the `SimulateExecStart` method should: set `Running: true` briefly, then set `Running: false, ExitCode: 0`. Since this is synchronous in-memory, the "running" state may be transient. The important thing is that after simulation, `ExitCode` is 0 and `Running` is false.
- When a container is removed, all associated exec instances should also be cleaned up from the store.
- Real exec requires the agent (Phase 2). The memory backend simulation is sufficient for Phase 1 protocol testing.
