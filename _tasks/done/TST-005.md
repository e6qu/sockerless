# TST-005: Exec endpoint tests

**Component:** Test Infrastructure and Suites
**Phase:** 1
**Depends on:** TST-001, FE-012, FE-013
**Estimated effort:** M

---

## Description

Black-box tests for exec endpoints: `POST /containers/{id}/exec` (create), `POST /exec/{id}/start` (start with hijacked stream), and `GET /exec/{id}/json` (inspect). Tests cover creation, error cases, state inspection, and the hijacked streaming protocol. Full exec testing requires the agent (Phase 2) -- the memory backend simulates exec by returning synthetic output.

---

## Context

### Exec create (Spec Section 4.4)

`POST /containers/{id}/exec`

Request body:
```json
{
  "AttachStdin": true,
  "AttachStdout": true,
  "AttachStderr": true,
  "Tty": false,
  "Cmd": ["sh", "-c", "echo hello"],
  "Env": ["FOO=bar"],
  "WorkingDir": "/app"
}
```

Response: `201 Created`
```json
{"Id": "<exec-id>"}
```

### Exec start (Spec Section 4.4)

`POST /exec/{id}/start`

Request body: `{"Detach": false, "Tty": false}`

Response: Connection hijack with multiplexed stream (same protocol as attach). `Content-Type: application/vnd.docker.multiplexed-stream`.

### Exec inspect (Spec Section 4.4)

`GET /exec/{id}/json`

```json
{
  "ID": "<exec-id>",
  "Running": false,
  "ExitCode": 0,
  "Pid": 0
}
```

### Multiplexed stream protocol (Spec Section 5.2)

Same 8-byte header framing as logs and attach:
```
[stream_type: 1 byte][0x00 0x00 0x00][size: 4 bytes big-endian][payload]
```

### Exec as primary mechanism for GitHub Actions (Spec Section 8.5)

> This is the **primary mechanism for GitHub Actions Runner** -- every workflow step is `docker exec` into the job container.

---

## Acceptance Criteria

### Exec Create

1. `POST /containers/{id}/exec` with a valid `Cmd` on a running container returns `201` with `{"Id": "<exec-id>"}`.
2. The exec ID is a non-empty string (hex format).
3. `POST /containers/{id}/exec` on a container that is not running returns `409` with `{"message": "Container <id> is not running"}`.
4. `POST /containers/{id}/exec` on a non-existent container returns `404` with `{"message": "No such container: <id>"}`.
5. `POST /containers/{id}/exec` without `Cmd` field returns `400` or appropriate error.

### Exec Start

6. `POST /exec/{id}/start` with `{"Detach": false, "Tty": false}` returns `101 Switching Protocols` or `200` with hijacked connection.
7. After hijack, stdout output arrives as multiplexed frames with stream_type = 1.
8. After hijack, the connection closes when the exec command completes.
9. `POST /exec/{id}/start` on a non-existent exec ID returns `404`.

### Exec Inspect

10. `GET /exec/{id}/json` before exec start returns `Running: false` (not yet started).
11. `GET /exec/{id}/json` after exec completes returns `Running: false` and `ExitCode: 0`.
12. `GET /exec/{id}/json` on a non-existent exec ID returns `404`.

### Integration

13. Full flow: create container -> start container -> exec create -> exec start (receive output) -> exec inspect (ExitCode: 0).

### Example Requests

```bash
# Prerequisites: create and start a container
curl --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/images/create?fromImage=alpine&tag=latest"
curl --unix-socket /var/run/sockerless.sock \
  -X POST "http://localhost/containers/create?name=exec-test" \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine:latest","Cmd":["tail","-f","/dev/null"]}'
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/exec-test/start

# Create exec
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/exec-test/exec \
  -H "Content-Type: application/json" \
  -d '{"Cmd":["echo","hello"],"AttachStdout":true,"AttachStderr":true}'
# Expected: 201 {"Id":"exec-abc123..."}

# Inspect exec
curl --unix-socket /var/run/sockerless.sock \
  http://localhost/exec/exec-abc123/json
# Expected: 200 {"ID":"exec-abc123...","Running":false,"ExitCode":0,"Pid":0}

# Exec on non-running container
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/stopped-container/exec \
  -H "Content-Type: application/json" \
  -d '{"Cmd":["echo","hello"]}'
# Expected: 409 {"message":"Container stopped-container is not running"}

# Exec on non-existent container
curl --unix-socket /var/run/sockerless.sock \
  -X POST http://localhost/containers/nonexistent/exec \
  -H "Content-Type: application/json" \
  -d '{"Cmd":["echo","hello"]}'
# Expected: 404 {"message":"No such container: nonexistent"}
```

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] New black-box REST tests written for new/changed behavior (in `tests/` module)
- [ ] Tests run against memory backend by default
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Custom error types used for all domain errors (not bare `errors.New`)
- [ ] Errors wrapped with context: `fmt.Errorf("operation: %w", err)`
- [ ] Zerolog structured logging on all error paths
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created or updated (if this task creates or modifies a module)

### Integration
- [ ] No breaking changes to the internal API contract
- [ ] Capability model updated if new backend capabilities are added

### Task-Specific
- [ ] All 13 acceptance criteria pass
- [ ] Reuses multiplexed frame parser from TST-004 helpers
- [ ] Tests pass against memory backend with synthetic output
- [ ] Exec start test has a timeout to avoid hanging

---

## Suggested File Paths

```
tests/
├── exec_test.go                   # TestExecCreate, TestExecStart, TestExecInspect, TestExecFullFlow
└── helpers/
    ├── exec.go                    # createExec, startExec, inspectExec helpers
    ├── mux_stream.go              # (from TST-004) reused for exec stream parsing
    └── hijack.go                  # (from TST-004) reused for exec hijack
```

---

## Notes

- Exec start uses the same connection hijacking protocol as attach. Reuse the hijack and mux stream helpers from TST-004.
- For the memory backend, exec start returns synthetic output (the echoed command). This is sufficient for validating the protocol and framing.
- Full exec testing with real command execution requires the agent (Phase 2) or the Docker backend. Consider adding a test that explicitly runs against the Docker backend with `t.Skip` when Docker is not available.
- The exec start endpoint requires a running container. Each exec test should set up a running container as a prerequisite (create + start + defer remove).
- Multiple exec instances can exist on the same container. Test creating two exec instances and verify they have different IDs.
- Exec IDs are separate from container IDs. The `GET /exec/{id}/json` endpoint uses the exec ID directly (not nested under containers).
- After exec completes, inspect should show `ExitCode: 0` for successful execution. For the memory backend, all simulated execs succeed.
