# AZF-001: Azure Functions backend

**Component:** AZF (Azure Functions backend)
**Phase:** 4
**Depends on:** API-002
**Estimated effort:** L

---

## Description

Build the Azure Functions backend for Sockerless. This backend translates internal API calls into Azure Functions operations, deploying and invoking functions using custom container image support. Like all FaaS backends, Azure Functions has hard limitations: no exec, no attach, no volumes, no networks, and no health checks. The backend reports these reduced capabilities so the frontend can return `501 Not Implemented` for unsupported operations.

Azure Functions supports custom container images deployed as function apps. Functions are created, invoked via HTTP triggers, and their output is retrieved from Azure Monitor (Application Insights / Log Analytics). The agent is NOT required -- there is no mechanism for exec or attach. Maximum timeout is 5-10 minutes on the Consumption plan.

This backend is suitable for short-lived, fire-and-forget container workloads such as batch processing, webhooks, and scheduled tasks. It is NOT compatible with CI runners (GitLab Runner, GitHub Actions Runner).

---

## Context

### Azure Functions backend mapping (Spec Section 9.2)

> | Docker Concept | Azure Functions Mapping |
> |---|---|
> | Container create + start | Deploy function (custom container) + invoke |
> | Container stop/kill | N/A |
> | Container logs | Azure Monitor |
> | Exec / Attach | **Not supported** |
> | Image pull | Functions pull from ACR |
> | Max timeout | 5-10 minutes (consumption plan) |
>
> **Capabilities:** `exec: false, attach: false, logs: true, logs_follow: false, max_timeout_seconds: 600, agent_required: false`

### Capability reporting (Spec Section 9.5)

> | Capability | Az Func |
> |---|:---:|
> | Long-running | No (10m) |
> | Exec | **No** |
> | Attach | **No** |
> | Log stream | Yes |
> | Log follow | No |
> | Volumes | No |
> | Networks | No |
> | Health checks | No |
> | Agent needed | No |
> | Startup latency | 1-5s |

### FaaS backend compatibility (Spec Section 13.4)

> FaaS backends (Lambda, Cloud Run Functions, Azure Functions) are NOT compatible with CI runners. This is a hard architectural limitation.
>
> Capability reporting prevents silent failures: FaaS backends report `exec: false, attach: false` in their capabilities. When the frontend receives an exec or attach request, it returns `501 Not Implemented` with `{"message":"This backend (azf) does not support exec. CI runners require exec-capable backends (ecs, cloudrun, aca, docker)."}`.
>
> FaaS backends ARE useful for: Short-lived, fire-and-forget container workloads that don't need exec or attach -- batch processing, webhooks, scheduled tasks.

### Backend configuration (Spec Section 15.3)

> Configuration follows the standard backend YAML format with Azure Functions-specific fields:
> ```yaml
> azf:
>   subscription_id: "..."
>   resource_group: sockerless-rg
>   location: eastus
>   storage_account: sockerlessstorage    # Required for Azure Functions
>   registry: sockerless.azurecr.io       # ACR registry
>   app_service_plan: ""                  # Empty = Consumption plan
>   timeout: 600                          # seconds (max 600 on Consumption)
> ```

---

## Acceptance Criteria

1. `sockerless-backend-azf` binary compiles and runs from `cmd/sockerless-backend-azf/main.go`.
2. Server listens on a Unix socket (default `/var/run/sockerless-backend.sock`) or TCP address for internal API requests.
3. Azure SDK clients are initialized for: Azure Functions management, Azure Monitor (Log Analytics / Application Insights).
4. Configuration loads from YAML file, environment variables, and CLI flags (priority: flags > env > file > defaults). Required config: `subscription_id`, `resource_group`, `location`, `storage_account`. Optional: `registry`, `app_service_plan` (default: Consumption plan), `timeout` (default `600`).
5. `GET /internal/v1/capabilities` returns the capability JSON with `backend: "azf"`, `agent_required: false`, `exec: false`, `attach: false`, `logs: true`, `logs_follow: false`, `volumes: false`, `networks: false`, `health_checks: false`, `max_timeout_seconds: 600`.
6. Container create maps to creating an Azure Function App with a custom container image from ACR. The container's `Image` field is used as the function app's container image reference. Returns a 64-char hex container ID.
7. Container start maps to invoking the Azure Function via its HTTP trigger URL. The function begins execution.
8. Container logs retrieves output from Azure Monitor (Application Insights or Log Analytics workspace) using the Azure Monitor query API. Supports `tail` and `timestamps` parameters. Does NOT support `follow` (returns immediately with available logs).
9. Container wait returns the function's exit status (0 for success, non-zero for failure/timeout) once invocation completes.
10. Container stop/kill are no-ops -- Azure Functions cannot be stopped mid-execution. Return success (idempotent).
11. Container remove deletes the Function App and removes state store entry.
12. Exec create, exec start, and attach requests return `501 Not Implemented` with message: `"This backend (azf) does not support exec. CI runners require exec-capable backends (ecs, cloudrun, aca, docker)."` (or similar for attach).
13. Image operations: image pull is a no-op (Azure Functions pulls from ACR natively), image inspect returns stored metadata.
14. Network and volume operations return `501 Not Implemented`.
15. In-memory or SQLite state store maps `container_id -> {function_app_name, function_url, resource_id, invocation_status, ...}` and `image_ref -> {config, digest, ...}`.
16. Azure SDK errors are mapped to Docker-compatible HTTP error responses: `{"message": "..."}`.
17. Azure credentials are loaded via the standard Azure Identity SDK credential chain (env vars, managed identity, Azure CLI, etc.).
18. Graceful shutdown on SIGTERM/SIGINT: drain in-flight requests, clean exit.
19. All requests logged via zerolog with method, path, status code, duration, and Azure request correlation IDs where applicable.

---

## Definition of Done

### Code Quality
- [ ] Code compiles: `go build ./...` passes with zero errors
- [ ] Lint passes: `golangci-lint run ./...` with zero warnings
- [ ] Vet passes: `go vet ./...` with zero warnings
- [ ] Race detector: `go test -race ./...` passes
- [ ] No new lint warnings introduced

### Testing
- [ ] All existing black-box REST tests continue to pass
- [ ] Unit tests for: configuration loading, capability reporting, state store CRUD, Azure error mapping, 501 responses for unsupported operations
- [ ] Tests use mock Azure clients (no real Azure calls in unit tests)
- [ ] Tests are deterministic (no flaky tests)

### Error Handling
- [ ] Azure SDK errors wrapped with context: `fmt.Errorf("azf: create function app: %w", err)`
- [ ] Zerolog structured logging on all error paths with Azure correlation IDs
- [ ] HTTP error responses use Docker's format: `{"message": "..."}`
- [ ] Unsupported operations return 501 with descriptive message

### Documentation
- [ ] GoDoc comments on all exported types, functions, methods, and constants
- [ ] Module `README.md` created with Azure Functions backend overview, configuration, prerequisites, and limitations

### Integration
- [ ] Implements Backend interface from API-002 (unsupported methods return NotImplementedError)
- [ ] Capability model accurately reflects Azure Functions backend limitations

---

## Suggested File Paths

```
backends/azure-functions/
├── go.mod                              # module github.com/sockerless/backend-azf, go 1.23
├── go.sum
├── README.md
├── server.go                           # HTTP server setup, route registration
├── capabilities.go                     # Capability reporting handler
├── config.go                           # YAML + env + flag config loading
├── azure.go                            # Azure SDK client initialization (functions mgmt, monitor)
├── containers.go                       # Container create (create function app), start (invoke), stop (no-op), remove (delete)
├── logs.go                             # Azure Monitor log retrieval (Log Analytics query)
├── store.go                            # State store (container_id -> function app mapping)
├── errors.go                           # Azure error -> HTTP error mapping
├── unsupported.go                      # 501 handlers for exec, attach, networks, volumes
└── cmd/
    └── sockerless-backend-azf/
        └── main.go                     # Binary entrypoint
```

---

## Notes

- Use the Azure SDK for Go (`github.com/Azure/azure-sdk-for-go/sdk/...`). Specifically `azfunctions` for management operations and `azidentity` for credential handling.
- Azure Functions custom container support requires a Function App configured with a container image from ACR. The Consumption plan has a 5-10 minute timeout; Premium plan supports up to 60 minutes but at higher cost.
- Function App names must be globally unique in Azure. Use a prefix (e.g., `skls-`) combined with a truncated/hashed sockerless container ID to avoid collisions.
- Azure Functions requires a Storage Account for internal state (triggers, bindings metadata). This is an Azure platform requirement, not a Sockerless concern -- the storage account must be pre-created.
- Azure Monitor / Application Insights log ingestion has a delay (typically 2-5 minutes for Log Analytics, shorter for Application Insights streaming). This is the longest log propagation delay among the three FaaS backends. Consider using Application Insights live metrics for lower latency where possible.
- The state store must map between sockerless's 64-char hex IDs and Azure resource IDs. Consider SQLite via `modernc.org/sqlite` (pure Go, no CGO) for persistence.
- Container stop/kill should be idempotent no-ops. Azure Functions run to completion or timeout.
- Import `github.com/sockerless/api` for shared types and the `Backend` interface.
